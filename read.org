* version control
** PROJECT github入门与实践
   :PROPERTIES:
   :COLUMNS:   %25ITEM %55CLOCK %30INTRODUCE %50TOPIC
   :END:
*** 社会化编程
    :PROPERTIES:
    :CLOCK:
    :TOPIC:     初步了解github理念
    :COMMAND:   watch follow pull request issue markdown
    :END:
    :以人为中心
    :免费无限git仓库
    :公司organization账户
    :问题分配issue bug管理系统tidd issueID
    :pull request仓库合并
    :markdown  @organization/user #issue
    :watch  news feed仓库提交信息
    :follow用户 在github上做了什么
*** git
   :LOGBOOK:  
   CLOCK: [2016-08-28 日 17:21]--[2016-08-28 日 17:37] =>  0:16
#+BEGIN: clocktable :maxlevel 2 :scope subtree
#+CAPTION: Clock summary at [2016-08-11 四 17:35]
| Headline     | Time   |      |
|--------------+--------+------|
| *Total time* | *0:23* |      |
|--------------+--------+------|
| \emsp git    |        | 0:23 |
#+END:

#+BEGIN: clocktable :maxlevel 2 :scope subtree
#+CAPTION: Clock summary at [2016-08-11 四 17:34]
| Headline     | Time   |      |
|--------------+--------+------|
| *Total time* | *0:23* |      |
|--------------+--------+------|
| \emsp git    |        | 0:23 |
#+END:

   CLOCK: [2016-08-08 一 22:38]--[2016-08-08 一 23:01] =>  0:23
   :END:      
   :PROPERTIES:
   :CLOCK:
   :TOPIC:     git相关操作
   :COMMAND:   clone init status commit log push pull branch merge
   :END:
   :终端 git bash
   :初始化姓名和邮箱 git config --globe user.name/user.email ""
   :设置ssh key
     1. 创建ssh-key  gen -t rsa -C "your_email@example.com"
     2. github添加公开密钥
   :克隆仓库 git clone
   :提高可读性  README.md
   :掌握markdown语法
   :未添加至git仓库 显示为untracked files
   :初始化仓库  git init
   :查看仓库状态  git status
   :向暂存区中添加文件  git add
   :保存仓库的历史记录  git commit
   :查看提交日志  git log
   :本地仓库与github同步  git push
   :查看更改前后的差别  git diff
   :显示分支一览表  git branch
   :创建、切换分支  git checkout -b / git branch  git checkout
   :合并分支 git merge
   :回溯历史版本  git reset
   :多人协作 不断从github库中push pull
*** github 
    :LOGBOOK:  
    CLOCK: [2016-08-28 日 20:07]--[2016-08-28 日 23:27] =>  3:20
     CLOCK: [2016-08-28 日 17:39]--[2016-08-28 日 18:05] =>  0:26
     :END:      
    :PROPERTIES:
    :CLOCK:
    :INTRODUCE:     全方位了解网页版github全部功能
    :TOPIC:   
    :END:
**** 快捷键
     :LOGBOOK:  
     CLOCK: [2016-08-28 日 23:27]--[2016-08-28 日 23:30] =>  0:03
     :END:      
     :PROPERTIES:
     :CLOCK:
     :INTRODUCE:     方便操作
     :TOPIC:   shitt + /
     :END:
     - 显示快捷键一览表 shift+/
**** 工具栏
     :LOGBOOK:  
     CLOCK: [2016-08-28 日 23:30]--[2016-08-28 日 23:34] =>  0:04
     :END:      
     :PROPERTIES:
     :CLOCK:
     :INTRODUCE:     出现LOGO那一行
     :TOPIC:   LOGO Notifications *explore* *Gist*
     :END:
     - LOGO 点击进入控制面板
     - Notifications  用户有新建issure 评论 pull request 等会收到通知
     - 搜索窗口 查询用户代码片段信息
    *- explore 从各个角度介绍热门软件 了解最尖端的技术和软件*
    *- Gist 管理没必要保存在仓库中的代码片段 可以方便的为他人编写代码示例*
     - Blog 官方博客链接
     - Help 帮助文档
     - Setting 仓库内置相关选项
**** 控制面板
     :LOGBOOK:  
     CLOCK: [2016-08-28 日 23:34]--[2016-08-28 日 23:37] =>  0:03
     :END:      
     :PROPERTIES:
     :CLOCK:
     :INTRODUCE:     点击LOGO后出现的网页
     :TOPIC:   *News Feed*  Issue Star  Your Repositories
     :END:
    *- News Feed  用户follow和项目watch信息 可通过rss查看*
     - Pull Request  方便追踪Pull Request后续情况
     - Issue  一并查看多个项目的Issue
     - Star  给项目添加标签 方便查找
     - Your Repositories  私有共有和fork的仓库
**** 个人信息 https://github.com/用户名
     :LOGBOOK:  
     CLOCK: [2016-08-28 日 23:37]--[2016-08-28 日 23:41] =>  0:04
     :END:      
     :PROPERTIES:
     :CLOCK:
     :INTRODUCE:     点击个人头像<Your Profile>
     :TOPIC:   Profile Overview Contributs
     :END:
     - Profile 包括姓名 邮箱 所属公司 organization 可以点击follow
     - Overview  显示个人仓库中最受欢迎的
     - Contributs  按时间顺序显示pull request
**** 仓库 https://github.com/用户名/仓库名
     :LOGBOOK:  
     CLOCK: [2016-08-28 日 23:41]--[2016-08-28 日 23:53] =>  0:12
     :END:      
     :PROPERTIES:
     :CLOCK:
     :INTRODUCE:     在个人信息网页中点击一个仓库名
     :TOPIC:         watch star fork code issue <p的第十行 url尾部会添加#L10 程序员讨论时 可以明确指向某一行
    *- 仓库界面按t  模糊搜索相关文件*
**** *:查看差别*
     :LOGBOOK:  
     CLOCK: [2016-08-28 日 23:56]--[2016-08-28 日 23:58] =>  0:02
     :END:      
     :PROPERTIES:
     :CLOCK:
     :INTRODUCE:     通过 url 进行仓库软件进行比对
     :TOPIC:         各版本之间 指定时间 指定日期
     :END:
     - https://github.com/rails/rails/compare/4-0-stable...3-2-stable  查看4-0版本与3-2的稳定版本之间的差别
     - https://github.com/rails/rails/compare/master@{7.day.ago}...master  查看master分支在7天内的差别 {day week month year} 差别过大只会显示部分
     - https://github.com/rails/rails/compare/master@{2013-01-01}...master  查看与指定日期之间的差别
**** Issue
     :LOGBOOK:  
     CLOCK: [2016-08-29 一 08:41]--[2016-08-29 一 08:54] =>  0:13
     CLOCK: [2016-08-29 一 00:33]--[2016-08-29 一 08:34] =>  8:01
     CLOCK: [2016-08-28 日 23:58]--[2016-08-29 一 00:33] =>  0:35
     :END:      
     :PROPERTIES:
     :CLOCK:
     :INTRODUCE:     bug报告 询问 探讨 今后任务
     :TOPIC:         GFW Label milestones 通过commit操纵issue
     :END:
     - GFW  富文本描述
       #+Name: <语法高亮>
       #+BEGIN_SRC <markdown>
          ````ruby
          def hello_world
              puts 'hello world'
          end
          ````
       #+END_SRC

       #+Name: <复选列表样式>
       #+BEGIN_SRC <Tasklist>
          # 本月要做的任务
            - [ ]完成图片
            - [x] 完成部署工具的设置
            - [ ] 实现抽签功能
       #+END_SRC
     - 添加图片  直接拖拽
    *- 添加标签(label)  积攒到一定数量 筛选管理*
    *- 添加里程碑(milestones)  完成下一个版本还剩下几个issue 完成度 ?%*
     - 规范  有些仓库软件会对 issue 界面进行规范制定 请仔细阅读
    *- 通过提交信息操作issue*
       #+Name: <在提交信息中显示issue号>
       #+BEGIN_SRC <commit>
          Add feature user add #24  ;;#24为issue号
       #+END_SRC

       #+Name: <在commit中关闭issue>
       #+BEGIN_SRC <commit>
          fix #24
          fixs #24
          fixed #24
          close #24
          closes #24
          closed #24
          resolve #24
          resolves #24
          resolved #24
       #+END_SRC
     - issue与pull request编号相互通用
**** *Pull Request*
     :LOGBOOK:  
     CLOCK: [2016-08-29 一 08:55]--[2016-08-29 一 11:20] =>  2:25
     :END:      
     :PROPERTIES:
     :CLOCK:
     :INTRODUCE:     开源开发核心功能 [[流程]]
     :TOPIC:         conversation commit <files changed>
     :END:
     #+Name: <获取 diff 与 patch 格式文件>
     #+BEGIN_SRC <https>
       https://github.com/用户名/仓库名/pull/28
       https://github.com/用户名/仓库名/pull/28.diff
       https://github.com/用户名/仓库名/pull/28.patch
     #+END_SRC
     - 按R引用评论内容  选中评论中某一段 在按R
     - 在评论中使用表情  在评论中使用:启动表情自动补全功能
     - commit  该骂更改提交次数
     - Files Changed  更改的文件内容前后差别 标签上数字显示文件数
       - 不显示空格的差别  url 末尾添加 ?w=1
       *- 在修改代码左侧点击＋  针对修改的代码进行评论*
**** Wiki
     :LOGBOOK:  
     CLOCK: [2016-08-29 一 11:20]--[2016-08-29 一 11:31] =>  0:11
     :END:      
     :PROPERTIES:
     :CLOCK:
     :INTRODUCE:     一个简单的软件文档
     :TOPIC:         page
     :END:
     - page  显示所有相关的页面
**** Pulse
     :LOGBOOK:  
     CLOCK: [2016-08-29 一 11:32]--[2016-08-29 一 11:47] =>  0:15
     :END:      
     :PROPERTIES:
     :CLOCK:
     :INTRODUCE:     判断软件是否在积极开发 认真进行bug维护
     :TOPIC:         <active pull request> <active issue>
     :END:
     - active pull request  所有合并以及未合并的pull request
       - merged  已合并的pull request 点击可查看链接
       - proposed  处于开放状态未合并的pull request
     - active issue  open和close的issue
     - commit
**** Graphs
     :LOGBOOK:  
     CLOCK: [2016-08-29 一 13:42]--[2016-08-29 一 13:55] =>  0:13
     :END:      
     :PROPERTIES:
     :CLOCK:
     :INTRODUCE:     仓库信息统计汇总
     :TOPIC:         contributes <commit activate> <code frequency> punchcard member
     :END:
     - contributes  了解代码编写人 分析维护和稳定阶段
     - commit activate  判断是否有人在积极更新
     - code frequency  代码增加量和减少量
    *- punchcard  直观显示哪个时段收到的提交次数最多 用来判断发送pull request在哪个时段内会被处理 软件开发集中在哪个时间段*
     - menmber  所有fork仓库信息
**** Setting
     :LOGBOOK:  
     CLOCK: [2016-08-29 一 13:55]--[2016-08-29 一 14:07] =>  0:12
     :END:      
     :PROPERTIES:
     :CLOCK:
     :INTRODUCE:     仓库信息设置
     :TOPIC:         Option Collaborators <Webhook & Server> <Deploy key>
     :END:
     - Option
       - github page
       - Danger Zone
       - feature
    *- Collaborators*  允许其他用户对仓库进行编辑
       - organization  建议赋予组织权限
     - Webhook & Server
     - Deploy key
**** Notifications
     :LOGBOOK:  
     CLOCK: [2016-08-29 一 14:08]--[2016-08-29 一 14:20] =>  0:12
     :END:      
     :PROPERTIES:
     :CLOCK:
     :INTRODUCE:     实时更新个人相关 issue <pull request> 状态
     :TOPIC:         
     :END:
**** 其他
     :LOGBOOK:  
     CLOCK: [2016-08-29 一 14:22]--[2016-08-29 一 14:29] =>  0:07
     :END:      
     :PROPERTIES:
     :CLOCK:
     :INTRODUCE:     涵盖多领域的其他功能
     :TOPIC:         <github enterprice> <github job>
     :END:
**** 发送pull request
     :LOGBOOK:  
     CLOCK: [2016-09-01 四 13:06]--[2016-09-01 四 13:26] =>  0:20
     :END:      
     :PROPERTIES:
     :CLOCK:
     :INTRODUCE:     了解pull request发送流程 如何高效利用
     :TOPIC:         流程解析 高效开发 正在开发中[WIP]
     :END:
     - 流程 <<流程>>
       - 他人github仓库 : fork -> pull -> 创建特性分支 -> push -> pull request
         - fork到自己的github仓库 -> clone到本地 -> 本地创建分支进行编程 -> 推送到远程github仓库 -> 在branch中create new pull request
       - 自己的github仓库 : pull -> 创建特性分支 -> push -> pull request
     - 在开发过程中发送pull request进行讨论
       - 避免在开发完成后收到设计或功能上面的指正
     - 还没开发完成的特性 在标题中注释[WIP]
**** *仓库维护*
     :LOGBOOK:  
     CLOCK: [2016-09-01 四 13:45]--[2016-09-01 四 20:10] =>  6:25
     :END:      
     :PROPERTIES:
     :CLOCK:
     :INTRODUCE:     让编写的仓库保持最新状态
     :TOPIC:         clone remoting fetch <merge or pull>
     :END:
     - clone  先从原始仓库进行fork 再clone到本地
     - remoting  将 原始仓库 设置upstream名称
     - fetch  从 upstream 获取最新代码(fetch) 与 自己仓库的分支 进行合并
     - merge or pull
       - terminal  merge upstream into master
       - emacs magit  pull from upstream
**** *接收 pull request*
     :LOGBOOK:  
     CLOCK: [2016-09-02 五 08:22]--[2016-09-02 五 09:03] =>  0:41
     :END:      
     :PROPERTIES:
     :CLOCK:
     :INTRODUCE:     如何自动合手动合并 pull request
     :TOPIC:         PR发送者 PR接收者
     :END:
     - PR发送者
       - fork -> pull -> push -> pull request
       - 在本地克隆对方仓库环境 编码发送 PR
     - PR接收者
       - 自动合并
         - 在github上直接操作
           - auto merge
           - 在 PR 上讨论 修正后合并
       - 手动合并
         - clone -> fetch
         - 本地创建特性分支和 fetch 过来的对方仓库进行合并 确认无误后push到 github 仓库
**** 查看图片差别
     :LOGBOOK:  
     CLOCK: [2016-09-02 五 09:05]--[2016-09-02 五 09:09] =>  0:04
     :END:      
     :PROPERTIES:
     :CLOCK:
     :INTRODUCE:     提供各种查看图片的差别的方式
     :TOPIC:         同时显示 两侧分别显示 分阶段过渡到新图片 找茬 161
     :END:
*** github 相互协作的工具及服务
**** hub 命令
     :LOGBOOK:  
     CLOCK: [2016-09-02 五 10:08]--[2016-09-02 五 10:39] =>  0:31
     :END:      
     :PROPERTIES:
     :CLOCK:
     :INTRODUCE:     Github 的 API 命令
     :TOPIC:         172
     :END:
**** Travis CI
     :LOGBOOK:  
     CLOCK: [2016-09-02 五 10:40]--[2016-09-02 五 11:10] =>  0:30
     :END:      
     :PROPERTIES:
     :CLOCK:
     :INTRODUCE:     一款针对 github 持续集成的免费服务(开源免费)
     :TOPIC:         178
     :END:
**** Coveralls
     :LOGBOOK:  
     CLOCK: [2016-09-02 五 11:10]--[2016-09-02 五 11:27] =>  0:17
     :END:      
     :PROPERTIES:
     :CLOCK:
     :INTRODUCE:     检测代码测试覆盖率(开源免费)
     :TOPIC:         183
     :END:
**** Gemnasium
     :LOGBOOK:  
     CLOCK: [2016-09-02 五 11:27]--[2016-09-02 五 11:30] =>  0:03
     :END:      
     :PROPERTIES:
     :CLOCK:
     :INTRODUCE:     当前版本提醒(开源免费)
     :TOPIC:         187
     :END:
**** Code Climate
     :LOGBOOK:  
     CLOCK: [2016-09-02 五 11:30]--[2016-09-02 五 11:33] =>  0:03
     :END:      
     :PROPERTIES:
     :CLOCK:
     :INTRODUCE:     Github 的 API 命令(收费)
     :TOPIC:         188
     :END:
**** jenkins
     :LOGBOOK:  
     CLOCK: [2016-09-02 五 11:33]--[2016-09-02 五 16:45] =>  5:12
     :END:      
     :PROPERTIES:
     :CLOCK:
     :INTRODUCE:     持续集成的代表服务(免费)
     :TOPIC:         189
     :END:
*** github 开发流程
**** *Git Flow*
***** *Git Flow 以部署为中心的开发模式*
      :LOGBOOK:  
      CLOCK: [2016-09-02 五 18:00]--[2016-09-02 五 19:00] =>  1:00
      CLOCK: [2016-09-02 五 16:51]--[2016-09-02 五 17:22] =>  0:31
      :END:      
      :PROPERTIES:
      :CLOCK:
      :INTRODUCE:     以部署为中心的开发模式
      :TOPIC:         不fork仓库 团队循环开发模式 部署测试自动化
      :END:
      - 不fork仓库  这一流程不需要fork仓库便可进行开发部署
      - 团队循环开发模式(master -> branch -> pull request -> master)
        - 随时部署  master分支保持随时可以部署的状态 防止同时出现多个严重bug
        - 进行新作业要从master分支创建新分支  新分支取名要具有功能描述性 例: redis-transition
          - 在创建的分支中进行提交  绝对不进行与该分支 /内容无关/ 的的修改
            - 提交 /细粒度/  一次提交包含一次差异
        - /定期/ push  备份代码
        - 尽早创建 pull request  /边听取反馈边编写代码/ @用户名 发送 notifications
        - 务必让开发者进行审查  前提是该部分代码已经通过 /自动测试/ 通过后进行master合并
        - 合并后 /立刻进行部署/  再次确认合并的代码是否存在问题
      - 部署自动化
        - 使用部署工具  部署工作简化成一条指令 回滚功能
        - 注意事项  防止一个部署尚未完成 开发者已经处理完下一个pull request
      - 重视测试
        - 测试自动化  检测是否有代码被恶意破坏
        - 编写代码 通过测试  /每一名开发者必须编写测试代码/
        - 维护测试代码  提高测试效率
***** *模拟体验 Github Flow*
      :LOGBOOK:  
      CLOCK: [2016-09-03 六 08:11]--[2016-09-03 六 09:09] =>  0:58
      :END:      
      :PROPERTIES:
      :CLOCK:
      :INTRODUCE:     在 github flow 流程下模拟开发一个软件
      :TOPIC:         提供测试代码 正常文件格式 218
      :END:
***** 团队实践 Github Flow几点建议
      :LOGBOOK:  
      CLOCK: [2016-09-03 六 09:14]--[2016-09-03 六 09:51] =>  0:37
      :END:      
      :PROPERTIES:
      :CLOCK:
      :INTRODUCE:     总结的一些经验
      :TOPIC:         试运行环境 <PR减少体积 不要太多反馈 积攒太多>  230
      :END:
      - 减少PR体积
        - 大代码量的 pull request 不容易查出 bug 进行部署时会畏手畏脚
        - 几小时或者几天的代码量提交会提高审查效率 加快开发进度
        - 进行功能讨论前应该将 /软件功能细化/
      - 准备试运行的环境
        - 对系统有重大影响的关键修改 为了避免在部署时发生意外 最好在预演环境中试运行
        - 不要把所有修改都放到预演环境中 免得画蛇添足
      - 不要让PR太多反馈
        - 团队在开发时 最好先制定规范 共享知识 可参考的资料
        - 避免因个人编程能力不足 团队交流不足造成的 PR迟迟无法合并的现象
      - 不要积攒PR
        - 下一个PR发送前 先帮忙审查完前面PR
        - 大量的PR积累 会导致长期无法部署 引发严重问题
**** *Git Flow* (with develop release hotfix)
***** compare with above
      :PROPERTIES:
      :CLOCK:
      :INTRODUCE:     相比较原始的 git flow 更加复杂
      :TOPIC:         develop开发分支 ?release发布版本分支 hotfix应急措施分支  234
      :END:
      - develop开发分支
        - 用于开发软件功能
        - 特性分支开发完成后与之合并
        - 在特性开发之前应该先将 /获取develop分支最新代码/
      - ?release发布版本分支(/可省略 直接在 master 分支上进行 release 操作/)
        - 建议在 develop 开发分支 功能完善后 /在网页进行 release 操作/
        - 分支完成后 /只做相关bug修复 减少功能上的增减/
      - hotfix应急措施分支
        - 当 develop 分支正在 /开发新功能/ 旧功能出现严重 bug
        - 该分支用于临时开通一个渠道进行 /修复工作/
        - 修复完成后与与 master 合并 进行 release 操作
        - 最后修复 develop 分支上的漏洞
      - 流程图 258
        - [[file:~/desktop/Git_Flow.png]]
*** github 应用到企业
    :LOGBOOK:  
    CLOCK: [2016-09-04 日 16:10]--[2016-09-04 日 16:23] =>  0:13
    :END:      
    :PROPERTIES:
    :TOPIC:      Subversion  264
    :END:
*** GitBucketA
    :LOGBOOK:  
    CLOCK: [2016-09-04 日 16:24]--[2016-09-04 日 16:27] =>  0:03
    :END:      
    :PROPERTIES:
    :INTRODUCE:  和github类似 提供免费私人仓库的服务
    :TOPIC:      268
    :END:
*** Gist
    :PROPERTIES:
    :INTRODUCE:  分享代码片段
    :TOPIC:      275
    :END:
** PROJECT pro git
*** 起步 get start
**** 基础要点 git basics
***** 直接快照 而非比较差异 snapshotss not differences
      - 文件数据整体是否发生变化 而不是文件内容的具体差异
        The major difference between Git and any other VCS (Subversion and friends included):
        - git
          Every time you commit, or save the state of your project in Git
          it basically takes a picture of what all your files look like at that moment and stores a reference to that snapshot
          Storing data as snapshots of the project over time [P En 32]
        - other VCS
          store information as a list of file-based changes
          Storing data as changes to a base version of each file [P En 32]
***** 时刻保持数据完整性 git has integrity
      - 哈希值索引
        Everything in Git is check-summed before it is stored and is then referred to by that checksum
        In fact, Git stores everything in its database *not by file name* but by the hash value of its contents
           /24b9da6552252987aa493b52f8696cd6d3b00373/
***** 多数操作仅添加数据 git generally only adds data
      - 一旦提交快照 不用担心丢失数据
        When you do actions in Git, nearly all of them only add data to the Git database
        after you commit a snapshot into Git, it is very difficult to lose, especially if you *regularly push your database to another repository*
***** 三种状态 the three states
      - 已提交 已修改 已暂存 之间的基本流程
        - modify files in your working directory (modified)
          - working directory
            The working directory is a single checkout of one version of the project
        - stage the files, adding snapshots of them to your staging area (staged)
          - staging area
            The staging area is a file, generally contained in your Git directory, that stores information about what will go into your next commit
        - do a commit, which takes the files as they are in the staging area and stores that snapshot permanently to your Git directory
          - Git directory
            The Git directory is where Git stores the metadata and object database for your project.
            This is the most important part of Git, and it is what is copied *when you clone a repository from another computer*

        Working directory, staging area, and Git directory [P En 35]
***** 查看配置信息 checking your settings
      - 查看已有的配置
        $ git config --list
      - 查阅某个环境变量的设定
        $ git config user.name
***** 获取帮助 getting help
      $ git help <cmd>
      $ git <cmd> --help
      $ man git <cmd>
*** 基础 git basics
**** 取得项目的git仓库 getting a git repository
***** 从当前目录初始化 initializing a repository in an existing directory
      - 对现有的某个项目开始用git管理
        =# This creates a new subdirectory named .git that contains all of your neces- sary repository files – a Git repository skeleton=
        $ git init
      - 将文件纳入版本控制
        $ git add *.c
        $ git add LICENSE
        $ git commit -m 'initial project version'
***** 从现有仓库克隆 cloning an existing repository
      - git仓库创建副本
        - git clone [url]
          $ git clone https://github.com/libgit2/libgit2
        - clone the repository into a directory
          $ git clone https://github.com/libgit2/libgit2 mylibgit
**** 记录每次更新到仓库 recording changes to the repository
     : The lifecycle of the status of your fles [P En 45]
***** 检查当前文件状态 checking the status of your files
      - 显示任何文件信息
        $ git status
***** 跟踪新文件 tracking new files
      - 跟踪一个新文件
        $ git add README
***** 暂存已修改文件 staging modified files
      - 文件暂存 下次提交时 一并记录到仓库
***** 忽略某些文件 ignoring files
      - .gitignore 避免提交无用的文件
        - The *rules for the patterns* you can put in the .gitignore file
          Blank lines or lines starting with # are ignored.
          Standard [[glob patterns]] work.
          You can end patterns with a forward slash (/) to specify a directory.
          You can negate a pattern by starting it with an exclamation point (!).

          - <<glob patterns>>
            : Glob patterns are like simplified regular expressions that shells use
            (*) matches zero or more characters
            [abc] matches any character inside the brackets (in this case a, b, or c)
            (?) matches a single character
            ([0-9]) match- es any character between them (in this case 0 through 9)
          - .gitignore example
            *.a                 =# no .a files=
            !lib.a              =# but do track lib.a, even though you're ignoring .a files above=
            /TODO               =# only ignore the root TODO file, not subdir/TODO=
            build/              =# ignore all files in the build/ directory=
            doc/*.txt           =# ignore doc/notes.txt, but not doc/server/arch.txt=
            doc/**/*.txt        =# ignore all .txt files in the doc/ directory=
***** 查看已暂存和未暂存的更新 viewing your staged and unstaged changes
      - 浏览暂存前后的变化
        $ git diff
***** 提交更新 committing your changes
      - 暂存的内容提交到仓库
        $ git commit
        $ git commit -m "Story 182: Fix benchmarks for speed"
***** 跳过使用暂存区域 skipping the staging area
      - 无需暂存 直接提交
        $ git commit -a -m 'added new benchmarks'
***** 移除文件 removing files
      - 移除文件
        $ git rm
        $ git rm -f     =# If you modified the file and added it to the index already, you must force the removal with the -f option=
      - 从跟踪文件清单中删除
        $ git rm --cached
      - glob模式
        =# Note the backslash (\) in front of the *, This is necessary because Git does its own filename expansion in addition to your shell’s filename expansion=
        $ git rm log/\*.log
***** 移动文件 moving files
      - 提交前删除老的文件名 再添加新的文件名
        $ git mv README.md README

        =# this is equivalent to running=

        $ mv README.md README
        $ git rm README.md
        $ git add README
**** 查看提交历史 viewing the commit history
     - 列出所有的更新
       $ git log
                 -p       显示每次提交内容差异
                 --stat   仅显示增改行数统计
                 --graph  显示ASCII图形表示分支合并历史
                 --pretty 使用其他格式显示历史信息 (oneline, short, full, fuller)
***** 限制输出长度 limiting log output
      $ git log
                -(n)                 仅最近的n条提交
                --since, --after     仅指定时间之后提交
                --until, --before    仅指定时间之前提交
                --author             指定作者
                --committer          仅指定提交者相关
**** 撤销操作 undoing things
***** 修改最后一次提交
      $ git commit --amend

      # 三条命令得到一个提交， 第二条提交命令修正了第一个的提交内容
      $ git commit -m 'initial commit'
      $ git add forgotten_file
      $ git commit --amend
***** 取消已经暂存的文件 unstaging a staged file
      $ git reset HEAD <file>...    # 取消文件暂存
***** 取消对文件的修改 unmodifying a modified file
      $ git checkout -- <file>
      $ git status
      $ git reset HEAD <file>...    # 取消文件暂存
**** 远程仓库的使用 working with remotes
***** 查看当前的远程库 showing your remotes
      $ git clone git://github.com/schacon/ticgit.git
      $ cd ticgit
      $ git remote
      origin

      $ git remote -v
      origin git://github.com/schacon/ticgit.git

      $ cd grit
      $ git remote -v
      bakkdoor     git://github.com/bakkdoor/grit.git
      cho45        git://github.com/cho45/grit.git
***** 添加远程仓库 adding remote repositories
      $ git remote add [shortname] [url]:

      $ git remote
      origin
      $ git remote add pb git://github.com/paulboone/ticgit.git
      $ git remote -v
      origin git://github.com/schacon/ticgit.git
      pb git://github.com/paulboone/ticgit.git
***** 从远程仓库抓取数据 fetching and pulling from your remotes
      $ git fetch [remote-name]

      # 抓取Paul有的，但本仓库没有的信息
      $ git fetch pb
      remote: Counting objects: 58, done.
      remote: Compressing objects: 100% (41/41), done. remote: Total 44 (delta 24), reused 1 (delta 0) Unpacking objects: 100% (44/44), done.
      From git://github.com/paulboone/ticgit
      * [new branch] master -> pb/master * [new branch] ticgit -> pb/ticgit
***** 推送数据到远程仓库 pushing to your remotes
      $ git push [remote-name] [banch-name]

      $ git push origin master
***** 查看远程仓库信息 inspecting a remote
      git remote show [remote-name]

      $ git remote show origin
      * remote origin
        URL: git://github.com/schacon/ticgit.git
        Remote branch merged with 'git pull' while on branch master
          master
        Tracked remote branches
          master ticgit
***** 远程仓库的删除和重命名 removing and renaming remotes
      $ git remote rename pb paul $ git remote
      origin
      paul

      $ git remote rm paul
      $ git remote
      origin
**** 打标签 tagging
     typically people use this functionality to mark release points (V1.0)
***** 列显已有的标签 listing your tags
      $ git tag
      v0.1
      v1.3

      $ git tag -l 'v1.4.2.*'
      v1.4.2.1
      v1.4.2.2
      v1.4.2.3
      v1.4.2.4
***** 新建标签 creating tags
****** 含附注的标签 annotated tags
       $ git tag -a v1.4 -m 'my version 1.4'
       $ git tag
       v0.1
       v1.3
       v1.4

       $ git show v1.4
       tag v1.4
       Tagger: Scott Chacon <schacon@gee-mail.com> Date: Mon Feb 9 14:45:11 2009 -0800
****** 签署标签
       # 使用GPG来签署标签
       $ git tag -s v1.5 -m 'my signed 1.5 tag'
       You need a passphrase to unlock the secret key for
       user: "Scott Chacon <schacon@gee-mail.com>"
       1024-bit DSA key, ID F721C45A, created 2009-02-09

       $ git show v1.5
       tag v1.5
       Tagger: Scott Chacon <schacon@gee-mail.com>
       Date: Mon Feb 9 15:22:20 2009 -0800
       my signed 1.5 tag
       -----BEGIN PGP SIGNATURE-----
       Version: GnuPG v1.4.8 (Darwin)
****** 轻量级标签 lightweight tags
       # 保存对应提交对象
       $ git tag v1.4-lw
       $ git tag
       v0.1
       v1.3
       v1.4 v1.4-lw v1.5
***** 验证标签
      # 调用GPG来验证签名
      git tag -v [tag-name]

      $ git tag -v v1.4.2.1
      object 883653babd8ee7ea23e6a5c392bb739348b1eb61
      type commit
      tag v1.4.2.1
      tagger Junio C Hamano <junkio@cox.net> 1158138501 -0700

      # 没有公钥 会报错
      gpg: Signature made Wed Sep 13 02:08:25 2006 PDT using DSA key ID F3119B9A
      gpg: Can't check signature: public key not found
      error: could not verify the tag 'v1.4.2.1'
***** 后期加注标签 tagging later
      $ git log --pretty=oneline
      15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch 'experiment'
      a6b4c97498bd301d84096da251c98a07c7723e65 beginning write support
      0d52aaab4479697da7686c15f77a3d64d9165190 one more thing
      6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch 'experiment'

      $ git tag -a v1.2 9fceb02
***** 分享标签 sharing tags
      # by default, the git push command doesn't transfer tags to remote servers.
      # you will have explicitly push tags to a shared server after you have created them
      git push origin [tagname]
      $ git push origin v1.5
      Counting objects: 50, done.
      Compressing objects: 100% (38/38), done.

      # if you have a lot of tags that you want to push up at once, use --tags
      $ git push origin --tags
      Counting objects: 50, done.
      Compressing objects: 100% (38/38), done.
**** 技巧的窍门 git aliases
***** 自动完成
***** git命名别名
      # 要输入commit 只需输入ci即可
      $ git config --global alias.co checkout
      $ git config --global alias.br branch
      $ git config --global alias.ci commit
      $ git config --global alias.st status

      $ git config --global alias.unstage 'reset HEAD --'
      $ git unstage fileA
      $ git reset HEAD fileA

      $ git config --global alias.last 'log -1 HEAD'
      $ git last
      commit 66938dae3329c7aebe598c2246a8e6af90d04646
      Author: Josh Goebel <dreamer3@example.com>
      Date: Tue Aug 26 19:48:51 2008 +0800
*** Git分支 Git branching
**** 何谓分支 branches in a nutshell
     - 创建分支内部演变流程 [P] (Cn 54)
       一次提交后仓库里的数据
       多次提交后的git对象数据
       指向提交数据历史的分支
       多个分支指向提交数据的历史
       head指向当前所在的分支
       head在你转换分支时指向新的分支
       每次提交后head随着分支一起向前移动
       head在一次checkout之后移动到了另一个分支
       分叉了的分支历史
**** 基本的分支与合并 basic branching and merging
* computer science
** sicp
*** short contents 3
*** building abstractions with procedures
    : the act of mind *
    : well-designed computational systems *
**** The Elements of Programming                                                :code:
     : describle a language *
     : procedures and data *
***** expressions                                                               :code:
      : a number expression *
      one kind of primitive expression you might type is a number
      : a compound expression *
      : prefix notation *
      : pretty-printing *
***** naming and the environment                                                :code:
      : using name identifies a variable *
      : environment
      associating values with symbols
        and later retrieving them means that
          the interpreter must maintain some sort of memory
          that keeps track of the name-object pairs
      this memory is called the environment
***** Evaluating Combinations                                                   :code:
      : evaluate a combination *
***** Compound Procedures                                                       :code:
      : procedure definitions *
***** the substitution model for procedure application                          :code:
      : substitution model *
      : applicative order versus normal order *
***** conditional expressions and predicates                                    :code:
      : conditional expression *
      : logical composition operations *
***** example: square roots by newton's method                                  :code:
      : mathematics and computer science *

      : define square roots function
      : how does one computer square roots *
      : formalize the process in terms of procedures *
***** Procedures as Black-Box Abstractions                                      :code:
      : black box *
      : procdural abstraction *
      : block structure *
      : lexical scoping *
      - sprt 过程分解
        一个过程应该隐藏起一些细节 So a procedure definition should be able to suppress detail.
        用户在使用一个过程时 应该不需要去弄清楚如何实现的 A user should not need to know how the procedure is implemented in order to use it
      - 局部名 local names
        过程的意义不应该依赖于作者为形式参数所选用的名称 a procedure should be independent of the parameter names used by its author

        ;;  the x in good-enough? must be a different x than the one in square
        (define (good-enough? guess x)
          (< (abs (- (square guess) x))
                                0.001))
      - 内部定义 块结构 Internal definitions and block structure

        将 x 作为参数在过程之间 显示传递
        (define (sqrt x)
          (define (good-enough? guess x)
            (< (abs (- (square guess) x)) 0.001))
          (define (improve guess x) (average guess (/ x guess)))
          (define (sqrt-iter guess x)
            (if (good-enough? guess x)
                guess
                (sqrt-iter (improve guess x) x)))
          (sqrt-iter 1.0 x))

        由于过程都定义在sqrt里 x在sqrt里受约束
        可以让x作为内部定义的自由变量
        词法作用域 lexical scoping
        (define (sqrt x)
          (define (good-enough? guess)
            (< (abs (- (square guess) x)) 0.001))
          (define (improve guess)
            (average guess (/ x guess)))
          (define (sqrt-iter guess)
            (if (good-enough? guess)
                guess
                (sqrt-iter (improve guess))))
        (sqrt-iter 1.0))

**** Procedures and the Processes They Generate                                 :code:
     : the chess *
     : common "shape" for processes *
***** Linear Recursion and Iteration
      : define factorial function
      : with linear recursive process *
      : with linear iterative process *
***** Tree Recursion
      : Fibonacci numbers *
      : tree recursion *
      : iterative process *

      : counting change *
      : recursion procedure *
***** Orders of Growth
      : the graph of counting change *
      : the orders of growth of the space *
***** exponentiation
      : b^n *
      : linear recursive process *
      : linear iteration process *
      : linear iteration process (improve) *
***** greatest common divisors (GCD)
      : GCD *
      : Euclid's Algorithm *
      : Lame's Theorem *
***** example testing for primality
      : searching for divisors *

      : the Fermat test *
      : Probabilistic methods *
**** formulating abstractions with higher-order procedures                      :code:
     : higher-order procedures *
***** procedure as arguments
      : common pattern *
***** constructing procedures using lambda
      : create procedures without defining any auxiliary procedures *
      : using local variables *
***** procedures as general methods
      : general methods for finding zeros and fixed points of function *
      : average damping *
***** procedures as returned values
      : procedures returned as procedures *
      : Newton's method *
      : abstractions and first-class procedures *
*** building abstractions with data
    : compound data *
**** introduction to data abstraction
     : data abstraction *

     : constructing a rational number *
     : constructing the arithmetic operations for rational numbers *
     : test rational-number procedures *

     : abstraction barriers *

     : procedural representations of data *

     : interval arithmetic *
**** hierarchical data and the closure property
     : the closure property of cons *
     : sequences *
     : tree *
     : the use of conventional interfaces *
**** symbolic data
     : arbitrary symbols as data *
     : quotation *
**** multiple representations for abstract data
     : generic procedures *
     : representations for complex numbers *
     : data-directed programming *
**** systems with generic operations
     : a generic arithmetic system *
     : generic arithmetic operations *
     : combining data of different types *
*** modularity, objects and state
    : designing programs
**** assignment and local state
     : have state *
     : local state variables *
     : introducing assignment *
**** the environment model of evaluation
     : environments *
     : the rules for evaluation *
     : applying simple procedures *
     : frames as the repository of local state *
     : internal definitions *
**** modeling with mutable data
     : mutators *
     : mutable list structure *
     : representing queues *
     : representing tables *
     : a simulator for digital circuits *
     : propagation of constraints *
**** concurrency: time is of the essence
     : concurrently *
     : the nature of time in concurrent systems *
     : mechanisms for controlling concurrency *
**** streams
     : streams are delayed lists *
     : infinite streams *
     : exploiting the stream paradigm *
     : streams and delayed evaluation *
     : modularity of functional programs and modularity of objects *
*** metalinguistic abstraction
    : establishing new languages
**** the metacircular evaluator
     : metacircular & evaluator *
     : the core of the evaluator *
     : representing expressions *
     : evaluator data structures *
     : running the evaluator as a program *
** 程序员的修炼之道 the pragmatic programmer, from journeyman to master
*** 注重实效的哲学 21 pragmatic philosophy 18
**** 我的源码给猫吃了 the cat ate my source code
     提供各种选择 不要找蹩脚的借口 *provide options  don't make lame excuses*
**** 软件的熵 software entropy
     - 无序增长 软件腐烂 software rot
       未实现注释 comment out
       虚设的数据 dummy data
     - 不要容忍破窗户 *don't live with broken windows*
**** 石头汤和青蛙 stone soup and boiled frogs
     - 做变化的催化剂 *be a catalyst for change*
       开发一个产品 让大家聚集在你的周围
     - 记住大背景 *remember the big picture*
       沸水煮青蛙            跳出来
       先放在冷水 慢慢加热    被煮熟
       观察周围发生的事情 不只是你自己在做的事
**** 足够好的软件 good-enough software
     - 让你的用户参与权衡 involve your users in the trade-off
       使质量成为需求问题 *make quality a requirements issue*
     - 知道何时止步 know when to stop
       不要因为过度修饰和过于求精而损坏完好的程序
**** 你的知识资产 your kownledge portfolio
     - 知识 是 有时效的资产 expiring asset
       定期为你的知识资产投资 *invest regularly in your knowledge portfolio*
     - 批判地分析你读到的和听到的 *critically analyze what you read and hear*
       是否受到媒体炒作的影响
       警惕提供唯一答案的狂热者
**** 交流 communicate
     - 你说什么和你怎么说同样重要 *it's both what you say and the way you say it*
       - 知道你要说什么 know what you want to say
         写出大纲 构思情节
       - 了解你的听众 know your audience
         技术 还是 兴趣
       - 选择时机 choose your moment
         找到刚刚因为丢失源码而遭到老板批评的经理 向他介绍关于源码仓库的构想
       - 选择风格 choose a style
         简报 书面文档 电子邮件
       - 让文档美观 make it look good
       - 回复他人 be a listener
       - Email communication
*** 注重实效的途径 45 a pragmatic approach 43
**** 重复的危害 the evil of duplication
    系统中每一项知识必须具有单一 无歧义 权威的表示
    Every piece of knowledge must have a single, unambiguous, authoritative representation within a system.

    不要重复你自己 *DRY-don't repeat yourself*

    - 重复是怎样发生的 how does duplication arise
      - 强加的重复 imposed duplication
        重复信息的文档 documents that contain duplicated information
          编写简单的过滤器 代码生成器
          write a simple filter or code generator
        重复代码中的信息 documents that duplicate information in the code
          把低级的知识放在代码中 把注释保留给其他的高级说明
          keep the low-level knowledge in the code where it belongs, and reserve The comments for other, high-level explanations.
        不同平台 不同编程语言 库 开发环境 Multiple target platforms each require their own programming languages, libraries, and development environments
          客户修改它们的规范时 测试套件自动改变
          When the client amended their specification, the test suite changed automatically
          编程环境强制重复 c/c++/java 头文件 命名重复
          Many languages impose considerable duplication in the source
      - 无意的重复 inadvertent duplication
          有时 无意的重复来源于设计上的错误
          Sometimes, duplication comes about as the result of mistakes in the design.

          当我们拥有互相依赖的元素时 会出现一种不显而易见的不规范数据
          There is a slightly less obvious kind of unnormalized data that occurs when we have multiple data elements that are mutually dependent
            class Line {
｀            public:
              Point start; Point end; double length; // change one of the points and the length changes. It's better to make the length a calculated field
            };
      - 无耐性的重复 impatient duplication
          开发者的懒惰 拷贝修改源码 项目重新构建
          shortcuts make for long delays
      - 开发者之间的重复 interdeveloper duplication
          让复用 变得容易 make it easy to reuse
**** 正交性 Orthogonality
     当任何系统各组间互相高度依赖时 就不再有局部修正这样的事情
     消除无关事物之间的影响 Eliminate Effects Between Unrelated Things
     模块化 modular  基于组件 component-based
     分层抽象 a level of abstraction  底层实现 underlying implementation
***** 提高生产率 Gain Productivity
      与编写单个大块代码相比 编写多个相对较小的自足的组件更为容易
***** 降低风险 Redu ce Risk
      隔离 测试 避免供应商绑定
***** 测试 testing
****** 单元测试 unit test
       每个模块都拥有自己的内建在代码中的单元测试
       在构建中自动运行
***** 编码 coding
****** 代码保持解耦 keep your code decoupled
       不暴露任何事情 不依赖其他实现的模块
****** 避免使用全局数据 avoid global data
****** 避免编写相似的函数 重构
**** 可撤销性 reversibility
***** 要实现一种东西 总有不止一种方法
***** 关键决策不容易撤销
      一旦决定使用供应商数据库 特定的部署模型 将受制于无法撤销的动作进程
***** 不存在最终决策 there are no final decisions
***** 灵活的架构 flexible architecture
      平台移植 系统部署
      把需求写入元数据 自动添加 自动去除
**** 曳光弹 tracer bullets
***** 用曳光弹找到目标 use tracer bullet to find the target
      曳光弹与常规弹药交错装在弹药带上
      发射时 在枪与击中的地方之间留下一条烟火踪迹
      如果曳光弹击中目标 那么常规子弹也会击中目标
***** 从代码出发 我们要找到某种东西 能快速 直观 可重复的从需求出发 满足系统某个方面的要求
      开发复杂的用c编写的数据库项目
        许多未知因素和许多不同的环境 没有人清楚gui该怎样工作
      开发前端框架结构
        用来检查ui是否能够与库交互 以及序列化和解序列化
***** 曳光代码并非用过就仍的代码
      它含有任何一段产品代码都拥有的完整的错误检查 结构 文档 以及自查
      一旦各组件实现乐端到端的连接 就可以检查你离目标还有多远 必要情况下进行调整
***** 原型与便笺 prototypes and post-it notes
      : 为了学习而制作原型 prototype to learn
      - 原型用于测试项目的一个或多个具体方面
        任何带有风险的 以前没有试过的 对于最终系统极端关键 未被证明的 实验性的事物
        架构 系统新功能 外部数据 三方组件 性能问题 用户界面
      - 原型制作应忽略
        正确性 完整性 健壮性 风格
      - 用户界面的原型可以是白板上的图形 或是用绘图程序的界面构建器的无功能模型
      - 制作架构原型
        主要组件得到良好定义
        主要组建间的协作
        耦合最小化
        是否重复
        接口各项约束是否可接受
      - 当原型不再是用过就扔的代码 我们将不再使用原型
***** 领域语言 domain languages
      : 靠近问题 领域编程
      : program cloase to the problem domain
      - 实现小型语言 implementing a mini-language
        数据语言产生某种形式的数据结构给应用使用 这些语言表示配置信息
        data languages produce some from of data structure used by an application. these languages are often used to represent configuration inform action
      - 扩展已有的语言(与python集成在一起)
        把高级命令语言直接嵌入你的应用 通过改变应用读取的脚本 改变应用的行为
        it's common to embed high-level imperative languages directly into your application,
        you can change your application's behaveior by changeing the scripts it reads, all without compiling
***** 估算 estimating
      : 估算， 可避免发生意外
      : estimate to avoid surprises
      : 通过代码对进度表进行迭代
      : iterate the schedule with the code
      - 估算时要考虑的内容
        多准确才足够准确 how accurate is accurate enough
        估算来自哪里 where do estimates come from
        理解提问内容  understand what's being asked
        建立系统的模型 build a model of the system
      - 在被要求进行估算时
        我等会儿回答你
        I'll get back to you
*** 基本工具 the basic tools
**** 纯文本的威力 the power of plain text
     : 用纯文本保存知识
     : keep knowledge in plain text
     保证不过时 insurance against obsolescence
     可读性 human readable
     unix哲学 each small sharp tools intended to do one thing well. when a system crashes, you may be faced with only a minimal envionment to restore it(use text)
**** shell游戏 shell games
     : 利用命令shell的力量
     : use the power of command shells
     去熟悉shell 你会发现自己的生产率迅速提高  gain familiarity with the shell, and you'll find your productivity soaring
     在windows下使用shell  using unix tools under windows (cygwin)
**** 强力编辑 power editing
     : 用好一种编辑器
     : use a single editor well
     选一种编辑器 彻底了解它 并将其用于所有的编辑任务  choose an editor, know it thoughly, and use it for all editiong tasks
     编译器特性  editor features
       可配置 可扩展 可编程
       configurable extensible programmable
       语法突显 自动完成 自动缩进 初始代码或模版 与帮助系统挂接 类IDE特性(编译 调试 等等)
       syntax highlighting  auto-completion  auto-indentation  initial code or document template  tie-in to help systems  IDE-like features(compile debug and so on)
**** 源码控制 source code control
     : 总是使用源码控制
     : always use source code control
     一个项目级的时间机器 你总能够返回软件的前一版本 维护的源码保存在某个中央仓库(repository)中
     在指定的时间 自动从仓库中取出源码块 进行构建测试
**** 调试 debugging
     : 要修正问题 而不是发出指责
     : fix the problem, not the blame
     : 不要恐慌
     : don't panic
     : 不要假定 要证明
     : don't assume it-prove it
     - 调试的思维方式 a debugging mindset
       要总是设法找出问题的根源 而不只是问题的特定表现  always try to discover the root cause of a problem, not jest this particular appearance of it
       确保能够在成功编译的代码上工作
       需要和报告bug的用户多交流
       测试边界条件  test both boundary conditions and realistic end-user usage patterns
     - 测试策略 denbugging strategies
       - 再现bug  bug reproduction
         通过一条命令再现bug
         强迫自己隔离显示出bug的环境
       - 使你的数据可视化 visualize your data
         使用数据及其所有的相互关系可视化的调试器 you can gain a much deeper insight into your data by using a debugger
         自己进行可视化 纸和笔
         单步跟踪 让bug自己跳出来
       - select没有问题  select isn't broken
         新版本升级
         os很可能没有问题 数据库也很可能情况良好
         在提交报告之前 必须先消除你代码中的bug
**** 文本操纵 text manipulation
     : 学习一种文本操纵语言  learn a text manipulation language
     - 编写perl程序
       分析c c++ schema makefile源文件 数据库维护 java属性访问 测试数据生成 写书 生成web文档
**** 代码生成器 code generators
     : 编写能编写代码的代码 write code that writes code
     - 被动代码生成器 passive code generators
       - 创建新的源文件
         模版 源码指示 版权说明 标准注释块...
       - 编程语言之间进行一次性转换
     - 主动代码生成器 active code generators
       - 根据某项知识的表示形式 转换为你的应用需要的所有形式(yasnippet)
*** 注重实效的偏执 pragmatic paranoia
    : 你不可能写出完美的软件 you can't write perfect software
**** 按合约设计 design by contract
     - java基类
       子类必须要能通过基类的接口使用 而使用者无需知道其区别
       在基类中合约一次 子类可以(可选的)接受和保证至少喝父类一样多
     - 断言 assertions
       断言式编程不能继承
     - 给软件增加前置条件和后置条件
**** 断言式编程 assertive programming
     : 如果他不可能发生 用断言确保他不会发生 if it can't happen, use assertions to ensure that it won't
     if增加条件判断
     try catch错误类型
     不要让调试改变了被调试系统的行为
**** 何时使用异常 when to use exceptions
     : 将异常用于异常问题 use exceptions for exceptional problems
**** 释放资源 how to balance resources
     : 有始有终 finish what you start
*** 弯曲或折断 bend or break
**** 解耦与得墨儿法则 decoupling and the law of demeter
     : 使模块之间的耦合至最少 minimize coupling between modules
***** TODO 大型系统中如何保持模块物理解耦又能高度依赖
      逻辑设计和物理设计必须协同进行
**** 元程序设计 metaprogramming
     : 要配置 不要集成  configure, don't intergrate
     - 用元数据描述应用的配置选项
       调谐参数 用户偏好 安装目录
     - 元数据对应用进行描述的数据
       应该怎样运行 应该使用什么资源...
     : 将抽象放进代码 细节放进元数据  put abstractions in code, details in metadata
     - 创建更强壮的抽象设计 推迟细节处理
     - 无需重新编译 就可以进行定制
     : 不要编写渡渡鸟代码
     - 元数据使你的代码获得他应有的适应性与灵活性
       不要让你的代码走向灭亡
**** 时间耦合 temporal coupling
     : 分析工作流 改善并发性  analyze workflow to improve concurrency
     : 总是为并发性进行设计  always design for concurrency
     - 兼容并发 考虑解除任何次序上的依赖
       - UML活动图  UMLacticity diagram
         - 工作流分析 workflow
           - 步骤 1-12 顺序执行 的调制冰镇果汁朗姆酒 进行并发性调整 ---中文pdf第172页
         - 架构 architecture
           - 数据库分布式应用 ---中文pdf第173页
       - 部署 deployment
         - 并发与不并发间进行选择
           单机  standlone
           客户-服务器  client-server
           动态系统架构
**** 视图 just a view
     : 使视图与模型分离  separate vviews from models
     - 三层架构 model-view-controller
       模型    表示目标对象的抽象数据模型
       视图    解释模型的方式
       控制器  控制视图 并向模型提供新数据
**** 黑板 blackboards
     : 用黑板协调工作流  use blackboards to coordinate workflow
     - 案情追踪
       不同地区 拥有不同经验 侦探们
       在黑板上 通过图片 判断 物证
       进行协同破案
     - 黑板方式编程消除了对太多接口的需要
       - 接受并处理抵押或贷款申请
         封装法律需求规则引擎
         数据到达次序无关紧要
         任何规则集输出到黑板
         并触发更为适用的规则
*** 当你编码时 while you are coding
**** 靠巧合编程 programming by conincidence
     : 不要靠巧合编程 don't programming by conincidence
     - 黑白战争片
       灌木丛的士兵试图通过雷区
       刺刺这里 戳戳那里 最后确信这个地方是安全的
       于是直起身向前走去 结果被炸成了片
     - 确认实现并非偶然
**** 算法速率 algorithm speed
     : 估算你的算法的阶 estimate the order of your algorithms
     : 测试你的估算 test your estimates
     - O()表示法
       处理近似计算的一种数学途径
       a mathematical way of dealing with approximations
     - 一些常用算法的近似表示
       速率对比 runtimes of various algorithms (英文第185页)
       O(1)         常量型(constant)              数组访问 简单语句
       O(n)         线性型(linear)                简单循环(simple loop) 顺序查找(swquential search)
       O(m*n)       平方型(square law)            嵌套循环(nested loops) 冒泡排序(bubble sort) 外循环(outer loop)
       O(n^2)                                                          选择、插入排序(selection and insertion sorts) 内循环(inner loop)
       O(lg(n)      对数型(logarithmic)           二分法(binary chop) 二分查找(binary search) 每次循环把事物一分为二(halvs the set of thing it considers each time around the loop)
       O(In(n))                                                     有序列表二分查找(a binary search of a sorted list) 遍历二叉树(traversing a binary tree) 查找机器字节第一个出现位置
       O(n*In(n))   比线性稍差(worse than linear)  分而治之(divide and conquer) 快速排序(quicksort) 堆排序(heapsort)
       O(c^3)       立方形(cubic)                 2n*n矩阵相乘(multiplication of 2n * n matrices)
       O(n!)        指数型(exponential)           事物的排列
       O(c^n)                                    组合(combinatoric) 旅行商问题(traveling salesman problem) 集合划分(set partitioning)
**** 重构 refactoring
     : 早重构 长重构 refactor early, refactor often
     - 园艺
       软件像园艺
       根据最初的计划在花园里种植许多花木
       有些茁壮生长 有些注定要成为堆肥
       你会改变蜘蛛的相对位置 以有效利用光影 风雨交互作用
       过度生长植株会被裁剪 颜色不协调会被移到从美学上更怡人的地方
       你拔除野草 并给需要额外照料的植株施肥
     - 何时进行重构
       重复 非正交设计 过时的知识 性能
     - 怎样进行重构
       不要试图在重构的同时增加功能
       在开始重构之前 确保你拥有良好的测试
**** 易于测试的代码 code that's easy to test
     : 为测试而设计 design to test
     : 测试你的软件 否则你的用户就得测试 test your software, or your users will
     - 针对合约进行测试 test against contract
       广泛的测试用例 边界条件 允诺的功能
       全面测试模块内的子组件 再测试模块 确保模块没有暴露子组件
       设计模块时 同时设计其公约 也设计测试该合约的代码
     - 编写单元测试 writing unit tests
       模块的单元测试潜入模块自身 或把每个测试都放进一个易于找到的目录
     - 使用测试装备 using test harnesses
       - Junit 被设计成可组合的 把任意多的测试加到这个套件中
       - 测试装备应该具有的功能
         指定设置与清理的标准途径 a standard way to specify setup and cleanup
         选择个别或所有可用的测试方法 a method for selecting individual tests or all available tests
         分析输出是否是预期结果 a means of analyzing output for expected(or unexpected) results
         标准化故障形式 a standardlized from of failure reporting
**** 邪恶的向导 evil wizards
     : 不要使用你不理解的向导代码 don't use wizard code you don't understand
     - 向导
       向导会为你生成骨架代码 然后就没有然后了
       如果他们制作的代码不完全正确 或者事情变了 需要修改代码 就只能靠你自己了
*** 在项目开始之前 before the project
**** 需求之坑 the requirements pit
     : 不要搜集需求-要挖掘它们 don't gather requirements-dig for them
     - 把政策的文档与需求的文档分开 政策可以成为应用中的元数据
     : 与用户一同工作 以像用户一样思考 work with a user to think like a user
     - 建立需求文档 (用例样本 中文第227页 英文第208页)
     : 抽象比细节要活得更长久 abstractions live longer than details
     - 不要规定多度 看远些
     : 使用项目词汇表 use a project glossary
     - 维护词汇表
       一旦讨论需求 领域专家就会使用对他们有特定含义的术语
**** 解开不可能解开的谜题 solving impossible puzzles
     : 不要在盒子外面思考-要找到盒子 don't think outside the box-find the box
     - 盒子约束
       找到约束的边界
     - 戈尔迪斯结
       如何解开死结
       用剑砍断
**** 等你准备好 not until you're ready
     : 倾听反复出现的顾虑-等你准备好再开始 listen to nagging doubts-start when you're ready
     - 知道何时开始 何时等待
       跳水运动员站在高台 等待完美时刻起跳
       指挥官站在乐队前面 手臂举起 直到他感觉到某个瞬间开始演奏
**** 规范陷阱 the specification trap
     : 对有些事情"做"胜于"描述" some things are better done than described
     - 客户需求
       一般客户可能无法准确的说出他们所需的系统
       他们可能在你制作的200页文档上签字
       但你可以确信 一旦他们看到运行的系统
       你就会被各种变更要求淹没
**** 圆圈与箭头 circles and arrows
     : 不要做形式方法的奴隶 don't be a slave to formal methods
     - 海难
       在许多已沉没项目的大海里漂流
       新的技术时尚像漂来的木头 你会费力地游过去
       但到最后 不管漂浮物有多好 开发者仍然漫无目的的漂浮着
     - 不要盲目采用任何技术 而不把它放进你的开发实践和能力的语境中
*** 注重实效的项目 pragmatic projects
**** 注重实效的团队 pragmatic teams
     : 围绕功能 而不是工作职务进行组织 organize around functionality, not job functions
     - 按照功能划分团队
       分成小团队 分别负责最终系统特定方面
       团队按个人的能力 在内部自行进行组织
     - 构造和部署使项目中苦差事自动化工具
       指定工具构建员
       制作 makefile shell脚本 编辑器模版 实用程序
**** 无处不在的自动化 ubiquitous automation
     : 不要使用手工流程 don't use manual procedures
     - T 型福特车
       老型福特车说明书有两页多 遵循一串指令汽车还不一定会启动
       构建启动器和喷油器 只需转动钥匙就能启动了
     - 使用 cron
       完成任何 unattended automatically 的事情
       自动备份 夜间构建 网站维护 ...
     - 使用 makefile
       项目编译脚本化 it is a scripted, automatic procedure
       增加挂钩 add in hooks to generate code
       运行回归测试 run regression tests automatically
       代码生成
         利用 make 的依赖分析机制 exploit make's dependency analysis mechanism to make this process easy
         给 makefile 增加规则 根据其他源 自动生成文件 it's pretty simple matter to add rules to a makefile to generate a file some other source automatically
       构建自动化 build automation
         仓库取源码 从头构建项目 运行规定测试
     - 使用 perl
       快速开发自制工具
**** 无情的测试 ruthless testing
     : 早测试 常测试 自动测试
     : 通过全部测试 编码才算成功
     : 通过蓄意破坏测试你的数据
     : 测试状态覆盖 而不是代码覆盖 test state coverage, not code coverage
     - 先通过单元测试 在进行集成测试
     - 资源 可用性测试
     - 回归测试
       对增加的代码与旧代码进行对比
       确保开发新代码时没有损失任何领地
     - 大量数据进行测试
     - 一次 bug 抓到一次 就应该在每次测试中检查那个特定的 bug
**** 全都是写 it's all writing
     : 把英语当作又一种编程语言 treat english as just another programming language
     - 内部文档
       - 注释
         简单的模块级头注释
         重要类型声明
       - 变量名
         有意义
         不要误导人
       - 修订历史
     - 外部文档
       - 使用标记语言(DcoBook HTML LaTex ...) 并可以用 perl 进行格式化
       - 放上日期或版本号 留下文档撰写者
**** 极大的期望 great expectations
     : 温和的超出用户的期望 gently exceed your users' expectations
     - 额外的一英里
       用一点外努力 给你的用户带来惊喜
**** 傲慢与偏见  pride and prejudice
     : 在你的作品上签名 sign your work
     - 尊重他人的代码
       黄金法则 do unto others as you would have them do unto you
     - 在大型项目中匿名
** cs50
*** Scratch
**** slides                                                                     :week0.pdf:
***** binary                                                                     :(P7-24):
      4 2 1
      1 0 1 = 5
***** ASCII                                                                      :(P29-33):
      A  B  C  ...
      65 66 67
***** RGB                                                                        :(P34-35):
      red green blue    ->    brown
      72  73    33         (72, 73, 33)
**** scratch
     a component drag programming tool
*** C
**** slides                                                                     :week1.pdf:
***** Scratch vs C
****** hello, world                                                             :(P5):
****** function                                                                 :(P6-8):
****** loop                                                                     :(P9-13):
****** variables                                                                :(P14-16):
****** boolean expressions                                                      :(P17-21):
****** conditions                                                               :(P22-24):
****** arrays                                                                   :(P25-27):
***** compiling                                                                 :(P28-34):
            source code           compiler              machine code
      printf("hello, world\n");      ->      01111111 010000101 01001100 01000110
***** integer overflow                                                          :(P50-52):
      the overflow of the integer
      : the test for overflow
      overflow.c
***** variable recap                                                            :(P61-62):
      the real world variable type
      the printf format type
***** escape sequence                                                           :(P63):
      escapes special characters
***** condition                                                                 :(P64):
***** compiling in detail
      : before compiling and during preprocess
      #include <stdio.h>
      go to hash table stdio.h and paste it here
      : compiling
      $ clang hello.c
      take source code to assembly
      : assembling
      take assembly to zero and one
      : linking
      $ make hello
      make all the program to the system
**** source code                                                                :cs50/src1:
***** hello.c
      : source code for C end in .c by convention
      : clang (as in C language) is a compiler
      $ clang hello.c
      $ ./a.out
      hello, world
      : if without \n
      $ clang hello.c
      $ ./a.out
      hello, world$ ./a.out
      : add \n is still not work, you must compile it again
      hello, world$ clang hello.c
      $ ./a.out
      hello, world
      : specify output name
      $ clang -o hello hello.c
      $ ./hello
      hello, world
      : make a source code ending by .c
      : make is a preconfigured additional feature by IDE
      $ make hello
      $ ./hello
      hello, world
***** string.c
      : customized library
      : customized variable
      use the library cs50.h predefined variable string
      : improving UX (user experience)
      let user know what's your programm to do next
      : format syntax
      printf with your string variable

      $ make string
      $ ./string
      Name: dcc
      hello, dcc
***** int.c
      : format syntax
      printf with int variable
***** addr.c
      : format syntax
      printf with the sum of two int vatiable
***** float.c
      the float variable
***** sizeof.c
      the size of data type (bytes - 8 bits)
***** overflow.c
      test for integer overflow
      : test long varsion
      test the overflow of long variable
***** imprecision.c
      control imprecise of float
***** condition.c
      use condition statement (if  else if  else)
***** logical.c
      : char
      one character should be around with single quotes (like 'y')
      : equal  or
      the logical symbol (== ||)
***** switch.c
      condition statement (switch case)
***** prototype.c
      define your first function
      : predefined
      Pre-declared method name
      : header
      many similar prototype function predefined in one line
      like stdio.h predefined printf
***** return.c
      the return type of funtion
      : return type
      the function of square return int type (n * n)
***** cough0 cough1 cough2 cough3 cough4
      execute printf 0 per lines
                     1 in for iterator
                     2 in for iterator and prototype
                     3 pass argument in for iterator
                     4 pass argument in for iterator and create many prototypes
*** Arrays
**** slides
***** airplane software integer overflow and float imprecise                    :(P9-10):
      integer overflow cause a airplane accident
      the float imprecise can be 32bit or 64bit
***** debugg50
      debugg step by step
      use tools
***** duck debugg
      debugg to use rubber duck
      walking yourself through your code
***** cryptography                                                              :(P29-36):
***** string                                                                    :(P37-38):
***** typecasting                                                               :(P39-41):
***** *more on string*                                                            :(P46-51):
***** *command-line argument*                                                     :(P52-54):
**** source code
***** buggy0 buggy1 buggy2 buggy3
      : buggy0 buggy1
      #include <stdio.h>
      import header to use library's method and variable
      : buggy2
      : loop times
      if you want loop 10 times, you should:
      for (int i = 0; i<10; i++)
      for (int i = 1; i<=10; i++)
      : buggy3
      : function declare
      the function should be declare before main function
***** string0 string1
      : string0
      : string
      use %s printf format defined in cs50.h
      : char
      use %c printf format defined in string.h

      : string1
      : welldesign
      arrange the strlen of s in a variable n
***** ascii0 ascii1
      : ascii0 ascii1
      what's the ascii's character is, what's the corresponding number is
***** capitalize0 capitalize1 capitalize2
      : capitalize0
      lowercase to uppercase

      : capitalize1
      : toupper function
      lowercase to uppercase by toupper function
      : TIP
      man toupper

      : capitalize2
      : better design
      give every logical judgement in toupper function
***** *strlen*
      : the end of string
      in memory, computer use \0 (escape 0) to terminal string between each other
      : slides - more on string
***** argv0 argu1 argu2
      : argv0
      : command-line argument
      $ make argv0
      $ ./argv0 dcc
      hello, dcc
      =# argc = 2=
      =# argv = ./argv0\0 | dcc\0    (a array)=

      $ ./argv0 dai chen chen
      hello, world
      =# argc = 4=
      =# argv = ./argv0\0 | dai\0 | chen\0 | chen\0    (a array)=

      : argv1
      $ make argv1
      $ ./argv1 dai
      ./argv1
      dai
      $ ./argv1 dai ch ch
      ./argv1
      dai
      ch
      ch

      : argv2
      iterator the string in argv[]
***** exit
      : main's output - error
      A non-zero number, on the other hand, is used to represent an error
      $ echo $?
      1
      : main's output - success
      When a program exits successfully, it returns a number 0 to indicate as much
      $ echo $?
      0
*** Algorithms
**** slides                                                                     :week3.pdf:
***** linear search                                                             :(P13_14):
      one direction search in sorted array
***** binary search                                                             :(P15_16):
      half search in sorted array
***** bubble sort                                                               :(P23_24):
***** selection sort                                                            :(P25_26):
***** insertion sort                                                            :(P27_28):
***** algorithm running time                                                    :(P29_41):
      bubble sort
      _1 1 1 1 1 1 1 1 1_    n-1
      1 _1 1 1 1 1 1 1 1_    n-2
      ...
      1 1 1 1 1 1 1 _1 1_    1

      (n-1) + (n-2) ... + 1 = n (n-1) / 2 = (n^2 - n)/2
***** big O notation                                                            :(P43_44):
      : the worst case on how long an algorithm might take
      O(n^2)    selection bubble inserting sort
      O(n)      linear search
      O(log n)  binary search
      O(1)      every case take one step
***** omega notation                                                            :(P49_50):
      : the best case on how long an algorithm might take
      Ω(n^2)    selection sort
                even if the list was already sorted
                we wouldn’t know because we look for the smallest element
                  in the rest of the list
      Ω(n^2)    bubble sort
                since we stop if we made no swaps
                we can realize that the list was indeed sorted, and stop
      Ω(log n)
      Ω(1)      it is impossible to sort a list with n elements in Ω(log n) or Ω(1)
                since at the least we need to look at all n elements
                  to make sure it is sorted
                linear search or binary search, tend to have Ω(1) running time
                since in the best case we get lucky and find our element on the first try
***** theta natation
      : we have theta, Θ
      : if the worst-case (Ω) the same as the best-case (O)
***** *visual sorting*                                                            :https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html:
      seeing how selection bubble inserting sort work
***** *merge sort*                                                                :(P59_120):
      O(n log n)    P60-111
**** source code                                                                :cs50/src3:
***** sigma0 sigma1
      : sigma0
      iterative sigma function in black box
      : sigma1
      recursive sigma function tecnically use many memory and may cause a computer crash
*** Memory
**** slides
***** program memory                                                            :(P10):
***** *the stack*                                                                 :(P11):
      1. when main is called, main is given a chunk of memory at the button
         with any arguments to main (like argc, argv)
           and any local variables that main has (like x, y)
      2. meanwhile, if main calls function like swap
           swap is allocate a chunk of memory above main by design
             with its local variable (like a, b)
         when a function call another function, passing in arguments as inputs (like 1, 2)
           the function is being passed to copies of those inputs
      3. but the catch is the moment that swap returns
           everything that was being used above main disappears
             it's not actually deleted, all of this bits is still there
               computer just forgets about these values
         even though it was correct in so far as it swapped a and b
           it did not actually permanent impact on the variables x and y
***** *get_string() in detail*                                                    :(P12):
      1) *a string is technically just the address of a character in memory*
         : string s = get_string();
         string s: I need a variable called s that's big enough to fit a string
         = get_string():
         4) and suppose that the user typed "Zamyla"
            if this string happens to exist at address number 123
            first byte of  Z is 123
            second byte of a is 124
                           m is 125 ...
            end with backslash 0 (\0)
         3) the s is actually going to get returned is the value begin at 123
              (with begin 123 and end \0 two marker, we can infer the entity of string)
         : string t = get_string();
         6) if user typed "Zamyla" again
            it is another chunk of memory begin at 234
         5) t get value 234
      2) *string type is really just a pointer to a character*
         : string t = s;
         string begin at a address with a pointer
         so it is setting t and s point to the address of 123
         : t[0] = toupper(t[0]);
         When we tried to capitalize just one string
           we were just setting t to the address of the string s was pointing to
***** *allocate*                                                                  :(P13):
***** swap                                                                      :(P17_19):
***** pointer gochas                                                            :(P21_22):
***** memory leak                                                               :(P29_31):
      use valgrind to check memory leak
***** the heap   type of overflow                                               :(P32_37):
***** enhance                                                                   :(P39_41):
      zooming in image
      and make the image more clear
***** image represent                                                           :(P42):
      how computer represent a image
***** JPEG                                                                      :(P43_44):
      how computer identify the JPEG format
      255 216 255
***** Hexadecimal                                                               :(P45_53):
      JPEG format start at Hexadecimal
      255 216 255
      11111111 11011000 11111111
      1111 1111  1101 1000  1111 1111
         f    f     d    8     f    f
         0xff       0xd8       0xff
***** BMP                                                                       :(P54_57):
      bit map
      first few bytes of a bitmap (P57)
**** source code
***** compare0 compare1
      : compare0
      : compare the pointer of string
      : slides / get_string() in detail / 1) string is address of character in memory
      $ make compare0
      $ ./compare0
      s: dcc
      t: dcc
      different
      : compare1
      : compare the pointer to the literal of string
      : char *
      a pointer to the address of first character in a string
      char *s = string s
      : strcmp
      string compare
      s and t should be a pointer a string
      strcmp will loop each character in two string
        if they are entirely equal, return 0
      $ make compare1
      $ ./compare1
      s: bar
      t: bar
      same
      $ ./compare1
      s: Bar
      t: bar
      different
***** copy0 copy1
      : copy0
      : change string by using the duplicate of pointer
      : slides / get_string() in detail / 2) string type is really just a pointer to a character
      $ make copy0
      $ ./copy0
      s: dcc
      s: Dcc
      t: Dcc
      : copy1
      : use malloc to allocate memory
      : malloc
      char *t = malloc((strlen(s) + 1) * sizeof(char));
      strlen(s) + 1
        length of string + \0
      in this case is (5 + 1) * 1 = malloc(6)
      remember to free the malloc memoery
      : slides / malloc
      : 1 -> 2
      the one david\0 (begin at 123) -> the one david\0 (begin at 234)
      : 2
      the one david\0 (begin at 234) -> the one David\0 (begin at 234)
      $ make copy1
      $ ./copy1
      s: david
      s: david
      t: David
***** noswap swap
      : noswap
      : pass the copy value of argument to the function
      : slides/the stack
      $ make noswap
      $ ./noswap
      x is 1
      y is 2
      Swapped.
      x is 1
      y is 2
      : swap
      : pass the pointer of argument to the funtion
      : slides / swap
      : 1 -> 2
      : passing pointer
      x (91) -> a (91)
      y (92) -> b (92)
***** pointer  slides / pointer gochas
      : pointer
      : for loop pointer
      : s[i]
      *s       is pointer to first character of string
      *(s+i)   is pointer to ith character of string (like s[i])
      : slides / pointer gochas
      : how to use pointer
      : 1    correct way
      define *x pointer
      malloc the x chunk of memory
      *x point to the x and give the 42 in it
      : 2    incorrect way
      define *y pointer
      *y point to somewhere in memory, so y may be a random value
        so *y point to 13 is error
***** pointer fun with Binky                                                    :https://www.youtube.com/watch?v=6pmWojisM_E:
      three pointer rule
      1) pointer and pointee are separate - don't forget to set up depointee
      2) dereference a pointer to access its pointee
      3) assignment (=) between pointers makes them point to the same pointee
***** memory
      : invalud byte size
      x[10] does not exist
      : memory leak
      *x have allocated a chunk of memory, but not hand it back
        it will cause the system slow down
      : slides / memory leak
      $ valgrind ./memory
***** slides / the heap   type of overflow   hacker inject code
      : the heap
      the stack is used when function are being called
        and they get layered on top of each other
        and get unlayered only once the function's return

      the heap is a chunk of memory above the stack
        you have a pool of avaliable memory that you can draw at any point

      when the stack keep going up then as function return it grows back down
        thereby throwing away, losing track of memory
      the heap does not disposal of memory
        when you call malloc, it use memory persists permanently
        only you call free to give back the memory to system
        and allow it reuse something else

      : type of overflow
      : stack overflow
      keep calling function after function after funtion and never return
        so much so that run out of stack space
      : heap overflow
      call malloc so many times that heap keep growing down hit the stack
      : hacker inject code
      : slides (P34)
      : buffer overflow
      a chunk of space (like a chunk of array memory)
        and you can eventually overflow it by trying to use more memory
      if the length of array bar is large then c
        bad guy have the ability somehow to inject the adversarial code
      : slides (P35)
      what the stack frame for f is actually like
      : 1) the c[12] in f function
      : 2) only argument to the f function
      : 3) Return Address
      main call f funtion
      when f is done, return to this address of main
      : slides (P36)
      that's fine if user provides a string of length 12 or shorter
      : slides (P37)
      if user figure out how to inject a pattern of code
        type in string more than 12 length
        overwrite this Return Address
        not return to main function but adversary's funtion
***** recover image
      the first several bits of a file typically follow a pattern
        you can recover the file by using this serveral pattern of bits
      : slides / enhance
      zomming in image and make it more clear
      get more imformation from this image
      : slides / JPEG Hexadecimal
      because JPEG represent start at Hexadecimal in computer
      you can write software to check memory
        recover all bits start at Hexadecimal to some.jpg
      : slides / BMP
      first few bytes in bitmap
        is standardized inside of the file (P57)
***** structs structs0 structs1
      : structs
      define struct student with string name and string dorm
      : structs0
      printf the array of struct
      : set a constant
      : create a array of structs
      student students[STUDENTS]
      student     the structs include in "structs.h"
      students    the name of struct
      STUDENTS    the constant length of array
      : structs1
      using pointer to write array of structs to the csv file
      : file pointer
      : file printf
      pointer to the students.csv file and write it
      print the struct of student to students.csv
*** Data Structures
**** slides
***** limitations of array                                                      :(P10):
      - can't change length dynamically
        in C
        arrays store the same type of data in a consecutive chunk of memory
          so we can jump to each location by knowing its index
          we can’t always add another element to the end of it
            since the memory right after it might be used to store some other variables
        We could allocate memory of a bigger size
          copy what we had before to the new location
            and add elements there
          but that requires more and more work as our array grows bigger
***** list                                                                      :(P11):
      - a new data type with the ability to dynamically allocate memory
        Each of these rectangles containing a number and an arrow we’ll call a node
          and the arrows will just be a pointer to the next node
        This way, the elements no longer need to be contiguous in memory
          and we can allocate new elements one at a time
***** nodes                                                                     :(P12_13):
      A node will contain the _int n_
        but also a pointer to the next node, a _struct node *_ named _next_
***** linked list                                                               :(P14_15):
      - search running time is O(n)
        This is because each node could be anywhere in memory
          so we can’t use strategies like binary search
        So the running time of this linear search will be O(n)
          even if our list is sorted
      - insetion deleting running time is O(n)
        the same as search running time
***** list operations                                                           :(P16_23):
      insert, delete operation in linked list
***** implementing search                                                       :(P25_26):
      1) Our function declaration takes in two arguments
           the _n_ we are looking for
           and the list, which is a pointer to the first _node_
      2) We make a temporary _node *ptr_ we can use, and set it to what the list is
      3) Then, while there is an element in the list
           we use _ptr->n_ to follow the pointer to a node struct
           and access the _n_ stored within
           If it’s what we’re looking for, we _return true_
           and otherwise, we set our _ptr_ to the next element in the list
      4) Once we have no more elements in the list to look at
           we can _return false_, since we would have returned _true_ if we found _n_ already
***** stacks                                                                    :(P27_28):
      - stack of trays
        Imagine a stack of trays
          where you can easily take the top tray off or put another tray on top
        A data structure with this metaphor called a stack
          does exist, with the operations _push_ and _pop_
            that stores and removes items respectively
      - fist in, last out
        The property we now get is that _the last item we pushed_
          will be _the first one we pop_
          And there are applications where this property is useful
            such as our _stack in memory_ where the next function being called
              is placed on top of the previous function
***** implementing a stack                                                      :(P29_30):
      : the array version
      1) total capacity possible size
      2) now copacity actually size
      : the pointer version
      3) Now we can malloc some chunk of memory to store our numbers
           and only store a pointer in our struct
      4) We also have the benefit of being able to choose how big we want each stack to be

      : TIP
      the pointer version stack that is not fixed from the outset
        not like the array version stack to some specific capacity
***** queues                                                                    :(P31_32):
      - fist in, first out
        enqueue    which places an element at the end of the list
        dequeue    which takes the first element from the beginning of the list
***** implementing a queues                                                     :(P33_35):
      : the array version (P33_34)
      if _A B C D E F G H_ in a queue
      _A B C_ quit the queue
      _I_ enter in the queue
      use front to keep track of where the front is (D in 3)
        and use the size (6) to figure out I
      : the pointer version (P35)
      we can similarly dynamically allocate memory
***** abstract data types
      a stack and a queue does not have a low level meaning as an array does
        which is very technical concept:
          linked list
            it's a node wiht pointers linking things together
          a stack
            is like a stack of cefeteria trays
          a queue
            is something like people lining up outside of an apple store
        which can be implemented a couple of different ways:
          you can use a array keep things simple
            but you're going to a corner by a fixing their size
          but with pointer, and malloc, and dynamic memory allocation
            the spirit of linked list
            you only just remember number pointer
                     just need malloc in order to allocate size
***** tree                                                                      :(P38_40):
      With pointers
        we can also now build data structures that aren’t just one-dimensional
      We can have one node point to multiple other nodes
        and in the case of this data structure
        a tree, we have one root node that points to other children nodes
          like in a family tree
        And nodes without children are called leaves
***** binary search tree                                                        :(P41):
      binary search with pointer (not array)
      a balanced linked list
      the height of tree is log of n (also a running time)
***** implementing a tree                                                       :(P42_43):
      : tree node (P42)
      To implement a binary search tree, we might start with defining a node
      : recursion tree searching (P43)
      recursion work beautifully so long as every time to recurse
        every time funtion calls itself it take a smaller bytes of the problem
        or you throw away half of the problem
***** huffman coding                                                            :(P44):
      : use huffman coding to compression ASCII character (P44)
      Recall that characters are encoded using ASCII, with a byte per character
        But if we only use a few characters, and some more frequently than others
        we can use fewer bits for the most common characters
      Huffman coding is a system that uses this concept for compression file (like .txt)
      : compare with morse code, huffman coding have no ambiguous (P45)
      Morse code, too, uses shorter series of dots and dashes for more common letters
        But some messages might be ambiguous
        For example, H is four dots in a row
                 and I is two dots in a row
                 and E is one dot, so six dots in a rows could either be HI or EEEEEE
      : how to compression ASCII character using huffman tree (P46_53)
      : First, we count the frequency of each character as a fraction of the message (P47)
      : Then, we use the fewest bits for the most common characters
      :   and build a tree like this (P52)
      We build this by starting at the bottom
        by taking the two smallest nodes and combining them
        and adding their frequencies together (P48_51)
      : that E, the most common character
      :   uses only one bit, 1, to represent
      :   and the least frequent letters, B and C requires the most
      :     either 0000 or 0001 (P53)
      : a leaf represent in a Huffman tree (P54)
***** hash tables
      Yet another data structure is a hash table
        with many operations taking O(1)
        a constant number of steps
***** bucket
      Imagine we have buckets, each labeled with a letter of the alphabet
        And we have exam booklets from students
          so we place them into each bucket based on the first letter of their name
        Our hash function will thus be using the first letter of their name
        So now we can work with 1/26th as many exam booklets at once
          if we know which bucket to look in. And if we use the same hash function
          we can always repeat the process and sort our booklets into the same buckets
***** linear probing                                                            :(P56_57):
      : A hash table looks like an array
      We might store any piece data in each of the location in the hash table
        but we can get close to a constant time lookup
      : Since a hash table is an array
      :   we might have multiple items that want to fit into the same slot
      :   So we could just move to the next slot in a technique called linear probing (P57)
      If we are inserting a name like _Alex_ or _Aaron_ but a name in the A slot
        _Alice_, is already present, then we just move down our hash table to the next slot
***** separate chaining                                                         :(P58):
      : We can also contain a pointer to a linked list in each of its locations
      :   so a particular bucket can expand horizontally
      This technique is called separate chaining
        where we have smaller and smaller linked lists as our hash table grows bigger
      In the worst case, if everyone shares the same first letter of their name
        we have a running time that’s linear again
        but in the real world, the actual running time might be closer to 1/26th as before
***** trie                                                                      :(P59):
      : Finally, we have another data structure called a trie
      a dictionary data structure
        this is esesentially a tree with an array as each of its children
        Each array contains pointers to the next layer of arrays
      the running time for looking up words based on the length of letters
        EANO    4 steps
        AVLOV   5 steps
      : source code / speller
***** implement a hash table                                                    :(P61):
***** implement a trie                                                          :(P62):
**** source code                                                                :(cs50/src5):
***** speller
      create the fastest (real-time) spell check data structure (hash table version)
****** dictionary.c
******* node
        : how to implement a hash table (P58)
        a hash table is a array of linked list, each elements of array is a node*
          1) implement a linked list
          2) implement a hash table (a array of linked list)
******* hash_it
        : Hash function
        algorithm for caculating the index of hash table
        - example
          # if the word is 'BAT'
          # the 'B' bucket index
          i = 0
          hash = 0x00
          needs_hashing[0] = 'B'
          hash << 2 =  0000
          hash = 0x00 ^ 0x42  (0000 ^ 0100 0010)
          hash = 0x42  (0100 0010)
          # the 'BA' bucket index
          i = 1
          hash = 0x42
          needs_hashing[1] = 'A'
          hash << 2 = 0100 0010 << 2 = 0001 0000 1000
          hash = 0x108 ^ 0x41  (0001 0000 1000 ^ 0100 0001)
          hash = 0x149  (0001 0100 1001)
          # the 'BAT' bucket index
          i = 2
          hash = 0x149
          needs_hashing[2] = 'T'
          hash << 2 = 0001 0100 1001 << 2 =  0000 0101 0010 0100
          hash = 0x524 ^ 0x54 (0000 0101 0010 0100 ^ 0101 0100)
          hash = 0x570    (0000 0101 0111 0000)
          # get 'BAT' bucket index
          return hash % HASHTABLE_SIZE  = 0x570
******* check
        : make a new word
        get the duplicate of word
        tolower
          case insensitive
        '\0'
          add the NULL terminal to the end of word
        : check the word in dictionary
        check if the word exist in dictionary
          yes return true
          no return false
******* load
        : load dictionary file, and format it use hash_it function
        : scan dictionary word by word
        fscanf(fp, "%s", new_node->word);
          take dictionary filei          (fp)
          look for string                ("%s")
          put the string in a variable   (new_node->word)
******* size
******* unload
*** HTTP
**** slides
***** web programming                                                           :(P14):
      1) Hyper Text Markup Language (HTML)
      2) Document Object Model (DOM)
***** home network                                                              :(P16):
***** DHCP & IP                                                                 :(P19_23):
      private IP
***** DNS
      Domain Name System
***** routers
      use IP to decide which to route your imformation
***** nslookup
      $ nslookup www.google.com
      Server:         140.247.233.195
      Address:        140.247.233.195#53

      Non-authoritative answer:
      Name:   www.google.com
      Address: 172.217.4.36       # use DNS to find IP address
***** traceroute                                                                :(P29):
***** undersea cabling
      the internet from country to country use undersea cabling
***** packets                                                                   :(P32_33):
      route information based on the destination IP
      by using packets from router to router (like a envelope)
***** TCP
      there exists a technology called TCP (Transmission Control Protocol)
        that splits data into pieces, and sends multiple packets
        And those packets are labeled with something like 1 of 4 or 2 of 4
          so we can order them and know we got them all
      there is other protocols, one of which is called UDP
        often used for the streaming and for video and applications like that
          where you really want the software to forge ahead
            rather than wait for some new data to get transmitted
***** Ports                                                                     :(P35):
      TCP also provides a standardization of services number
        to distinguish the type of packets
***** firewall
      Firewalls keep out packets
        so they might be used to block certain websites
        or keep in packets
          to prevent sensitive information from leaving
        And this is implemented with a local router looking at all the packets
          and simply not sending ones with certain addresses
        And it could also block all traffic on a certain port
***** VPN
      There are services called VPNs (Virtual Private Networks)
        that you can use to connect to your company or school’s network
        An encrypted tunnel is created to route all your traffic through the VPN first
          before being sent out to the internet
        But the cost of this is that it now takes more time to send our packets there first
***** warrior of the Net
      how internet work
      https://www.youtube.com/watch?v=PBWhzz_Gn10
***** HTTP GET                                                                  :(P41_45):
      HTTP (HyperText Transfer Protocol) is a protocol
        like a sort of handshake agreement
        that governs that when I want to request information of a server
        I should say GET and then a few other words
          and then the server should respond with OK and a few other words
***** status codes  telnet  curl                                                :(P46_48):
      : status codes
      the number are actually sent in these packets of information (P46)
        back and forth from the server
      : telnet curl
      what page, what funtion you look up in a URL
***** quert strings                                                             :(P49_50):
      If we now visit Google and search for something like "cats"
        we might end up at some long URL
        But we can change it to what we understand: http://www.google.com/search?q=cats
***** HTML                                                                      :(P53_55):
      HTML is a markup language
        that really controls formatting and layout
        there aren't ifs and loops and other control constructs
***** CSS
      CSS, Cascading Style Sheets
        While HTML is used to mark up web pages
          or indicate their hierachy and content
        CSS is used to change the look and appearance of web pages
**** source code                                                                :(src6):
***** image
      : />
      since no other content goes inside an img tag
        we simply close the start tag with />
      : alt
      alternative text the browser describe over image
***** link
      : a
      The a tag is for anchor, with a href, or hyper-reference
***** paragraph
      : p
      Notice that we have Latin paragraphs, each in a separate <p> tag
***** headings                                                                  :(P56):
***** list
      : ul ol
      <ul>      unordered list
      <ol>      ordered list
***** table
***** css0 css1 css2
      : slides / CSS
      : css0
      mix css into html
      : css1
      factor out css
      : css2
      reuse css and separate it into a file
      : &#169
      html entity, the special symbol ©
***** search
      : method
      GET - Requests data from a specified resource
      POST - Submits data to be processed to a specified resource
*** Machine Learning
**** slides                                                                     :week7:
***** introduce machine learning
      sklearn svm AI
      +search engines+  image recognition  +voice recognition+  natural language processing
***** image classification                                                      :(P11_17):
      one-dimension classification    (P14)
      two-dimensions classification   (P15)
      image classification            (P17)
***** Lineland Flatland Spaceland Beyond                                        :(P22):
      how to draw high-dimention       (P23)
      map image to high-dimention      (P25)
      real-world image represent       (P26_27)
        eight by eight array of pixels
        the color number between 0 and 16
      how to test training point       (P28_31)
        one two three - dimention dist (P29)
        image is a 64-dimentions dist  (P30-31)
***** introducing python                                                        :(P33_34):
      : 1
      in python, there is no need curly bracket
        it's simply matter of the indention you use
***** *Supervised Learning in python*                                             :http://cdn.cs50.net/2016/fall/lectures/7/notes7.html:
      : Supervised Learning
      what is supervised learning


      : Classifying points
      how to implement points classification in python
      : dist(x,y)             (In[9] - P35)
      calculating the distance from test point to labeled training dataset


      : Classifying images
      how to implement images classification in python
      : digits                (In[13] - P36)
      import Labeled training set
      : digits.image[0]       (In[14_15] - P38)
      2) the first image of labeled training set
      : digits.target[0]      (In[16] - P38)
      1) Labeled Training subset 0

      : test single image         (In[17_21] - P36_37)
      : X_train Y_train           (In[17] - P37)
      extract the 10 images of Training set
        X_train    10 training set
        Y_train    0_9 training subset
      : X_test                    (In[18_19] - P36)
      Test point 3
      : distance                  (In[20_21] - P37)
      dist the Test point and the Testing set, get the index with smallest distance

      : test 100 images           (In[22] - P38)
      test 100 images (4 Testing set) with 10 training set (3 Training set)
        and print the error results

      : test 100 images with 1000 training set (In[23_24] - P39)
      : Improving the performance
      the error results is only 3
***** *deep learning*                                                             :(P44 47_48):
      the challenges to image recognition (P44)
      Image recognition algorithms can be improved
        by grouping pixels in an image into features
        in a process called deep learning (P47)
      A lot of computational power is needed for these algorithms
        and libraries like _TensorFlow_ help build programs
          that use machine learning to solve some problem (P48)
***** *text clustering*                                                           :(P56):
      : Unsupervised Learning


      : Clustering points             (In[25_31] - P59)

      : k-means
      how many clustering to group
      : two clustering                (In[28_29])
      : three clustering              (In[30])
      : seven clustering              (In[31])


      : clustering documents

      : the simple document           (In[32_39] - P62_68)
      : corpus                        (In[32] - P62)
      something simple document
      : count_vect                    (In[33] - P65)
      the english stop_words
      : fit_transform                 (In[33] - P64)
      build the vocabulary, and format it in matrix
      : vocab                         (In[34] - P65)
      Bags of words
      : todense                       (In[35] - P65)
      generate a matrix from Z
      : TfidfVectorizer               (In[36] - P66_67)
      the tf-idf (Term Frequency times Inverse Document Frequency)
      - example
        Consider the document a) containing 6 keywords
          wherein the word _awesome_ appears 3 times
          The term frequency (i.e., tf) for cat is then (3 / 6) = 0.5
        we have 4 documents and the word _awesome_ appears in one of these
          Then, the inverse document frequency (i.e., idf) is calculated
            as log_10 (4 / 1) = 0.6
        Thus, the Tf-idf weight is the product of these quantities: 0.5 * 0.6 = 0.3
      : kmean                         (In[38] - P68)
      : print the outcome             (In[39])

      : clustering movies based on their IDMB synopses (P57)
      : import external data          (In[40_41])
      : corpus                        (In[42])
      loop each data content and append to a list of string
      : TfidfVectorizer               (In[43])
      generate the tf-idf matrix
      : kmeans                        (In(44))
      use kmeans algorithm to group cluster
      : print the outcome             (In[45])
**** source code
*** Python
*** SQL
*** Javascript
* algorithm
** CANCELLED 算法导论 introduction to algorithmns
   CLOSED: [2017-09-17 日 10:19]
   :LOGBOOK:  
   - State "CANCELLED"  from ""           [2017-09-17 日 10:19] \\
     far more complex for me, may be reopen sometimes
   :END:      
*** 基础知识 foundations
    第一章 综述
    第二章 排序
    第三章 渐进表示
    第四章 分治法
    第五章 概率分析 随记化算法
**** 算法 algorithm
     交通图                     十字路口                         最短路径
     DNA链         X有m个序列 Y有n个序列 2^m或2^n次方子序列        动态规划
     机械设计           列出部件 m个部件 m!可能的顺序              拓扑排序
     寻找凸壳        给定平面上n个点 包含2^n次方凸壳定点            凸壳求法

     数据结构                  存取和组织数据 访问和修改
     技术          求中位数 顺序统计量 计算最小生成树 确定网络中的最大流 ...
     难题                            NP完全算法
**** 作为一种技术的算法
     插入排序    排序n个项 所花时间c1*n^2       c1是常数 \
                                                        c1<c2  n较小     插入排序快
                                                        n较大  lgn<n^2   归并排序快
     归并排序    排序n个项 所花时间c2*n*lgn     c2是常数 /

   * 算法需要 f(n) 毫秒    在时间 t 内求解的最大规模 n
     | f(n)\t |  1 sec |      1 min | 1 hour       | 1 day | 1 month | 1 year | 1 century | n          |
     |--------+--------+------------+--------------+-------+---------+--------+-----------+------------|
     | lgn    | 2^1000 | 2^(6*10^4) | 2^(3.6*10^5) |       |         |        |           | 2^t        |
     | √n     | 1*10^6 |   3.6*10^8 | 1.2*10^12    |       |         |        |           | t^2        |
     | n      | 1*10^3 |     6*10^4 | 3.6*10^5     |       |         |        |           | t          |
     | nlgn   |    140 |       5000 | 2.3*10^4     |       |         |        |           | 2^(t/n)    |
     | n^2    |     31 |      244.9 | 600          |       |         |        |           | √t         |
     | n^3    |    9.9 |       39.1 | 71.6         |       |         |        |           | 3√t        |
     | 2^n    |    9.9 |       15.5 | 18.4         |       |         |        |           | lgt        |
     | n!     |    6.1 |        8.1 | 9            |       |         |        |           | √(2t) -1/4 |
*** 算法基础
**** 插入排序 insettion sort
     #+Name: <INSERTION-SORT(A)>
     #+BEGIN_SRC <pseudocode>
        for j = 2 to A.length
            key = A[j]
            i = j - 1
            while i > 0 and A[i] > key
                  A[i+1] = A[i]
                  i = i - 1
            A[i+1] = key
     #+END_SRC

     + +  +  + ... +  +
     \ /
     \ /\ /
     \ /\ /\ /
     \ /\ /\ / ...  \ /
**** 分析算法 analyzing algorithm
     - 插入排序耗时分析 running time of algorithm 47
       - 代价与对应元素求和 sum the products of the cost and time columns 47
         - 最佳情况 best-case           an+b
         - 最差情况 worst-case          an^2+bn+c
         - 增长量级 order of growth     n^2 > n
**** 设计算法 designing algorithm
***** 分治法 the divide-and-conquer approach
      分解 Divide
      解决 Conquer
      合并 Combine

      - 归并排序 merge sort
                          分解n个元素序列成n/2个子序列                  ->                         递归排序两个子序列             ->             合并排序结果
        divide n-elements sequence into two subsequence of n/2 element each            sort two subsequence recursively           merge two sorted subsequence
        #+Name: <MERGE(A,p,q,r)>    A-array    p,q,r-indices under A (p<q<r)    A[p..q] and A[q..r] in sort order (1)
        #+Begin_SRC <pseudocode>
          n_1 = q - p + 1  // (2) computes the length n_1 of subarray A[p..q]
          n_2 = r - q  // (3) computes the length n_2 of subarray A[q+1..r]
          let L[1..n_1+1] and R[1..n_2+1] be new array  // (4) create array L and R of lengths n_1+1 and n_2+1 respectively (the extra position in each array will hold the sentinel)
          for i = 1 to n_1
            L[i] = A[p + i -1]  // (5) copy A[p..q] into L[1..n_1+1]
          for j = 1 to n_2
            R[j] = a[q + j]  // (6) copy A[p+1..q] into L[1..n_2+1]
          L[n_1 + 1] = ∞
          R[n_2 + 1] = ∞  // (7) set sentinel into L and R
          i = 1
          j = 1
          for k = p to r
            if L[i] <= R[j]
               A[k] = L[i]
               i = i + 1
            else A[k] = R[j]
               j = j + 1  // (8)
        #+END_SRC

                                                                      A  [2 4 5 7 1 2 3 6]                            (1)
                                                             A  [1..n_1]                A  [1..n_2]                 (2) (3)
                                                           A/2 [2 4 5 7]              A/2 [1 2 3 6]                   (4)
                                                             L [2 3 5 7]                R [1 2 3 6]                 (5) (6)
                                                            L [2 3 5 7 ∞]              R [1 2 3 6 ∞]                  (7)

                                                                              A  []
                                                                              k ->
                                                                                |
                                                                                <?
                                                                           /         \
                                                                         i ->   :   j ->
                                                                     L []               R []                          (8)
*** 数学基础知识 appendix mathematical background
**** 求和 summations
** CANCELLED 计算机程序设计艺术 the art of computer program
*** PROJECT 第一卷
    :PROPERTIES:
    :COLUMNS:  %20ITEM %50DISCRIBE %50OVERVIEW %30MATHEMATIC
    :END:
**** 欧几里得算法 euclidean algorithm
    :PROPERTIES:
    :DISCRIBE:     给定两个正整数m和n 求它们最大公因子 能够同时整除m和n的最大正整数
    :OVERVIEW:     [[算法E的流程图]] [[算法E的流程表]]
    :MATHEMATIC:   [[算法E的集合论]]
    :END:
    - <<算法E的流程图>>
                         V------------------------------|
      E0.确保(m>=n)  ->  E1.求余数  ->  E2.余数为0?  -->  E3.减少
                                           |        N
                                           | Y
                                           V
    - <<算法E的流程表>>
      | step | purpose        | detail                       | m    | n    | r     | tag                                                        |
      |------+----------------+------------------------------+------+------+-------+------------------------------------------------------------|
      | E0   | ensure(m>=n)   | if(m < n) m <-> n            | m(n) | n(m) |       | .            [fn:input]                                    |
      | - E1 | find remainder | m % n = r (0 <= r < n)       | m    | n    | m % n | <<E1>>       [fn:definiteness] [fn:effectiveness]          |
      | - E2 | is it zero?    | if(r = 0) return n           |      | *n*    | r = 0 | terminate    [fn:finiteness]   [fn:output]    [fn:analyze] |
      | - E3 | reduce         | else m <- n, n <- r  goto E1 | n    | r    |       | [[E1]]                                                         |

    - <<算法E的集合论>>
      - template 1
                 *Q* -- *Ω*        (1) input x_0  -----------------------------E0
        *(1)*    /               (2) x_1 = f(x_0)  --------------------------E1
        -->  *I*      /          (3) if exist k>=0  f(x_k) = x_k = min Ω  ---E2
               \   / *(3)*           else goto (2)  -------------------------E3
            *(2)* \
               f(x_k)

        | elements            | Q                             | I                                      | Ω        | f                           |
        |---------------------+-------------------------------+----------------------------------------+----------+-----------------------------|
        | quadruple (Q I Ω f) | a set contain subsets I and Ω | x_0 = x  and  x_k+1 = f(x_k)  for k>=0 | f(q) = q | function from Q into itself |

      - template 2

        (m,n,0,1)  ->  (m,n,remainder of m divided by n,2)  ->  r = 0 ?  ->  (n)
           (1)                         (2)                               Y   (3)
                                        ^--         <--         --| N
                                           (n,r,r,1)    (m,n,r,3)
                                              (5)          (4)
        - <<f2:>>
          (1) f((m,n)) ------------------- E0
            (2) f(m,n,r,1) --------------- E1
              (3) f((n)) ----------------- E2 output
            (4) f(m,n,r,2) --------------- E2 loop (4) (5) (2)
            (5) f(m,n,p,3) --------------- E3

        | elements  | Q                                        | I     | Ω   | f  |
        |-----------+------------------------------------------+-------+-----+----|
        | (Q I Ω f) | (n) (m, n) (m,n,r,1) (m,n,r,2) (m,n,p,3) | (m,n) | (n) | [[f2:]] |

      - *template 3*

        *one state of complutation*      *states of computation*      *instantiation A*      *E*
                                                                                            Y                  N
                    A              -->           A^*          -->        σ       ->    Q    - >   loop (σ, j)  -> (3)
              (xj  1≤ j≤ n)              (x1 x2 ... xn  n>=0)                         (1)  \   / Y
                                                                                            < -
                                                                                       | N
                                                                                       V

                                                              -->        θ       ->   (2)
                                                                      (0<=j<N)   Y

        - <<f3:>>
          (1) f(σ, j) = (σ,       a_j)  if θ_j does not occur in σ ------------------------------------E3
          (2) f(σ, j) = (α φ_j ω, b_j)  if α is the shortest possible string for which σ = α θ_j ω ----E2 output
          (3) f(σ, N) = (σ,       N  )  ---------------------------------------------------------------E1

        | elements        | A                       | A^*                     | N                     |
        |-----------------+-------------------------+-------------------------+-----------------------|
        | A A^* N Q I Ω f | a finite set of letters | set of all strings on A | a nonnegative integer |

        | elements | Q                                    | I                      | Ω                      | f   |
        |----------+--------------------------------------+------------------------+------------------------+-----|
        | Q I Ω f  | set of all (σ, j) *[fn:restriction_Q]* | subset of Q with j = 0 | subset of Q with j = N | [[f3:]] |

        | elements  | σ | θ | α | ω        | j                       |
        |-----------+---+---+---+----------+-------------------------|
        | σ θ α ω j | m | n | r | constant | the step of computation |

[fn:finiteness]     有限性 一个算法在有限步骤后必然要中止
                    算法E中: r<n 有限次计算后 n的值逐渐减少 最终r=0 算法中止并给出最终解n
[fn:definiteness]   确定性 算法每个步骤必须精确定义
                    算法E中: 确切的理解m%n 执行E1时m和n都为正整数
[fn:input]          输入 一个算法有零个或多个输入
                    算法E中: 输入为m和n
[fn:output]         输出 一个算法有一个或多个输出
                    算法E中: 输出为n
[fn:effectiveness]  能行性 (或称有效的) 原则上每个步骤要充分描述 并在有效的时间内精确完成
                    算法E中: 如果m和n涉及的是无穷小数 同样的运算就不是可行的
[fn:analyze]        算法分析 给定一个算法 确定它的性能特征
                    算法E中: 执行的平均次数Tn近似于(12(In 2)/π^2)In n [[详情]]
*[fn:restriction_Q]*  对Q添加能行性的描述:
                    1) σ in A^*
                    2) j is a integer(0 ≤ and ≤ N)

**** 数学准备 mathematical preliminaries
***** 数学归纳法 mathematical induction
     :PROPERTIES:
     :DISCRIBE:     给定公式 如何用数学归纳法证明
     :OVERVIEW:     [[算法I的流程图]] [[古代等式序列]] [[斐波那契数列]] [[扩充欧几里得算法]] [[如何真正了解一种算法]]
     :MATHEMATIC:   [[等式归纳]] [[递归归纳]] [[断言归纳]]
     :END:
     - <<算法I的流程图>>
                      v--------------------------|
       *I1*.证明P(1) -> *I2*.k=n? -> *I3*.证明P(k+1) -> *I4*.k加1
                      v 是    否
     - <<古代等式序列>>

       | *formula*                                              |   | *diagram* | 1 | 2 | 3 | ... | n | n+1 |
       |------------------------------------------------------+---+---------+---+---+---+-----+---+-----|
       | 1 = 1^2                                      <<(1)>> |   | 1       | + | + | + |     | + | +   |
       | 1 + 3 = 2^2                                          |   | 2       | + | + | + |     | n | +   |
       | 1 + 3 + 5 =3^2                                       |   | 3       | + | + | + |     | n | +   |
       | ...                                                  |   | ...     |   |   |   | ... |   |     |
       | 1 + 3 + ... + (2n-1) = n^2                   <<(2)>> |   | n       | + | + | + |     | + | +   |
       | 1 + 3 + ... + (2n-1) + (2n+1) = (n+1)^2      <<(3)>> |   | n+1     | + | + | + |     | + | +   |

       | step | condition  | describe                        | detail | next step |
       |------+------------+---------------------------------+--------+-----------|
       | I1   | set k <- 1 | P(1) is true, since 1 = 1^2     | [[(1)]]    | I3        |
       | -I2  |            |                                 |        | output    |
       | I3   | let k <- n | if P(n) is true                 | [[(2)]]    | I4        |
       | I4   | then k + 1 | then proves P(n+1) is also true | [[(3)]]    | I2        |

       - <<等式归纳>>
         1  2  3  ... n                 n+1
          \   get n  /
         | 1 is true?
                        \ n+1 is true? /

     - <<斐波那契数列>>

       条件:     对于数列  0 1 1 2 3 5 8 13 ...
                    存在  Φ = (1+sqrt(5))/2

       证明:     F(n) <= Φ^(n-1)

       - <<递归归纳>>
       | step  | F        | Φ             |                                      |
       |-------+----------+---------------+--------------------------------------|
       | I1    | F(1) = 0 | 1             | true                                 |
       |       | F(2) = 1 | 1.6           | true                                 |
       | I3-I4 | F(n-1)   | Φ^(n-2)       | if true                              |
       |       | F(n)     | Φ^(n-1)       | if true                              |
       |       | F(n+1)   | Φ^(n-2)x(1+Φ) | proof valid     F(n-1) + F(n)        |
       | I2    | F(n+1)   | Φ(n)          | true            because  1 + Φ = Φ^2 |

       - <<递归归纳>>
         Φ     Φ   Φ   Φ        Φ             Φ        Φ
         1     2   3   5  ...  n-1            n       n+1
         | 1 is true?
                                  \ if true /   ->   true?
     - <<扩充欧几里得算法>>

       条件:     给定两个正整数 m 和 n
       证明:     计算它们的最大公因子 d
                 和两个整数 a 和 b
                 使得 am + bn = d

                                     A6
                            v-----------------|
       start   -   E1   -   E2   -   E3   -   E4
               A1       A2       A3   \   A5
                                     A4\
                                       stop

       | operation | assertion | describe                              | detail          |
       |-----------+-----------+---------------------------------------+-----------------|
       |           | A1        | m > 0    n > 0    (m n is integer)    | limit           |
       | E1        |           | a <- 0    a' <- 1    c <- m           | initialize      |
       |           |           | b <- 1    b' <- 0    d <- n           |                 |
       |           | A2        | c = m > 0     d = n > 0               |                 |
       |           |           | a = b' > 0    a' = b = 1              |                 |
       | E2        |           | q <- quotient (c / d)                 | divide          |
       |           |           | r <- remainder(c / d)                 |                 |
       |           | A3        | am + bn = d    a'm + b'n = c = qd + r |                 |
       |           |           | 0 < = r < d    gcd(c, d) = gcd(m, n)  | [fn:gcd]        |
       | E3        |           | r = 0?                                | remainder zero? |
       |           | -A4       | am + bn = d = gcd(m, n)               | output          |
       |           | -A5       | am + bn = d    a'm + b'n = c = qd + r |                 |
       |           |           | 0 < = r < d    gcd(c, d) = gcd(m, n)  |                 |
       | -E4       |           | c <- d    d <- r                      | recycle         |
       |           |           | t <- a'   a' <- a    a <- t - qa      |                 |
       |           |           | t <-b'    b' <- b    b <- t - qb      |                 |
       |           | -A6       | am + bn = d    a'm + b'n = c    d > 0 |                 |
       |           |           | am + bn = d = gcd(m, n)               |                 |

       - <<断言归纳>>

         - operator
           m = qn + d
           c = qd + d  <-  d = am + bn
           c = (aq + 1)m + (bq + 1)n
           c = a'm + b'n  ->  a' = aq + 1 and b' = bq + 1

         - assertion
           c = a'm + b'n
           d = am  + bn

         - induction
           如果在执行一个框的操作之前 引向本框的任意一个箭头所附的断言为真
           if any one of assertions on the arrows leading into box is true before the operation in that box is performed
           则在该操作之后离开本框的有关箭头上的断言也为真
           then all of the assertions on the arrows leading away from the box are true after the operation

           A2 (A6 (A3 (A4 A5)))
     - <<如何真正了解一种算法>>

                               the understanding of the theory of a routine
             may be greatly aided by providing, at the time of construction
                  one or two statements concerning the state of the machine
                                                   at well chosen point ...

                                                    编写程序的时候 在合适的地方
                                                   提供一两个涉及机器状态的命题
                                          可能会大大有助于对对程序理论的理解 ...

                              in the extreme form of the theoretical method
             a watertight mathematical proof is provided for the assertions

                                                               在理论方法一端
                                                     对于断言提供严密的数学证明

                                  in the extreme of the experimental method
           the routine is tried out in the machine with a variety of inital
       conditions and is pronounced fit if the assertions hold in each case

                                                               在实验方法一端
                                         应用各种各样的初始条件在机器上对程序试验
                                              如果每种情况下断言都成立则宣告成功

                                           both methods have their weakness
                                                            两种方法都有其弱点

                                       -- A. M. TURING | Programming Manual

[fn:gcd] 最大公因數（greatest common divisor)
***** 数 幂和对数 numbers powers and logarithms
      - integers
        ..., -3, -2, -1, 0, 1, 2, 3 ,...
      - rational number
        p / q
        radio(quotient) of two integers
      - real number
        x =   n   +   0.d₁d₂d₃...
           integers   a digit between 0 and 9
        π = 3.1415926...  the radio of circumference to diameter in a circle
        φ = 1.6180339...  the golden radio(1 + √5)/2
      - complex numbers
        z = x + iy
        x and y is real number
        i² = -1
        $$|z| = √{x²+y²}$$
        \macr{z}z = x² + y² = |z|²  % the complex conjugate of z
      - logarithm
        bˣ = y
        x = log_b y = b^{log_b x} = log_b (bˣ)
        log (xy) = log_b x + log_b y  (x > 0, y > 0)
        log_b cʸ = y log_b c  (x > 0)
        lgₓ = log₂ x
        log_c x = log_b x / log_b c
        - natural logarithms
          In x = logₑ x  (e = 2.71828...)
          [[~/Desktop/In x.png]]
          eʳ (the interest for 1 dollar)
***** 和与积 sums and products
     
* tools
** DONE vim实用技巧 Practical Vim
   :PROPERTIES:
   :COLUMNS:  %20ITEM %50SUMMARY %30SOURCE %OPERATE
   :END:
*** 启动及功能列表
   + $ vim -u NONE -N  恢复出厂设置 19
   + $ vim -u code/essential.vim  自定义插件形式启动 20
   + 功能列表 21 
*** 以vim的方式解决问题 The Vim way
    :PROPERTIES:
   :SUMMARY:  思考的方式决定编码效率
   :SOURCE:   the_vim_way
   :END:
**** .命令 meet the dot command                                                 :.u:
   :PROPERTIES:
   :SUMMARY: 不要重复自我
   :SOURCE:  0_mechanics.txt
   :OPERATE: x -> . -> ..  dd －> .
   :END:
   *+ .  重复上次操作 [[:h .]]*
   + x  删除光标下的字符
   + dd  删除光标下一整行
   + u  撤销上次操作
   + >G  缩进层级 30
**** 减少无关的移动 don't repeat yourself                                       :$aA:
   :PROPERTIES:
   :SUMMARY: 注意组合键的使用
   :SOURCE:  2_foo_bar.js
   :OPERATE: A;<Esc> -> j -> . -> j.
   :END:
   + $  移动到行末 31
   + j  下移一行
   + a  光标之后添加内容
   *+ A  组合键 $ a*
**** 以退为进 take one step back, then three forward
   :PROPERTIES:
   :SUMMARY: 要替换可先删除再添加
   :SOURCE:  3_concat.js
   :OPERATE: f+ -> *s␣+␣<Esc>* -> ; -> . -> ;. -> ;.
   :END:
   *+ f[char]  找指定字符 [[:h f]]*
   + ;  向下重复上次查找
   + ,  向上重复上次查找
   + s  组合键 c l 31
**** 执行 重复 回退 act repeat reverse
   :PROPERTIES:
   :SUMMARY: 一系列内部命令的撤销操作
   :END:
   | 操作         | 目的             | 重复 | 回退 |
   |--------------+------------------+------+------|
   | {edit}       | 文本修改         | .    | u    |
   | f{char}      | 向下查找字符     | ;    | ,    |
   | F{char}      | 向上查找自负     | ;    | ,    |
   | /pattern<CR> | 查找下一处匹配项 | n    | N    |
   | ?pattren<CR> | 查找上一处匹配项 | n    | N    |
**** 查找并替换 find and replace by hand
     :LOGBOOK:  
     CLOCK: [2016-08-23 二 19:50]--[2016-08-23 二 20:12] =>  0:22
     CLOCK: [2016-08-23 二 19:41]--[2016-08-23 二 19:50] =>  0:09
     :END:      
     :PROPERTIES:
     :SUMMARY:    [[使用点范式逐个查找替换]]
     :SOURCE:     1_copy_content.txt
     :OPERATE:    光标放在content上 -> * -> cwcopy<Esc> ->n -> .
     :END:
     - 替换所有 content 为 copy
       ...We're waiting for content before the site can go live...
                       (1) ^content
                       (2) copy^
       ...If you are content with this, let's go ahead with it...
                 (1) content
                (3) ^content
                 (4) copy^
       ...We'll launch as soon as we have the content...
                                          (1) content

       - <<使用点范式逐个查找替换>>
         (1) *   查找当前光标下单词 并高亮显示所有匹配项 [[:h *]]*
         (2) cw  删除光标起始位置到单词结束 并进入插入模式
         (3) n   跳到下一个匹配项
         (4) .   重复(2)(3)  <<点范式>>  [[替换-确认模式]]
**** 结识.范式 meet the dot formula
     :LOGBOOK:  
     CLOCK: [2016-08-23 二 20:13]--[2016-08-23 二 20:18] =>  0:05
     :END:      
     :PROPERTIES:
     :SUMMARY: 总结规律一键移动一键执行
     :END:
*** 模式 Modes
**** 普通模式 (normal mode)
     :PROPERTIES:
     :SUMMARY: 操作符与动作命令结合在一起
     :SOURCE:  normal_mode
     :END:
***** 停顿时请移开画笔 pause with your brush off the page
      :LOGBOOK:  
      CLOCK: [2016-08-23 二 20:28]--[2016-08-24 三 08:15] => 11:47
      :END:      
      :PROPERTIES:
      :SUMMARY: 大时间思考小时间编码放松
      :END:
***** 把撤销单元切成块 chunk your undos
      :PROPERTIES:
      :SUMMARY: 模式切换调整细粒度
      :END:      
      - I(插入模式) -> 编写代码 -> <Esc>(思考的时候进入普通模式) -> u(撤销先前操作) 或 A o(继续进入插入模式编写代码)
      - 插入模式 <up> <down> <left> <right>   the same as   普通模式 h j k l操作  result  会产生一个新的撤销快
***** 构造可重复的修改 compose repeatable changes
      :PROPERTIES:
      :SUMMARY: 相同按键效率不同.命令影响
      :SOURCE:  the_end.txt
      :OPERATE: d -> bx  b -> dw  daw
      :END:
      The end is nigh
                    ^
                 +nig+   (1)
                    +h+  (2)
                 +nigh+  (3)
      - db  删除光标起始位置到单词结束(保留光标下那个词) (1)
      - x  删除光标下那个词 (2)
      - b  移到单词开头
      - dw  删除整个单词 [[:h aw]] (3)
      - daw  删除整个单词(aw为文本对象) (3)
      | 操作 | 目的         | 实际效果 | .命令效果 |
      |------+--------------+----------+-----------|
      | dbx  | 反响删除     | db x     | x         |
      | bdw  | 正向删除     | b dw     | dw        |
      | daw  | 删除整个单词 | daw      | daw       |
***** 用次数做简单的算术运算 use counts to do simple arithmetic
      :LOGBOOK:  
      CLOCK: [2016-08-24 三 09:34]--[2016-08-24 三 10:56] =>  1:22
      :END:      
      :PROPERTIES:
      :SUMMARY: <<带数字的运算>>
      :SOURCE:  sprite.css
      :OPERATE: yyp -> cW.news<Esc> -> *180<C-x>*
      :END:
      target
        .blog, .news { background-image: url(/sprite.png); }
        .blog { background-position: 0px 0px }
      change
        .blog, .news { background-image: url(/sprite.png); }
        .blog { background-position: 0px 0px }
        .news { background-position: -180px 0px }
      - [[:h count]]
      - yyp  复制一整行 光标移到下一行行首
      - cw  修改第一个单词
      - <C-a>  数字加法运算
      - <C-x>  数字减法运算
***** 能够重复 就别用次数 don't count if you can repeat
      :LOGBOOK:  
      CLOCK: [2016-08-24 三 11:05]--[2016-08-24 三 11:20] =>  0:15
      :END:      
      :PROPERTIES:
      :SUMMARY: 因为细粒度更高的.u操作
      :SOURCE:  Delete more than one word
      :OPERATE: 2dw  d2w  dw.
      :END:
      - d  删除命令
      - w  单词
***** 必要时使用次数                                                            :cw:c3w:
      :PROPERTIES:
      :SUMMARY: 同时需要删除修改
      :SOURCE:  I have a couple of questions
      :OPERATE: c3wsome more<Esc>
      :END:
      - cw 删除
***** 双剑合璧 天下无敌 combine and conquer                                     :操作符:动作命令:操作符等待模式:
      :PROPERTIES:
      :SUMMARY: 操作符＋动作命令＝操作
      :OPERATE: dl daw dap  g- gu gU  guaw
      :END:
      -    操作符(Operator)           ＋          动作命令(Motion)            ＝             操作(Action)
        | trigger | effect                |   | trigger   | effect             |   | trigger        | effect |
        |---------+-----------------------+---+-----------+--------------------+---+----------------+--------|
        | c       | change                |   | l         | a single character |   | dl d2l         |        |
        | d       | delete                |   | w aw iw   | a complete word    |   | dw d2w daw diw |        |
        | y       | yank into register    |   | s as is ) | a sentence         |   | dd 2dd         |        |
        | g~      | swap case             |   | p ap ip } | a entire paragraph |   |                |        |
        | gu      | make lowercase        |   |           |                    |   |                |        |
        | gU      | make uppercase        |   |           |                    |   |                |        |
        | >       | shift right           |   |           |                    |   |                |        |
        | <       | shift left            |   |           |                    |   |                |        |
        | =       | autoindent            |   |           |                    |   |                |        |
        | !       | Filter {motion} lines |   |           |                    |   |                |        |

             独立操作符(single Operator)
        | trigger | effect                                                 |
        |---------+--------------------------------------------------------|
        | x       | delete single character                                |
        | r       | replace (insert mode)                                  |
        | J       | cut the next line and paste to the end of current line |

      - 一个操作符被连续调用两次 他会作用当前行
        + dd  删除当千行
        + >>  缩进当前行
        + gUgU gUU  当前行第一个单词大写
      - 操作符等待模式 Operator-Pending Mode
        + 在操作符 与 命令符之间 存在一种模式
        + 在按操作符时 这种模式会等待以激活命令符
        + 同时 按下操作符时 可以按<Esc>取消
      - 操作符 (Operator) [[:h operator]]
      | 操作符 | 用途         |
      |--------+--------------|
      | c      | 修改         |
      | d      | 删除         |
      | y      | 复制到寄存器 |
      | g~     | 反转大小写   |
      | gu     | 转换为小写   |
      | gU     | 转换为大写   |
      | >      | 增加缩进     |
      | <      | 减少缩进     |
      | =      | 自动缩进     |
      - 动作命令 (Motion)
***** 扩展命令组合的威力
      :PROPERTIES:
      :SUMMARY: 自定义操作符 自定义动作命令
      :OPERATE: ae \\
      :END:
      - 自定义操作符
        - [[:h :map-operator]]
        - [[https://github.com/tpope/vim-commentary][vim-commentary]]
           - \\ap  切换但前段落注释状态
           - \\G  从当前行到文件结尾所有内容注释
           - \\\  注释当前行
      - 自定义动作命令
        - [[:h omap-info]]
        - [[https://github.com/kana/vim-textobj-entire][vim-textobj-entire]]
          - =ae  缩进整个文件 功能等同于 gg=G
      - 自定义操作符 ＋ 自定义动作命令
        - \\ae  注释整个文件
**** 插入模式 Insert Mode
     :PROPERTIES:
     :SOURCE:      insert_mode
     :END:
***** 插入模式及时更正错误 make corrections instantly from insert mode                   :<c-h>:<c-w>:<c-u>:
      :PROPERTIES:
      :SUMMARY: 插入模式文本出错 退格键删除错误文本 再输入正确内容
      :OPERATE: <C-h> <C-w> <C-u>
      :END:
      - 插入模式中文本出错 直接使用退格键删除文本
        - 避免切换模式造成的时间浪费
        - 今后再次输入对错误的文本有意识的提高警觉
      - 插入模式组合键删除字符
        | 组合键 | 用途           |
        |--------+----------------|
        | <C-h>  | 删除前一个字符 |
        | <C-w>  | 删除前一个单词 |
        | <C-u>  | 删至行首       |
***** 返回普通模式 get back to normal mode                                              :<Esc><C-[>:<C-o>zz:
      :PROPERTIES:
      :SUMMARY: 经典方式是<Esc> 巧妙方式利用插入-普通模式<C-o>
      :OPERATE: <Esc> <C-o>
      :END:
      - 切换回普通模式 :h i_CTRL-[ [[内置链接1]]
        | 按键  | 用途                |
        |-------+---------------------|
        | <Esc> | 切换到普通模式      |
        | <C-[> | 切换到普通模式      |
        | <C-o> | 切换到插入-普通模式 |
        - 插入-普通模式  在插入模式中直接执行普通模式命令 [[:h i_CTRL-O]]
          - <C-o>zz
            - zz  重绘屏幕 当前显示在屏幕正中
          - 执行完zz后返回插入模式
***** 不离开插入模式 粘贴寄存器中的文本 paste from a Register without leaving insert mode  :<C-r>{register}:
      :PROPERTIES:
      :SUMMARY: 映射<capslock>为<ctrl>
      :SOURCE:  practical-vim.txt
      :OPERATE: <C-h> <C-w> <C-u>
      :END:
      - 映射<capslock>为<ctrl>  用<ctrl-[>代替<Esc>
      - yt,  将,之前的字符放入寄存器
        - t{char}  动作命令
      - jA␣
        - j  下一行
        - A  行末
      - <C-r>0  将刚才复制的寄存器粘贴到光标位置 [[:h i_CTRL-R]]
      - <C-r>{register}  插入寄存器文本 <<技巧15>>
      - <C-r><C-p>{register}  按愿义插入文本 [[:h i_CTRL-R_CTRL-P]]
***** 随时随地做运算 do back-of-the-envelope caculations in place                       :<C-r>=:
      :PROPERTIES:
      :SUMMARY: 插入模式下在寄存器中做运算并返回结果 <<带表达式的运算>>
      :SOURCE:  back-of-envelope.txt
      :OPERATE: 1 A -> 2 <C-r>=6*35<CR>
      :END:
      6 chairs, each costing $35, totals $
                                          ^ 1 2

      - <C-r>=  表明使用表达式寄存器 <<技巧16>> <<practise 16>>
***** 用字符编码插入非常用字符 insert unusual characters by character code                :<C-v>:
      :PROPERTIES:
      :SUMMARY: 用字符编码(Unicode)插入任意字符
      :OPERATE: <C-v>{code}  其中{code}代表字符编码
      :END:
      - 插入非常用字符 <<:h i_CTRL-V_digit>>
        | 按键                | 用途                                 |
        |---------------------+--------------------------------------|
        | <C-v>{123} [fn:例1]   | 以十进制插入字符                     |
        | <C-v>u{1234} [fn:例2] | 以十六进制插入字符                   |
        | <C-v>{nondigit}     | 按原义插入非数字字符                 |
        | <C-k>{char1}{char2} | 插入二合字母{char1}{char2}表示的字符 |
      - 想知道 文档中 任意字符的编码
        - 将光标移到它上面 按 ga <<:h ga>>
      - 想知道 所有字符 的编码
        - 查 unicode表
[fn:例1] 插入A  <C-v>065
[fn:例2] 插入¿  <C-v>u00bf
***** 用二合字母插入非常用字符 insert unusual characters by digraph                       :<C-k>:
      :PROPERTIES:
      :SUMMARY:     用两个字母 代替字符编码 插入非常用字符
      :OPERATE:     <C-k>{char1}{char2} [fn:例1]
      :END:
      - 缺省二合字母集依从一定的规律 <<:h digraphs-default>>
      - 可用二合字符列表 <<:h digraph-table>>
[fn:例1] 非常用字符¿  <C-k>?I
***** 用替换模式替换已有文本 overwrite existing text with replace mode          :R:gR:
      :PROPERTIES:
      :SUMMARY:     输入字符替换已有文本
      :SOURCE:      replace.txt
      :OPERATE:     f. -> R,␣b<Esc>
      :END:      
      - R  进入替换模式 输入的字符都会与当前的文本进行替换
      - gR  虚拟替换模式 按照屏幕上实际显示的宽度来替换字符 [fn:例]
      - 单次版本的替换模式及虚拟替换模式 r{char} gr{char} <<:h r>>
[fn:例]
| 模式 | 替换文本         | 替换效果             |
|------+------------------+----------------------|
| R    | <TAB>(占8个空格) | 输入一个空格即可替换 |
| gR   | <TAB>(占8个空格) | 输入8个空格才可替换  |

**** 可视模式 Visual mode
     :Properties:
     :SUMMARY:    [[激活]] [[切换]] [[高亮选中复杂区域]] 一些按键命令与普通模式不同的另一种模式
     :SOURCE:     visual_mode
     :END:
***** 选择高亮选区 define a visual selection                                    :v:b:o:e:
      :PROPERTIES:
      :SUMMARY:    介绍可视模式3个子模式 以及<<高亮选中复杂区域>>
      :SOURCE:     Select from here to here
      :OPERATE:    1 vbb -> 2 o -> 3 e
      :END:
      Select from here to here
                          ^ 1
                  here to h 2      <-  <<切换光标方向>>
                  here to here 3   ->
      - <<激活>>
        | 命令  | 用途                   |
        |-------+------------------------|
        | v     | 激活面向字符的可视模式 |
        | V     | 激活面向行的可是模式   |
        | <C-v> | 激活面向列快的可是模式 |
        | gv    | <<重选上次的高亮选取>> |
      - <<切换>>
        | 按键            | 用途                                           |
        |-----------------+------------------------------------------------|
        | <Esc> or <C-[>  | 回到普通模式                                   |
        | v or V or <C-v> | 切换到普通模式(在相应的模式下再次输入即可返回) |
        | v               | 切换面向字符的可视模式                         |
        | V               | 切换面向行的可视模式                           |
        | <C-v>           | 切换面向列快的可视模式                         |
        | o               | 切换高亮选区活动端 [[切换光标方向]]                     |
***** 重复执行面向行的可视命令 repeat line-wise visual commands                                  :V:>:
      :PROPERTIES:
      :SUMMARY:    介绍可视模式3个子模式
      :SOURCE:     fibonacci-malformed.py
      :OPERATE:    Vj -> >.
      :END:
      def fib(n):
        a, b = 0, 1
        while a < n:
      print a,
      a, b = b, a+b
      fib(42)
      - >  缩进指定空格数
      - <  取消所缩进的空格数目
      - :set shiftwidth=4 softtabstop=4 expandtab
        - 设定 tab 占据几个空格
***** 只要可能 最好用操作命令 而不是可视命令 prefer operators to visual command where possible :vit:guit:U:
      :PROPERTIES:
      :SUMMARY:    如果想使用.命令重复某些字符替换工作 最好远离可视模式 可视模式所擅长的是修改复杂结构的文本操作
      :SOURCE:     list-of-links.html
      :OPERATE:    <可视 vit -> U> <普通 guit -> j. -> j.>
      :END:
      - 转换链接文字为大写模式
        <a href="#">one</a>
        <a href="#">two</a>
        <a href="#">three</a>

      - U  所选的字符变为大写 <<:h v_U>>
      - gU{motion}  等同于可视模式下的 U <<:h gU>>
***** 用面向列块的可视模式编辑表格数据 edit tabular data with visual-block mode                   :<C-v>:V:r:
      :PROPERTIES:
      :SUMMARY:    用面向列块的可视模式把文本变成表格
      :SOURCE:     chapter-table.txt
      :OPERATE:    <C-v>3j -> x... -> gv -> r| -> yyp -> Vr-
      :END:
      - 使用竖线隔开两列文本
        Chapter        Page
                     ^
        Normal mode    15
        Insert mode    31
        Visual mode    44

        Chapter     | Page
        --------------------
        Normal mode | 15
        Insert mode | 31
        Visual mode | 44

      - <C-v>   进入列块模式
      - x       删除此列
      - gv      重选上次的高亮选区
      - r|      选中的区域用 | 进行替换
      - yyp     复制并粘贴上面一行
        - yy or Y  复制游标所在一整行
        - p        粘贴至游标下方
        - P        粘贴至游标上方
      - Vr-     用面向行的可视模式 字符－进行整行文本替换
***** 修改列文本 change columns of text                                                        :<C-v>c<Esc>:
      :PROPERTIES:
      :SUMMARY:    如何在面向列的可视模式下同时修改多行相同数据
      :SOURCE:     sprite.css
      :OPERATE:    <C-v>jje -> c -> components -> <Esc>
      :END:
      li.one   a{ background-image: url('/images/sprite.png'); }
                                          ^
                                          components
      li.two   a{ background-image: url('/images/sprite.png'); }
      li.three a{ background-image: url('/images/sprite.png'); }

      - c  所有选择区域消失 进入插入模式
***** 在长短不一的高亮块后添加文本 append after a ragged visual block                             :$:A:
      :PROPERTIES:
      :SUMMARY:    面向列的可视模式中 完成技巧2的功能
      :SOURCE:     the_vim_way/2_foo_bar.js
      :OPERATE:    <C-v>jj$ -> A; -> <Esc>
      :END:
      var foo = 1
                ^
      var bar = 'a'
      var foobar = foo + bar

      var foo = 1;
      var bar = 'a';
      var foobar = foo + bar;

      - $  选区扩大至行尾
      - A  添加内容(限可视模式)
        | 按键 | 可视模式模式                        | 普通模式约定                        |
        |------+-------------------------------------+-------------------------------------|
        | a    | [[技巧51]]                              | 切换到插入模式 将光标置于字符之后   |
        | i    | [[技巧51]]                              | 切换到插入模式 将光标置于字符之前   |
        | A    | 切换到插入模式 将光标置于当前行之后 | 切换到插入模式 将光标置于当前行之后 |
        | I    | 切换到插入模式 将光标置于当前行之前 | 切换到插入模式 将光标置于当前行之前 |
**** 命令行模式 command-line mode
     :Properties:
     :SUMMARY:    一些沿用至今的ex命令(ex为vi之父)
     :SOURCE:     ex_mode
     :END:
***** 结识vim命令行模式 meet vim's command line                                                 :
      :PROPERTIES:
      :SUMMARY:    [[基本概念]] [[惊叹的能力]]
      :SOURCE:     
      :OPERATE:    
      :END:
      - <<基本概念>>
        - :       切换到命令行模式
        - /       调出查找提示符
        - <C-r>=  访问表达式寄存器 [[技巧16]]
        - <Esc>   返回到普通模式
      - <<惊叹的能力>>          <<:h ex-cmd-index>>
        - :edit and :write    读写文件
        - :tabnew             创建新标签页
        - :split              分割窗口
        - :copy               快速复制一行
        - :normal             对范围内的行做相同修改 [[技巧30]]
        - :delete :yank :put  [[第十章]]
        - :substitude :global [[第十五章]]
        - <C-w> <C-u> <C-v> <C-k>  插入模式通用的特殊按键
          - <C-w>  删除至上个单词的开头
          - <C-u>  删除至行首
          - <C-v>  <C-k>  插入特殊字符
          - <C-r>{register}  [[技巧15]]
        - 编辑文本的ex命令
          - [[file:~/desktop/操作缓冲区的ex命令.png]]
        - 在一行或者多行上执行命令
          - [[打印]] [[复制和移动]] [[避免重复的.命令]]
***** 在一行或者多个连续行上执行命令 execute command on one or more consecutive lines             :[range]p:
      :PROPERTIES:
      :SUMMARY:    介绍如何用ex命令<<打印>>
      :SOURCE:     practical-vim.html
      :OPERATE:    :1 :p :1p :2,5p :.,$p :%p :%s/a/b/ :/a/+1,/b/-1p :.,.+3p
      :END:      
      - 打印指定 行 / 范围行 / 行尾 / 偏移行 / 标签行
        <html>
          <head>
            <title>Practical Vim</title>
          </head>
          <body>
            <h1>Practical Vim</h1>
          </body>
        </html>

      - *:{address}*
        - :1p  打印第一行
          - :1  数字代表行 定位第一行行首
          - :p  打印当前区域
        - :%p  打印全部行
      - *:{address}+n*
        - :.,.+3p  打印当前行到下面3行
      - *:{start},{end}*
        - :2,5p  打印2到5行
        - :.,$p  打印当前行到末尾
      - *:{start}+n,{end}+n*
        - :/a/+1,/b/-1p  打印含有 a 字符的下面一行到含有 b 字符的上面一行
      - *:print :delete :join :substitude :normal*
        - :%s/a/b/  全文所有 a 替换成 b
      - 高亮选区指定范围
        - 2G -> VG -> : -> '<,'>p(预填充)

      - <<range>>
        | 符号 | 位置                    |
        |------+-------------------------|
        | 1    | 第一行                  |
        | $    | 最后一行                |
        | 0    | 虚拟行 位于第一行的上面 |
        | .    | 当前行                  |
        | 'm   | 标记的行                |
        | '<   | 高亮选取起始行          |
        | '>   | 高亮选区结束行          |
        | %    | 整个文件                |
***** 使用:t和:m复制和移动行 duplicate or move lines using ':t' and ':m' commands               :[range]t{address}:
      :PROPERTIES:
      :SUMMARY:    介绍如何用ex命令<<复制和移动>>
      :SOURCE:     shopping-list.todo
      :OPERATE:    <:6copy.(:6t.)> [[1]]   <Vjj -> :'<,'>m$> [[2]]
      :END:      
      - 复制指定行到指定地点
        Shopping list
            Hardware Store
                Buy new hammer
            Beauty Parlor
                Buy nail polish remover
                Buy nails

        (1)
        Shopping list
            Hardware Store
                Buy nails
                *Buy new hammer*
            Beauty Parlor
                Buy nail polish remover
                Buy nails

      - :[range]copy{address} <<1>>
        - :6copy. (:6t.)  <<:h :copy>>
          - [range]    第6行
          - {address}  . 代表当前行
          - 意思是复制第6行到当前行的下面
          | command  | effect                                                    |
          |----------+-----------------------------------------------------------|
          | :t6.     | Copy line 6 to just below the current line                |
          | :t6      | Copy the current line to just below line 6                |
          | :t.      | Duplicate the current line (similar to Normal mode yyp)   |
          | :t$      | Copy the current line to the end of the file <<:t>>       |
          | :'<,'>t0 | Copy the visually selected lines to the start of the file |
      - :[range]move{address} <<2>>
        - [rnage]    '<,'>当前高亮选区
        - {address}  $文本末尾
***** 在指定范围内执行普通模式 run normal mode commands across a range                           :'<:'>normal .:
      :PROPERTIES:
      :SUMMARY:    用 :normal 命令多行同时执行 . 命令 <<技巧30>>
      :SOURCE:     foobar.js
      :OPERATE:    A;<Esc> -> jVG -> :'<,'>normal .
      :END:
      - 为每一行行尾添加;
        var foo = 1
        var bar = 'a'
        var baz = 'z'
        var foobar = foo + bar
        var foobarbaz = foo + bar + baz

        var foo = 1;
        var bar = 'a';
        var baz = 'z';
        var foobar = foo + bar;
        var foobarbaz = foo + bar + baz;

      - jVG  用面向行的可视模式选中高亮区域
      -  :'<,'>normal .  再由ex命令在高亮选区范围内执行普通模式的 . 命令
         - :normal       在 ex 命令行中执行普通模式命令
      - 在每一行上执行相同的普通模式命令 <<避免重复的.命令>>
        - :%normal A;    每一行的末尾添加;号  [[用可视模式的另一种解决方案]]
        - :%normal i//   每一行都注释掉
***** 重复上次的ex命令 repeat the last ex command  [[重复ex命令]]
***** 自动补全ex命令 tab-complete your ex commands                                             :<TAB>:
      :PROPERTIES:
      :SUMMARY:    如何在补全 ex 命令  启用补全导航列表
      :END:
      - :cmd<C-d>  <<:h c_CTRL-D>>
        - <C-d>  显示可用的补全列表 多次按<TAB>效果相同
      - <TAB>  输入部分命令进行自动补全  <<:h :command-complete>>
      - 多个补全项间选择 缺省状态下<TAB>存在多个补全项 只会匹配第一个 往后每按一次匹配后面一个
        - wildmode  采用自定义补全行为  <<:h 'wildmode'>> <<vimrc相关配置1>>
          | 正向遍历 | <TAB> <C-n> <right>  |
          | 反向遍历 | <S-TAB> <C-p> <left> |
          - bash  采用bash补全
            - set wildmode=longest,list
          - zsh  采用zsh补全
            - set wildmenu
            - set wildmode=full
***** 把当前单词插入到命令行 insert the current word at the command prompt                       :<C-r><C-w>:
      :PROPERTIES:
      :SUMMARY:    <C-r><C-w>把当前光标下的单词插入到 ex 命令行中
      :SOURCE:     loop.js
      :OPERATE:    * -> :%s//<C-r><C-w>/g
      :END:
      - 把指定字符放入寄存器 替换模式进行替换
        var tally;
        for (tally=1; tally <= 10; tally++) {
          // do something with tally
        };

        var tally;
        for (counter=1; tally <= 10; tally++) {
             ^
          // do something with tally
        };

      - *  匹配当前光标下的单词 并跳到下一处匹配项
        - 等效于 /\<C-r><C-w>\><CR>  [[关于\<和\>在模式中的作用]]
      - :%s//<C-r><C-w>/g
         - :%S  整个文本进行:substitute替换
         - //  [[为什么可以将查找域留空]]  要感谢 * 命令
         - <C-r> <C-w>  把光标下的文字插入到ex命令行
***** 回溯历史命令 recall command from history                                                 :q:<C-f>:
      :PROPERTIES:
      :SUMMARY:    用<up><down> <C-n><C-p>对历史记录进行操作  [[使用q;对命令行进行编辑]]
      :SOURCE:     loop.js
      :OPERATE:    q:
      :END:
      - [[提高历史记录上限]]
      *- 命令行窗口*
        - <<使用q;对命令行进行编辑>>  例 [[file:~/desktop/命令行窗口.png]]
        - 编辑 ex 历史记录 k j <up> <down> 进行上下移动    <<重复ex命令>>
        | 命令 | 动作 |
        |------+------|
        | q/   |  打开查找命令的命令行窗口 |
        | q:   |   打开ex命令行窗口 |
        | <C-f> |   从命令行模式切换到命令行窗口 | [fn:注]
        [[命令行窗口的另一个应用实例]]
[fn:注] 在编写ex命令行模式时突然发现需要更为强大的命令行窗口
        这时就需要<C-f>将原先命令行模式的内容映射到命令行窗口中
***** 运行SHELL命令 run commands in the shell                                                 :[range][!]cmd:
      :PROPERTIES:
      :SUMMARY:    在 vim 中与 shell 交互
      :SOURCE:     emails.csv
      :OPERATE:    :2,$!sort -t',' -k2
      :END:
      | 命令                 | 用途                                              |
      |----------------------+---------------------------------------------------|
      | :shell               | 启动一个shell(输入exit返回vim)                    |    [[在shell中挂起 唤回vim]]
      | :!{cmd}              | 在shell中执行{cmd}                                |   [fn:单次执行]
      | :read !{cmd}         | 在shell中执行{cmd} 并把标准输出插入到光标下面     |       [fn:shell结果返回vim]
      | :[range]write !{cmd} | 在shell中执行{cmd} 以[range]作为其标准输入        |     [fn:vim结果返回shell]
      | :[range]!{filter}    | 使用外部程序{filter} 过滤指定的[range]            |     [[例]]
      - :2,$!sort -t',' -k2 <<例>>
        - 2,$               [range] 2到最后一行
        - sort -t',' -k2
          - sort            排序
            - t','          参数以逗号分割
            - k2            以第二个字段进行排序
      - <<在shell中挂起 唤回vim>>
        - <C-z>    挂起
        - fg       唤回
        - $jobs    当前作业列表

[fn:单次执行]  执行一行命令后返回vim
[fn:shell结果返回vim]  将!{cmd}执行结果 返回到vim当前光标下
[fn:vim结果返回shell]  将[range]内容标准输入到shell中
                      注 <:write !sh>  [range]为缓冲区内容  而 <:write! sh> 为将内容输出到一个名字为sh的文件中
***** Run Multiple Ex Commands as a Batch                                       :source:args:argdo:
      :PROPERTIES:
      :SUMMARY:    [[use vim script in a file]]  [[use vim script in a folder]]
      :SOURCE:     emails.csv
      :OPERATE:    [[Write Ex Commands to a Script and Source It]]
      :END:
      - modify this into a plain-text format showing the title followed by the URL
        <ol>
          <li>
            <a href="/episodes/show-invisibles/">
              Show invisibles
            </a>
          </li>
          <li>
            <a href="/episodes/tabs-and-spaces/">
              Tabs and Spaces
            </a>
          </li>
        </ol>

        (1)
        Show invisibles: http://vimcasts.org/episodes/show-invisibles/
        Tabs and Spaces: http://vimcasts.org/episodes/tabs-and-spaces/

        - Run Ex Commands One by One (1)
          :g/href/j
          :v/href/d
          *:%norm A: http://vimcasts.org*
          :%norm yi"$p
          :%s/\v^[^\>]+\>\s//g

        - <<Write Ex Commands to a Script and Source It>>
          - <<use vim script in a file>>
            $ vim vimcasts/episodes-1.html
            :source [[batch.vim]]
          - <<use vim script in a folder>>
                        $ vim vimcasts/*.html
            [[:args]]                 [[:argdo]] source [[batch.vim]]
            :first
            :source [[batch.vim]]
            :next
            :source [[batch.vim]]
          - <<batch.vim>>
            global/href/join
            vglobal/href/delete
            %normal A: http://vimcasts.org
            %normal yi"$p
            %substitute/\v^[^\>]+\>\s//g
*** 文件 Files
**** 管理多个文件 manage mutiple files
     :PROPERTIES:
     :SUMMARY: vim允许我们在多个文件上同时工作
     :SOURCE:  files
     :END:
***** 用缓冲区列表管理打开的文件 track open files with the buffer list                     :vim:bn[ext]:bp[rev]:bd[elete]:
      :PROPERTIES:
      :SUMMARY:    vim缓冲区可以对多个文件同时进行管理
      :SOURCE:     
      :OPERATE:    $ cd code/files -> $ vim *.txt -> :ls -> :bnext -> :ls
      :END:
      - 缓冲区列表基本操作
        - $ cd code/files       进入 files 文件夹
        - $ vim *.tx            编辑所有的 txt 文件
        - :ls                   显示所有被载入内存的缓冲区列表
          - %                   当前窗口处在哪个缓冲区
          - #                   代表可轮换文件  用 <C-^> 快速进行切换
        - :bnext(:bn)   :bprev(:bp)       在列表中正向反向移动    [[创建快速遍历VIM列表的按键映射项]]
          - :bfirst   :blast    跳转到列表开头和结尾
          *- :buffer N           直接跳转到指定列表 N代表列表开头数字编号*
          - :buffer {buffername}   输入唯一标识缓冲区的字符 如匹配不止一项 TAB 切换
        - :bufdo                允许我们在所有缓冲区列表中执行 ex 命令
        - :bdelete(:bd)         删除缓冲区
          - :bdelete 5 6 7 9
          - :5,9 bdelete
      - <<创建快速遍历VIM列表的按键映射项>>    [[https://github.com/tpope/vim-unimpaired][链接]]
        - nnoremap <silent> [b :bprevious<CR>
        - nnoremap <silent> ]b :bnext<CR>
        - nnoremap <silent> [B :bfirst<CR>
        - nnoremap <silent> ]B :blast<CR>
      - [[参数列表]] 缓冲区列表的强力补充
***** 用参数列表将缓冲区分组 group buffers into a collection with the argument list :args:
      :PROPERTIES:
      :SUMMARY:    vim缓冲区可以对多个文件同时进行管理
      :SOURCE:     letters      mvc                  .chapters
      :OPERATE:    [[执行参数列表]]  [[填充参数列表(glob模式)]]  [[用反引号指定文件]]
      :END:
      - <<参数列表>>
        - <<执行参数列表>>
          - $ cd code/files/letters -> $ vim *.txt -> :args
            - :args  输出比较简陋 原本是vi的一个功能
        - <<填充参数列表(glob模式)>>
          - $ cd code/files/mvc -> $ vim -> :args index.html app.js -> :args
            - :args {arglist}             {arglist}可以包括文件名 [[通配符]] 甚至一条shell语句 默认执行ls    <<:args>>
              - glob模式指定文件 <<通配符>>   例:[[file:~/desktop/glob模式.png]]
                - *      匹配0个或多个字符 范围仅限于指定目录
                - **     匹配0个或多个字符 范围可以递归进入指定目录的子目录
        - <<用反引号指定文件>>
          - :args `cat .chapters`     反引号内可以是任意shell命令 仅限于unix-like系统
        - :next :prev
***** 管理隐藏缓冲区 manage hidden files                                                 :w[rite]:e[dit]:q[uit]:
      :PROPERTIES:
      :SUMMARY:    vim缓冲区可以对多个文件同时进行管理
      :SOURCE:     
      :OPERATE:    [[修改缓冲区列表文件]] -> [[在缓冲区中切换文件]] -> [[退出时处理缓冲区]]
      :END:
      - <<修改缓冲区列表文件>>
        - $ cd code/files -> $ ls -> $ vim *.txt -> 对 a.txt 执行 Go -> :ls
          - Go     在缓冲区尾部增加一行
          - :ls    这时 a.txt 前面显示 + 表示已经被修改过了
            | 1  %a + "a.txt"   line1 |
            |-------------------------|
            | 2       "b.txt"   line0 |
      - <<在缓冲区中切换文件>>
        - :bnext -> :bnext! -> :ls
          - :bnext!     !强制切换缓冲区 将未保存的缓冲区置为隐藏
          - :ls         a 表示当前活动缓冲区  h表示它是一个隐藏缓冲区
            | 1 #h + "a.txt" line 1 |
            |-----------------------|
            | 2 %a   "b.txt" line 1 |
      - <<退出时处理缓冲区>>
        - :q[uit] -> :w[rite] or :e[dit]! -> :q[uit]
          - 退出时处理隐藏缓冲区的方法
            | 命令     | 用途                      |
            |----------+---------------------------|
            | :w[rite] | 把缓冲区写入磁盘          |
            | :e[dit]  | 把磁盘内容读入缓冲区      |
            | :qa[ll]  | 关闭所有窗口 摒弃所有修改 |
            | :wa[ll]  | 把所有修改写入缓冲区      |
       - hidden选项     不需要! 离开缓冲区自动将其隐藏

***** 将工作区切分成窗口 divide your workspace into split windows                         :<C-w>:
      :PROPERTIES:
      :SUMMARY:    vim窗口管理
      :SOURCE:     
      :OPERATE:    [[分割窗口]] -> [[窗口切换]] -> [[关闭窗口]] -> [[重排窗口]]
      :END:
      - <<分割窗口>>
        |                | 水平分割窗口    | 垂直分割窗口     |
        |----------------+-----------------+------------------|
        | 显示当前缓冲区 | <C-w>s          | <C-w>v           |
        | 载入{file}     | :sp[lit] {file} | :vsp[lit] {file} |
      - <<窗口切换>>
        |------------+------+-------+---+-------|
        |            |      | up    |   |       |
        |            |      | k     |   |       |
        | left       | h    | <C-w> | l | right |
        |            |      | j     |   |       |
        |            |      | down  |   |       |
        |            |      |       |   |       |
        | <C-w><C-w> | loop |       |   |       |
      - <<关闭窗口>>
        | 功能           | 普通模式命令与之等效的ex命令 |
        |----------------+------------------------------|
        | 关闭活动窗口   | <C-w>c  :clo[se]             |
        | 只保留当前窗口 | <C-w>o  :on[ly]              |
      - <<重排窗口>>
        | 命令      | 用途          |
        |-----------+---------------|
        | <C-w>=    | 等宽 等高     |
        | <C-w>_    | 最大化高度    |
        | <C-w>|     | 最大化宽度    |
        | [N]<C-w>_ | 高度设为[N]行 |
        | [N]<C-w>|  | 宽度设为[N]列 |
***** 用标签页将窗口分组 organize your window layouts with tab page             :tab:
      :PROPERTIES:
      :SUMMARY:    标签页(工作区)的管理
      :SOURCE:     
      :OPERATE:    [[如何使用]] -> [[打开及关闭]] －> [[切换]]
      :END:
      - <<如何使用>>
        |            | 设置工作目录      |
        |------------+-------------------|
        | 当前窗口   | :lcd {path}       |
        | 当前标签页 | :windo lcd {path} |
      - <<打开及关闭>>
        | 命令                  | 用途                          |
        |-----------------------+-------------------------------|
        | :tabe[dit] {filename} | 打开 新标签页 {filename}      |
        | <C-w>T                | 移到 新标签页                 |
        | :tabc[lose]           | 关闭 当前标签页(下面所有窗口) |
        | :tabo[nly]            | 只保留当前标签页 关闭其他     |
      - <<切换>>
        | 用途            | 普通模式命令与之等效的ex命令 |
        |-----------------+------------------------------|
        | 切换到{N}标签页 | {N}gt  :tabn[ext] {N}        |
        | 下一标签页      | gt  :tabn[ext]               |
        | 上一标签页      | gT  :tabp[revious]           |
**** 打开及保存文件 open files and save them to disk
***** 用:edit打开文件 open a file by its filepath using ':edit'                          :edit {relative path}:
      :PROPERTIES:
      :SUMMARY:    指定 工作目录 方式 打开文件
      :SOURCE:     
      :OPERATE:    [[相对于当前目录打开文件]] [[相对于活动目录打开文件]] [[优化]]
      :END:
      - <<相对于当前目录打开文件>>
        - $ cd code/files/mvc -> $ vim index.html -> :pwd -> :edit lib/framework.js -> :edit app/controllers/Navigation.js
          - :pwd              打印工作目录
          - *:edit {file}*      基于工作目录 相对路径 打开文件
      - <<相对于活动目录打开文件>>
        - :edit %<Tab> -> :edit %:h<Tab> -> :edit app/controllers/ -> :edit %:h<Tab>M<Tab>
          - %<TAB>          显示 当前缓冲区 的 完整路径
          - %:h<TAB>        显示 当前文件 所在目录 的 路径
          - <TAB>           自动查找目录下的文件(自动补全文件名)
      - <<优化>>
        - [[:edit%20%E5%B1%95%E5%BC%80%E5%BD%93%E5%89%8D%E6%96%87%E4%BB%B6%E6%89%80%E5%9C%A8%E7%9B%AE%E5%BD%95%20vimrc%20%E9%85%8D%E7%BD%AE][:edit 展开当前文件所在目录 vimrc 配置]]
***** 使用:find打开文件 open a file by its filename using ':find'                        :find {specific path}:
      :PROPERTIES:
      :SUMMARY:    指定 多个工作目录 输入文件名 匹配完整目录
      :SOURCE:     
      :OPERATE:    [[进入工程目录]] -> [[配置 path 选项]] -> [[通过文件名查找文件]]
      :END:
      - <<进入工程目录>>
        - $ cd code/files/mvc -> $ vim index.html
      - <<配置 path 选项>>
        - :set path+=app/**
          - app/**                 匹配 app 目录下面所有子目录
      - <<通过文件名查找文件>>
        - :find Navigation.js      精确匹配(只存在一个匹配项)
        - :find Main.js<Tab>       循环匹配(存在多个匹配项)
        - 以上都可以通过<TAB>自动补全 例 :find nav<Tab>
***** 使用netrw管理文件系统 explore the file system with netrw
      :PROPERTIES:
      :SUMMARY:    原生的文件管理器
      :SOURCE:     
      :OPERATE:    [[%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%99%A8][文件管理器]]  [[网络读写文件]]
      :END:
      - 加载 netrw 插件  (可省略)
        - [[加载 VIM 发行版中自带的标配插件]]
      - <<文件管理器>>
        - $ cd code/file/mvc
          - $ vim .              直接以根目录形式打开 vim
          - $ vim index.html     打开根目录下任意文件 在缓冲区中显示根目录
            - :e[dit] .
            - :E[xplore]         netrw 命令
        - k j                    上下移动
        - <CR>                   进入指定缓冲区
      - <<网络读写文件>>
***** 把文件保存到不存在的目录 save files to nonexistent directories                       :edit {nonexistent path}:mkdir:
      :PROPERTIES:
      :SUMMARY:    :edit 命令打开一个不存在的文件路径 并进行保存
      :SOURCE:     
      :OPERATE:    :edit madeup/dir/doesnotexist.yet -> :!mkdir -p %:h -> :write
      :END:
      - :edit madeup/dir/doesnotexist.yet  编辑不存在的新文件
        - <C-g>      该文件被创建为新缓冲区
        - :write     此时如果写入文件会报错
          -  "madeup/dir/doesnotexist.yet" E212: Can't open file for writing   不存在该文件路径
      - :!mkdir -p %:h      外部的 mkdir 进行文件目录创建
        - p                 创建任何不存在的中间目录
        - %:h               当前目录
***** 以超级用户权限保存文件 save a file as the super user
      :PROPERTIES:
      :SUMMARY:    以 root 身份 保存系统文件
      :SOURCE:     
      :OPERATE:    $ ls -al /etc/ | grep hosts -> $ vim /etc/hosts -> :w !sudo tee % > /dev/null
      :END:
      - $ ls -al /etc/ | grep host          打开 etc 下的系统文件
        - $ whoami                        显示当前文件夹拥有着 (root)
      - $ vim /etc/host                   对 hosts 文件进行编辑
        - :write                          'readonly' option is set (add ! to override)      写入文件     只读出错
        - :write!                         "/etc/hosts" E212: Can't open file for writing    强制写入     没有权限
      - :w !sudo tee % > /dev/null        以 root 身份保存文件
        - !sudo                           root 身份进行操作 (需要输入密码)
        - tee % > /dev/null
          - tee                           标准输入读取数据 将其内容输出到标准输出设备 同时保存成文件
          - %                             当前目录 (etc/hosts)
          - > /dev/null                   将标准输出内容丢弃到 /dev/null
*** 更快的移动及跳转 getting around faster
    :PROPERTIES:
    :SUMMARY:      vim 动作命令 移动光标 配合操作符待决模式
    :SOURCE:       motions
    :END:
**** 用动作命令在文档中移动 navigate inside files with motions
     :PROPERTIES:
     :SUMMARY:     motion 动作命令
     :SOURCE:  
     :END:
***** 让手指保持在本位行上 keep your fingers on the home row                    :hjkl:
      :PROPERTIES:
      :SUMMARY:    [[本位行]]  [[h j k l]]  [[戒掉用光标键的习惯]]
      :SOURCE:     
      :OPERATE:    
      :END:
      - <<本位行>>
        - 左手停留在      a s d f
        - 右手停留在      j k l ;
      - <<h j k l>>
        | 命令 | 光标动作                                                 |
        |------+----------------------------------------------------------|
        | h    | 左移 (只在距离差一两个字符时使用) [fn:off-by-one-errors] |
        | j    | 下移                                                     |
        | k    | 上移                                                     |
        | l    | 右移 (只在距离差一两个字符时使用) [fn:off-by-one-errors] |
      - <<戒掉用光标键的习惯>>
        - [[禁用光标键映射]]
[fn:off-by-one-errors]  差一错误    通常是指对于边界判断错误 导致多循环或少循环一次
***** 区分实际行和屏幕行 distinguish between real lines and display lines       :[g]:j:k:0:^:$:
      :PROPERTIES:
      :SUMMARY:    [[%E5%AE%9E%E9%99%85%E8%A1%8C%E4%B8%8E%E5%B1%8F%E5%B9%95%E8%A1%8C][实际行与屏幕行]]  [[%E5%AE%9E%E9%99%85%E8%A1%8C%E4%B8%8E%E5%B1%8F%E5%B9%95%E8%A1%8C%E4%BD%8D%E7%A7%BB%E6%93%8D%E4%BD%9C][实际行与屏幕行位移操作]]  [[%E4%BA%A4%E6%8D%A2%E5%AE%9E%E9%99%85%E8%A1%8C%E4%B8%8E%E5%B1%8F%E5%B9%95%E8%A1%8C%E7%9A%84%E4%BD%8D%E7%A7%BB%E6%93%8D%E4%BD%9C][交换实际行与屏幕行的位移操作]]
      :SOURCE:     
      :OPERATE:    
      :END:
      - <<实际行与屏幕行>>
        - 实际行    文本所在实际的行数
        - 屏幕行    超出窗口宽度 回绕显示在屏幕上的行数
      - <<实际行与屏幕行位移操作>>
        | 实际行命令 | 屏幕行命令 | 光标动作       |
        |------------+------------+----------------|
        | j          | gj         | 上移           |
        | k          | gk         | 下移           |
        | 0          | g0         | 行首           |
        | ^          | g^         | 第一个非空字符 |
        | $          | g$         | 行尾           |
      - <<交换实际行与屏幕行的位移操作>> (不建议进行此项配置)
        - [[重新映射面向行的动作命令]]
***** 基于单词移动 move word-wise                                              :b w:ge e:w W:
      :PROPERTIES:
      :SUMMARY:    [[单词跳转]]  [[字串跳转]]
      :SOURCE:     
      :OPERATE:    b w ge e W
      :END:
      - <<单词跳转>>
          b   b   w
        | <- |<-| -> |
        prev current next
           | <- |->| -> |
             ge  e   e
      - <<字串跳转>>
        e.g. we're going too slow
        | -> |                     wwww or  W
             |  -> |               www  or  W
            you're                 cwyou<Esc>
             it's                  cWit's<Esc>
***** 对字符进行查找 find by character                                         :<fF tT ;,>:
      :PROPERTIES:
      :SUMMARY:    [[字符查找]]  [[重复反转]]  [[出现频率]]
      :SOURCE:     
      :OPERATE:    f{char} F{char} t{char} T{char} ; ,
      :END:
      - <<字符查找>>
        f{char}      正向移动到下一个{char}所在之处    \
                                                        在普通模式下使用   \
        F{char}      反向移动到上一个{char}所在之处    /
                                                                                 <<普通模式与操作符等待模式>>
        t{char}      正向移动到下一个{char}所在之处的前一个字符上   \
                                                                   在操作符等待模式下使用   /
        T{char}      反向移动到上一个{char}所在之处的后一个字符上   /
      - <<重复反转>>
        Find the first occurrence of {char} and move
        |      fo      |                                 查找字符o
                       |           ;;            |       重复上次查找2次
                                  |       ,      |       撤销最近一次查找

        I've been expecting you, Mister Bond.
                               ^                         f,
        I've been expecting you.                         dt.
      - <<出现频率>>
        在使用字符查找命令时 最好选择 出现频率频率 比较低 的字母作 目标字符
***** 通过查找命令进行移动 search to navigate                                   :</ nN>:
      :PROPERTIES:
      :SUMMARY:    [[%E5%AD%97%E7%AC%A6%E5%8C%B9%E9%85%8D%E5%BD%A2%E5%BC%8F%E6%9F%A5%E6%89%BE][字符匹配形式查找]]  [[操作文本]]
      :SOURCE:     search-haiku.txt
      :OPERATE:    /{char}
      :END:
      - <<字符匹配形式查找>>
        search for your target it only takes a moment to get where you want
                        *ta*     [[n]]->     *ta*                                      /ta<CR>  多行 多个字符 匹配字符  \
                               <-[[N]]                                                                                <<各种查找命令之间的区别>>
                                                                               ft -> ;  单行 单个字符          /
                                       *tas*                                     /tas<CR>
        - <<n>>    匹配字符 正向跳转
        - <<N>>    匹配字符 反向跳转
      - <<操作文本>>
        This phrase takes time but eventually gets to the point
                    *takes time but eventually g*                   (1)
                    *takes time but eventually*                     (2)
                    +takes time but eventually+                     (3)
        - 可视模式
          v 进入可视模式 -> /ge<CR> (1) -> h (2) -> d (3)
        - 普通模式
          d/ge<CR> (1) (3)
***** 用精确的文本对象选择选区 trace your selection with precision text objects  :<cyd ai ">]t>:
      :PROPERTIES:
      :SUMMARY:    [[%E5%8F%AF%E8%A7%86%E6%A8%A1%E5%BC%8F%20%E6%96%87%E6%9C%AC%E5%AF%B9%E8%B1%A1%20%E6%93%8D%E4%BD%9C%E6%8B%AC%E5%8F%B7%20%E8%A2%AB%E5%BC%95%E7%94%A8%E6%96%87%E6%9C%AC%20XML%E6%A0%87%E7%AD%BE][可视模式 文本对象 操作括号 被引用文本 XML标签]]  [[操作等待模式下使用文本对象]]
      :SOURCE:     template.js
      :OPERATE:    v | i/a | }">t]        d/y/c | i/a | }">t
      :END:
      - <<文本对象操作括号 被引用文本 XML标签>>
        var tpl = [ '<a href="{url}">{title}</a>' ]
                                ^                     {start}
                               url                    vi}           可视模式 高亮选中 {}内部
                             "{url}"                  a"                    高亮选中 ""字符范围
                      a href="{url}"                  i>                    高亮选中 <>内部
                                    {title}           it                    高亮选中 xml标签内部
                     <a href="{url}">{title}</a>      at                    高亮选中 xml标签范围
                  [ '<a href="{url}">{title}</a>' ]   a]                    高亮选中 []字符范围
      - <<操作等待模式下使用文本对象>>
        var tpl = [ '<a href="{url}">{title}</a>' ]
                                ^                              {start}
                               {url} ->  *#*                     ci"#<Esc>           修改 ""内部 返回普通模式
                                     {title} ->  click here    citclick here<Esc>  修改 xml标签内部 返回普通模式
                                                               yit                 拷贝 xml标签内部
                                                               dit                 删除 xml标签内部
***** 删除周边 修改内部 delete around, or change inside                         :<dc ai wWsp>
      :PROPERTIES:
      :SUMMARY:    [[操作符与文本块文本对象]]
      :SOURCE:     
      :OPERATE:    i/a | w/W/s/p
      :END:
      - <<操作符与文本块文本对象>>
        Improve your writing by deleting excellent adjectives.
                                            ^                      {start}
                                         +excellent_+                daw               删除 单词 包括后面空格 (around the word)
                                                                                     d{motion} 与 aw as ap 配合使用
                                         +execlient+ -> most         ciwmost<Esc>      修改 单词 不包括后面空格 (inside the word)
                                                                                     c{motion} 与 iw is ip 配合使用
***** 设置位置标记 以便快速跳回 mark your place and snap back to it              :m:`:
      :PROPERTIES:
      :SUMMARY:    [[位置标记跳转]]  [[自动位置标记]]
      :SOURCE:     
      :OPERATE:    m{mark} `{mark}    `` `.
      :END:
      - <<位置标记与跳转>>
        m{a-z}            局部标记
        m{A-Z}            全局标记
        `{mark}           跳转
      - <<自动位置标记>>
        ``                   上次跳转之前的位置     [[跳转列表]]
        `.                   上次修改的地方        [[改变列表]]
        `<                   上次高亮选区起始位置   可视模式补充
        `>                   上次高亮选区结束位置   可视模式补充
***** 在匹配括号间跳转 junmp between matching parentheses                       :%:
      :PROPERTIES:
      :SUMMARY:    [[开、闭括号间跳转]]  [[选中文本添加分隔符 修改已有分隔符]]
      :SOURCE:     
      :OPERATE:    %
      :END:
      - <<开、闭括号间跳转>>
        console.log([{'a':1},{'b':2}])
                   ^                       {start}
                                     ^     %           在一组开、闭括号间跳转
                                    ^      h
                    ^                      %
                     ^                     l
                           ^               %
      - <<选中文本添加分隔符 修改已有分隔符>>  [[https://github.com/tpope/vim-surround][Surround.vim]]
        ities = ["London", "Berlin", New York]
                                     ^                 {start}
                                     New York          vee
                                    "New York"         S"
                                    {New York}         cs"}
**** 在文件间跳转 navigate between files with jumps
     :PROPERTIES:
     :SUMMARY:     跳转列表 改变列表
     :SOURCE:      jumps
     :END:
***** 遍历跳转列表 traverse the jump list                                       :<:junmps><C-o><C-i>:
      :PROPERTIES:
      :SUMMARY:    [[操作跳转列表]]  [[跳转动作]]
      :SOURCE:     
      :OPERATE:    :jumps  <C-o>  <C-i>
      :END:      
      - <<操作跳转列表>>
        显示   :jumps
        移动   <C-o>    <C-i>
               后退      前进
      - <<跳转动作>>       每一个动作都将生成跳转列表
        [count]G          指定行号
        %
        ( or )            上一句 / 下一句 开头
        { or }            上一段 / 下一段 开头
        gf                [[源码定位]]
        <C-[>             光标下 关键字 定义处 [[源码定位]]
        `{mark} or '{mark}
***** 遍历改变列表 traverse the change list                                     :<:changes g; g,>:
      :PROPERTIES:
      :SUMMARY:    [[操作改变列表]] 
      :SOURCE:     
      :OPERATE:    :changes  g;  g,
      :END:      
      - <<改变列表>>
        显示    :changes
        移动    g;     g,
               反向    正向
***** 跳转到光标下的文件 jump to the filename under the cursor
      :PROPERTIES:
      :SUMMARY:    
      :SOURCE:     practical_vim.rb
      :OPERATE:    gf
      :END:      
***** 用全局位置标记在文件间快速跳转 snap between files using global marks         :<mM `M>:
      :PROPERTIES:
      :SUMMARY:    [[全局跳转]]
      :SOURCE:     
      :OPERATE:    `{mark}
      :END:      
      - <<全局跳转>>
        `{mark}        全局标记
                       全局跳转

*** 寄存器 registers
    :PROPERTIES:
    :SUMMARY:      剪切版 剪切 复制 粘贴 录制宏
    :SOURCE:       
    :END:
**** 复制和粘贴 copy and paste
     :PROPERTIES:
     :SUMMARY:     删除 delete  复制 yank  粘贴 put
     :SOURCE:      copy_and_paste
     :END:
***** 用无名寄存器实现删除 复制 粘贴操作 delete, yank, and put with vim's unnamed register :xp:ddp:yyp:
      :PROPERTIES:
      :SUMMARY:    [[调换字符]] [[调换文本行]] [[创建文本行的副本]]
      :SOURCE:     
      :OPERATE:    
      :END:      
      - <<调换字符>>
        Practica lvim
                    ^     {start}
                ^         F␣  [[字符查找]]
                \/        xp  调换光标上的字符与后一个字符  --   x  剪切当前字符 放到无名寄存器
                                                        \    p  将无名寄存器中的内容粘贴到光标后面
      - <<调换文本行>>
        2) line two                   1) line one  \
        ^             {start}                        ddp 交换当前行与下一行  --  dd  剪切当前行 放入无名寄存器
        1) line one                   2) line two  /                      \    p   无名寄存器的内容粘贴到下一行
      - <<创建文本副本>>
        1) line one        1) line one
        2) line two        2) line two
        ^                  2) line two
                           ^             yyp 复制一个副本到下面一行
***** 深入理解vim寄存器 grok vim's registers                                             :"ayiw:"ap:
      :PROPERTIES:
      :SUMMARY:    [[引用寄存器]] [[vim术语对照表]] [[常用寄存器]]
      :SOURCE:     
      :OPERATE:    
      :END:
      - <<引用寄存器>> addressing a register
        "{[[register name]]} 常用寄存器名
      - <<vim术语对照表>>
        [d]elete -> cut   [y]ank -> copy   [p]ut -> paste
                剪切             复制            粘贴
      - <<常用寄存器>>
        |                         |                   | collection = getCollection();   process(somethingInTheWay, target); |                 |
        | register                | <<register name>> | ^ 1                                     ^ 2 3                       | properties      |
        |-------------------------+-------------------+---------------------------------------------------------------------+-----------------|
        | the unamaed register    | "                 | yiw (collection) -> diw (somthingInTheWay) -> P (somethingInTheWay) | [[defaultRegister]] |
        | the yank register       | 0                 | yiw (collection) -> diw (collection) -> "0P (collection)            | [[copyRegister]]    |
        | the named register      | a-z               | "ayiw (collection) -> diw (collection) -> "aP (collection)          | [[26Registers]]     |
        | the black hole register | _                 | yiw -> "_diw -> P (collection)                                      | [[nonRegister]]     |
        | the system clipboard    | +                 |                                                                     | [[systemClipboard]] |
        | selection register      | *                 |                                                                     | [[systemClipboard]] |
        | the expression register | =                 |                                                                     | [[practise 16]]   |

<<defaultRegister>> 寄存器名默认为空 即 “”p = p  *if we don't specified which register we want to interact with, then vim will use the unnamed register*
<<copyRegister>> 复制专用寄存器 即只寄存和yank相关的操作  *the specified text is copied not only into the unnamed register but also into the yank register*
<<26Registers>> 26个字母对应26个寄存器 可供使用  *wim has one named register for each letter of the alphabet*
<<nonRegister>> 不寄存任何字符  *is a place from which nothing return*
<<systemClipboard>> 系统剪切版  *if we want to copy some text from inside of vim and paste it into an external program (or vice versa)*
***** 用寄存器中的内容替换高亮选区的文本 replace a visual selection with a register :yiw:ve:p:
      :PROPERTIES:
      :SUMMARY:    [[替换文本]]  [[交换文本]]
      :SOURCE:     
      :OPERATE:    
      :END:
      - 图解 unnamed register 和 visual selection
           y{scope1} d{scope1}
                    |
                  scope1
                            \
                                   v{scope2}
                                +v{scope2}+ scope1
                  scope2    /
      - <<替换文本>> using the unnamed register for both the yank and put operations because there is no delete step
        collection = getCollection();               1 yiw    unnamed register get 'collection' string
        ^ 1
        process(somethingintheway, target);
                ^ 2 3                               2 ve     visual mode select 'somethingintheway'
                                                    3 p      'collection' replace 'somethingintheway'
      - <<交换文本>> swap two word
        I like chips and fish
        ^ 1    ^ 2 3 7   ^ 4 5 6                    1 fc     find the first 'c' character backword the cursor
                                                    2 de     delete 'chips' string and bring it to unnamed register
                                                    3 mm     mark the current cursor
                                                    4 ww     locate the begin of the 'fish'
                                                    5 ve
                                                    6 p      replace 'chips' to 'fish' and give 'fish' to unnanmed register
                                                    7 `m     return to the mark place
                                                    8 P
***** 把寄存器的内容粘贴出来 paste from a register                                        :ciw<C-r>0:<yap gp gP>:
      :PROPERTIES:
      :SUMMARY:    [[面向字符]] [[面向行]]
      :SOURCE:     
      :OPERATE:    
      :END:
      - <<面向字符>> pasting character-wise regions
        - ciw<C-r>0<Esc>        always paste text *in front of* the cursor
          ciw                   delete a word then into insert mode
          <C-r>0                use yank register
      - <<面向行>> pasting line-wise regions
        yap               yank line-regions
        gp gP             put the text before or after line
***** 与系统剪切板进行交互 interact with the system clipboard
**** 宏 Macro
     :PROPERTIES:
     :SUMMARY:     针对相似的行 段落 文件 进行重复性的操作  for repeating changes over a set of similar lines paragraph file
     :SOURCE:      copy_and_paste
     :END:
***** 宏的读取与执行 record and execute a macro                                 :q{register}:@{register}:
      :PROPERTIES:
      :SUMMARY:    [[录制]] [[回放]]
      :SOURCE:     
      :OPERATE:    
      :END:      
      - <<录制>> capture a sequence of commands by recording a macro
               foo = 1                  1 qa              开始录制  q{register}  giving the address of register where we want to *save* the macro
         ^ 3 4 ^ 1    ^ 2               2 A;<Esc>         foo = 1;
               bar = 'a'                3 Ivar␣<Esc>      var foo = 1;
               Foobar = foo + bar       4 q               结束录制

        :reg a
        "a A;^[Ivar ^[
      - <<回放>> play back a sequence of commands by executing a macro
             var foo = 1;
              bar = 'a'
                ^ 1                     1 @a              执行宏  @{register}  execute the contents of the specified register
          Foobar = foo + bar
              ^ 2                       2 j@@             重复上次的宏  @@  repeat the macro that was invoked most recently
***** 规范光标位置 直达目标以及中止宏 normalize strike abort                    :100@a:
      :PROPERTIES:
      :SUMMARY:    [[规范光标位置]] [[可重复的命令直达目标]] [[当动作命令失败时 宏将中止]]
      :SOURCE:     
      :OPERATE:    
      :END:      
      - 录制一个宏时 要确保每条命令都可以被重复执行 *when recording a macro  ensure that every command is repeatable*
      - <<规范光标位置>> normalize cursor position
        - 确保光标位置已就位          make sure your cursor is positioned
        - 确定的位置开始执行          always starting on square one make it easier to strike the right target every time
            n        下一处匹配项           next search match
            0        当前行行首         start of the current line
            gg       文件首行          first line of current file
      - <<可重复的命令直达目标>>
        不要一味的敲方向键          <h j k l>     don't just hammer the *arrow key* until your cursor reaches its target
        使用面向单词的动作命令      <w b e ge>     more flexible
        禁止使用鼠标               using the mouse is *verboten*
      - <<当动作命令失败时 宏将中止>> abort when a motion fails
        如果宏动作命令失败 vim将中止宏的其余命令     10@a 100@a 1000@a   *ignore how many times* we execute this macro (result is the same)
***** 加次数回放宏 play back with a count                                       :qq;.q:
      #+Begin_SRC <vim>
        x = "+a+","+b+","+c+","+d+","+e+")";
        ^ 1                                       1 f+
          " + a 2                                 2 s + <Esc>
            " + a+" 3                             3 qq;.q          begin ;. macro
            " + a + " 4                           4 22@q           give all the + with macro ;.
      #+END_SRC
***** 在连续的文本上重复修改 repeat a change on contiguous lines                 :<j 3@a>:<jVG :'<,'>normal @a>:w~:
      :PROPERTIES:
      :SUMMARY:    [[以串行方式执行宏]] [[以并行方式执行宏]]
      :SOURCE:     broken-lines.txt
      :OPERATE:    
      :END:      
                                      <<以串行方式执行宏>>                                   <<以并行方式执行宏>>
                               qa -> 0f. -> r) -> w~ -> j -> q               qa -> 0f.r)w~ -> q -> jVG -> :'<,'>normal @a
      1. one                  |          1          |    2    |             |        1         |            2            |
         ^                       顺序执行 中间一旦出错 停止执行                 宏与宏的调用相互独立 即使其中一个出错 不会影响其他的宏
      2. two                     1                                                1
      3. three                   | 2                                              -->
      4. four                    V                                              / 1
                                 1                                           2  - -->
      1) One                     | 2                                            \ 1
      2) Two                     V                                                -->
      3) Three                   1
      4) Four

***** 给宏追加命令 append commands to a macro                                   :<qa qA>:
      :PROPERTIES:
      :SUMMARY:    [[宏的结尾添加命令]]
      :SOURCE:     
      :OPERATE:    
      :END:      
      - <<宏的结尾添加命令>> track commands on at the end of a macro
        qa   ->   q  ->  qA  ->  q
        | 0f.r)w~ |      |   j   |

        :reg a
        | 0f.r)w~ |
        | 0f.r)w~j               |
***** 在一组文件中执行宏 act upon a collection of files                          :<qa :next q 22@a :wall>:<qa q :edit! :argdo normal @a>:
      :PROPERTIES:
      :SUMMARY:    [[并行方式]] [[串行方式]]
      :SOURCE:     ruby_module/animal.rb  rc.vim
      :OPERATE:    
      :END:      
      # ...[end of copyright notice]
      class Animal
      ^ 1
        # implementation
      end

      # ...[end of copyright notice]
      module Rank
      ^ 2
        class Animal
          # implementation...
        end
      ^^ 3
      end
      ^^^ 4
              建立目标文件列表                       宏的录制                        <<并行方式>>                          <<串行方式>>
       build a list of target files        record a unit of work        execute the macro in parallel         execute the macro in series

        :cd code/macros/ruby_module         qa                                :edit! [fn:edit!]                    qa -> :next -> q
              :args ruby.*                  1 *gg* /class<CR> [fn:1]             [fn:argdo副作用]                           22@a
                  :args                     2 *O* module Rank<Esc>         :argdo normal @a [fn:argdo]               :wall [fn:wall]
        (:first :next :prev :last)          3 j>G [fn:3]
                                            4 *Go* end<Esc>
                                            q

[fn:1] gg  移到文档起始位置 place the cursor at the start of file
[fn:3] >G  本行到文件末尾自动缩进 to indent each line up to the end of the file
[fn:edit!] 放弃所有修改 文件未保存 revert all of the changes  if you had always written the changes to a file  just use the *u* command
[fn:argdo副作用] 需要先执行 edit! 取消对第一个缓冲区所做的修改
[fn:argdo] 参数列表内所有缓冲区文件执行一条ex命令 allow us execute an Ex command once for each buffer in argumnet list    <<:argdo>>
[fn:wall] 保存缓冲区列表内所有文件 save all files in the buffer list
***** 用迭代求值的方式给列表编号 evaluate an iterator to number items in a list   :<:let i=1 qa <C-r>=i :let i+=1 q>:
      :PROPERTIES:
      :SUMMARY:    [[带数字的运算]] [[带表达式的运算]] [[带变量循环的运算]]
      :SOURCE:     incremental.txt
      :OPERATE:    
      :END:      
      - target
        partridge in a pear tree
        turtle doves
        French hens
        calling birds
        golden rings
      - change
        1) partridge in a pear tree
        2) turtle doves
        3) French hens
        4) calling birds
        5) golden rings

      - <<带变量循环的运算>>
        1 设定变量i从1到5 录制宏为每行添加编号 第一行为 '1)'
          :let i=1 -> *qa* -> *I<C-r>=i<CR>)* <Esc> -> :let i+=1 -> q
        2 执行宏为剩下的行添加编号
          *jVG* -> :'<'> normal @a
***** 编辑宏的内容 edit the content of a macro                                  :<:put a !@#$% "ay$>:
      :PROPERTIES:
      :SUMMARY:    [[将宏粘贴到文档中]] [[编辑宏]] [[将宏从文档复制回寄存器]]
      :SOURCE:     mixed-lines.txt
      :OPERATE:    
      :END:
                      <<将宏粘贴到文档中>>            <<编辑宏>>                <<将宏从文档复制回寄存器>>
      1. One              1 :put a               2 f~ -> svU<Esc>               3 0 -> "ay$ -> dd
      2. Two              [fn:put]                 [fn:编辑宏]                    [fn:复制回寄存器]
      3. three
      4. four
      0f.r)w~j
      ^ 1 3 ^ 2
[fn:put] 最下方显示put对象 always pastes belows the current line
[fn:编辑宏] 像编辑文本一样编辑宏
[fn:复制回寄存器] 直接删除回寄存器"add 但会增加拖尾字符^J(换行)    先复制回寄存器 再删除更安全"ay$
*** pattern 模式
    :PROPERTIES:
    :SUMMARY:      /进入pattern模式 构造正则表达式 研究查找命令 :substitute :global
    :SOURCE:       patterns
    :END:
**** 按模式匹配及按原义匹配 matcing patterns and literals
     :PROPERTIES:
     :SUMMARY:     如何使用very nonlogic原义开关  使用查找模式中特殊元字符
     :END:
***** 调整查找模式大小写敏感 tune the case sensitivity of search patterns       :\c:\C:
      :PROPERTIES:
      :SUMMARY:    [[全局设置]] [[每次查找设置]]
      :SOURCE:     
      :OPERATE:    
      :END:
      - <<全局设置>> setting case sensitivily global
        :set ignorecase
      - <<每次查找设置>> setting case sensitivily per search
        \c 忽略大小写
        \C 强制区分大小写
        can be used anywhere in a pattern
***** 按正则表达式查找时 使用\v模式开关 use the \v pattern swich for regex searches
      :PROPERTIES:
      :SUMMARY:    [[用/\v模拟perl正则表达式]]
      :SOURCE:     color.css
      :OPERATE:    [[三种正则表达式]]
      :END:
      - 构造正则表达式 匹配CSS颜色代码 compose a regular expression that matches each of color codes in this snippet CSS

        body { color: #3c3c3c; }
        a { color: #0000EE; }
        strong { color: #000; }

        - <<三种正则表达式>>

          *bad*       magic search
                    /#\([0-9a-fA-F]\{6}\|[0-9a-fA-F]\{3}\)      必须转义 ( ) | {
                                                                escape ( ) | { character to confer special meaning upon them

          *better*    very magic search
                    \v#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})          \v模式开启后 ( ) | { 表现出特殊含义 <<用/\v模拟perl正则表达式>>
                                                                using \v pettern switch  the  ( ) | { character assume special meaning

          *best*      use hex character with very magic
                    \v#(\x{6}|\x{3})                            用\x字符类代替[0-9a-fA-F]
                                                                compact expression further by using \x character class
***** 按原义查找文本时 使用\V原义开关 use the \V literal switch for verbatim searches
      :PROPERTIES:
      :SUMMARY:    [[使用\V屏蔽特殊字符]]
      :SOURCE:     excerpt-also-known-as.txt
      :OPERATE:    [[屏蔽查找模式特殊字符]]
      :END:
      - 按照原义匹配 a.k.a.
        The N key searches backward...
        ...the \v pattern switch (a.k.a. very magic search)...

        - <<屏蔽查找模式特殊字符>>
          /\Va.k.a.     <<使用\V屏蔽特殊字符>>
          /a\.k\.a\.    转义特殊字符
                        cancel out the special meaning of . character by escapting it
***** 使用圆括号捕获子匹配 use parentheses capture submatches
      :PROPERTIES:
      :SUMMARY:    [[使用()和\1两次匹配相同的单词]]
      :SOURCE:     springtime.txt
      :OPERATE:    [[匹配重复单词的正则表达式]]
      :END:
      - 匹配重复字符 the the
        I love Paris in the
        the springtime.

        - <<匹配重复单词的正则表达式>>
          /\v<(\w+)\_s+\1>
          - (w+)\_s+\1  <<使用()和\1两次匹配相同的单词)>>
                       the trick to matching the same word twice lies in the combination of () and \1
            ()         括号内部的匹配文本自动保存到一个临时的仓库
                       Anything that matches inside of parentheses is automatically assigned to a temporary silo
            w          单词匹配
            _s        匹配空白符或换行符
                       matches whitespace or a line break
            \1         捕获括号内文本 (第二个括号用\2 以此类推)  <<子匹配调用>>
                       reference the captured text as \1
          - <>         [[技巧76]]
***** 界定单词的边界 stake the boundaries of a word                             :<>:[[%]]:
      :PROPERTIES:
      :SUMMARY:    [[在\v模式下 使用<>表示单词定界符]]
      :SOURCE:     springtime.txt
      :OPERATE:    [[匹配the单词的几种方式]]
      :END:
      - 明确匹配'the'这个单词 而不是其他词的某个组成部分 match 'the' as a word rather than a fragment
        the problem with these new recruits is that
        they don't keep their boots clean.

        - <<匹配the单词的几种方式>>

          精确匹配
            /\v    <    the    >     <CR>                搜索the单词
                                                         <<在\v模式下 使用<>表示单词定界符>> <<技巧76>>
            /\v \W\zs\w the \w\ze\W  <CR>                使用 单词符(\w \W) 匹配定界符(\zs \ze)  模拟<>
                                                         [fn:单词符_匹配定界符]

          模糊匹配
            /the<CR>         搜索包含the单词

      - 使用圆括号 但不捕获其内容 (<<%>>)
        /\v%(And|D)rew Neil

        /\v(%(And|D)rew) (Neil)
        :%s//\2, \1/g

[fn:单词符_匹配定界符] \w 匹配单词类字符 包括字母、数字以及符号'_'
                     \W 匹配单词类字符以外的其他字符
                     \ze \zs [[技巧77]]
***** 界定匹配的边界 stake the boundaries of a match
      :PROPERTIES:
      :SUMMARY:    [[同时使用\zs和\ze对匹配的起始和末尾进行微调]]
      :SOURCE:     
      :OPERATE:    
      :END:
      - 对双引号内匹配的文本进行微调
        Match "quoted words" ---not quote marks.

              "quoted words"                       /\v"[^"]+"<CR>
                                                      "[^"]+"              对双引号内容进行匹配(包括双引号)
               quoted words                        /\v"\zs[^"]+\ze"<CR>    <<同时使用\zs和\ze对匹配的起始和末尾进行微调>> <<技巧77>>
                                                                           use \zs and \ze items to crop the match  makeing it a subset of entire pattern
***** 转义问题字符 escap problem character
      :PROPERTIES:
      :SUMMARY:    [[手动转义查找域结束符]] [[调用=表达式escape函数自动转义]]
      :SOURCE:     
      :OPERATE:    [[将URL复制到寄存器]] -> [[编辑查找域]] -> [[转义URL结束符]]
      :END:
      - 将 http://vimdoc.net/search?q=/\\ 粘贴到寄存器u 并在文本进行查找

        Search items: [http://vimdoc.net/search?q=/\\][s]
        ...
        [s]: http://vimdoc.net/search?q=/\\

        - <<将URL复制到寄存器>>
          - "uyi[
            "u        调用u寄存器
            yi[       yank insert []
        - <<编辑查找域>>
          - 手动转义
            /\V<C-r>u<CR>    粘贴至查找域
          - 调用函数
            /\V<C-r>=<CR>    使用=表达式
        - <<转义URL结束符>>
          - <<手动转义查找域结束符>>
            - 手动转义
              - 屏蔽正向查找域结束符/  escape / character when searching forward
                ->/\Vhttp://vimdoc.net/search?q=/\\
              - 屏蔽反向查找域结束符?  escape ? character when searching backword
                ->/\V?http://vimdoc.net/search\?q=/\\
              - 无论正向反向都要屏蔽的字符\  escape \ every time
                ->/\Vhttp:\/\/vimdoc.net\/search?q=\/\\\\
            - <<调用=表达式escape函数自动转义>>  escap character programmatically
              escape({string}, {chars})  自动转义指定寄存器内容
                     =escape(@u, getcmdtype().'\')          [fn:自判断函数]
                              正反向自判断
                         /                   \
              =escape(@u, '/\')           =escape(@u,'?\')
                   正向搜索                    反向搜索

                                   正向搜索返回      反向搜索返回
[fn:自判断函数] getcmdtype().'\'       '/\'             '?\'        其中.操作符用来连接字符串

**** 查找 search
     :PROPERTIES:
     :SUMMARY:     怎样查找 如何高亮匹配 各个匹配之间的跳转
                   vim增量查找功能 查找偏移功能
                   简单的定制命令 查找当前高亮选区文本
     :SOURCE:      search
     :END:
***** 结识查找命令 meet the search command                                      :</?>:<nN>:<gn gN>:
      :PROPERTIES:
      :SUMMARY:    [[执行查找]] [[查找方向]] [[重复查找]] [[回溯查找]]
      :SOURCE:     
      :OPERATE:    
      :END:
      - <<执行查找>>
        /
        <CR>
        <Esc>
      - <<查找方向>>
        /
        ?
      - <<重复查找>>
        n        N
        /<CR>    ?<CR>
        [[gn]]       gN
      - <<回溯查找>>
        <up>
***** 高亮查找匹配 highlight search matches
***** 匹配的增量功能 preview the first match before execution
      :PROPERTIES:
      :SUMMARY:    [[即时匹配]] [[即时预览]] [[自动补全]]
      :SOURCE:     
      :OPERATE:    
      :END:
      - The car was the color of a carrot.
        (1) car
                               (2) carrot
        (3) ^                  (4) ^

        (1) /car -> (2) /carr -> (3) /carr<CR>         <<即时匹配>>
                              -> (4) /carr<Esc>        <<即时预览>>
                              -> (5) /carr<C-r><C-w>   <<自动补全>>
***** 将光标偏移到查找匹配的结尾 offset the cursor to the end of search match   :/lang/e:
      :PROPERTIES:
      :SUMMARY:    [[前置查找偏移]] [[后置查找偏移]]
      :SOURCE:     langs.txt
      :OPERATE:    [[查找模式字符匹配 n字符跳转 .范式字符操作]]
      :END:
      - 替换 lang 为 language
        Aim to learn a new programming lang each year.
                                   (1) lang^
                                   (2) language^
        Which lang did you pick up last year?
          (1) lang
          (3) lang^
          (4) language^
        Which lang did you pick up last year?
          (1) lang
          (5) languages

        - <<查找模式字符匹配 n字符跳转 .范式字符操作>>
               */lang/e<CR> ->*        <<前置查找偏移>>
                     (1)         \
                                           *a uage<CR> -> n -> . -> n.*
                                               (2)      (3)  (4)  (5)
                     (1)         /
          */lang/<CR> -> //e<CR> ->*    <<后置查找偏移>>
***** 对完整的查找匹配进行操作 operate on a complete search match
      :PROPERTIES:
      :SUMMARY:    [[构造一个指定匹配的正则表达式]] [[转换需要转换的字符为大写]]
      :SOURCE:     tag-heirarchy.rb
      :OPERATE:    [[查找模式下正则表达式匹配字符操作]]
      :END:
      - 指定字符 转换大写
        class XhtmlDocument < XmlDocument; end
          (1)^Xhtml       (1) Xml
        class XhtmlTag < XmlTag; end
          (1) Xhtml  (1) Xml

        class XHTMLDocument < XMLDocument; end
          (2)^XHTML       (3)^XML
        class XHTMLTag < XMLTag; end
          (4)^XHTML
        - <<查找模式下正则表达式匹配字符操作>>
          (1) /\vX(ht)?ml\C<CR>                              <<构造一个指定匹配的正则表达式>>
          (2) gUgn  (3) .  (4) .                             <<转换需要转换的字符为大写>> [fn:gn]

[fn:gn] <<gn>>  把光标移到下一匹配处(或者在当前光标匹配处) 运行动作命令    集 操作命令 和 移动命令 于一身的 .范式
                operates on the next match (or current cursor) and applies the last operation, I call this the Improved Dot Formula.
***** 利用查找历史 迭代完成复杂的模式 create complex patterns by iterating upon search history
      :PROPERTIES:
      :SUMMARY:    [[回溯查找历史]]
      :SOURCE:     quoted-strings.txt
      :OPERATE:    [[替换所有的'为“]]
      :END:
      - 替换 ' -> "
        This string contains a 'quoted' word.
                          (ac) 'quoted'
                      (<<b1>>)  quoted'
        This string contains 'two' quoted 'words.'
                    (<<a2>>) 'two' quoted 'words.'
                        (bc) 'two'        'words.'
        This 'string doesn't make things easy.'
        (ab) 'string doesn't make things easy.'
        (c)

        This string contains a “quoted” word.
        This string contains “two” quoted “words.”
        This “string doesn't make things easy.”

        - <<替换所有的'为“>>
          - :%s/\v'(([^']|'\w)+)'/“\1”/g    最终形态
            ^
          - :%s//“\1”/g                     把匹配的内容从寄存器1中取出 进行替换
                  \1                        <<an effective workflow for building regular expressions>>
                   ^
          - /\v'(([^']|'\w)+)'              把匹配的内容保存在寄存器1中
                (([^']|'\w)+)
                (           )
            ^
          - /\v'([^']|'\w)+'                把撇号的情况包含进来
                ([^']|'\w)
                 [^']
                     |
                      '\w
            ^
          - /\v'[^']+'                      第一行第一个'被当做撇号处理([[b1]]) [fn:撇号]
                [^']                        除了'之外的其他字符
            ^
          - /\v'.+'                         在第二行进行了贪婪匹配 quoted 被多余匹配([[a2]])
            .                               匹配一个或多个字符
        - <<回溯查找历史>>
          /<UP>                 prefill the search field with our pattern
          q/                    summon the command-line window  [fn:example]
[fn:撇号]     示例 won't don't
[fn:example] /\v'[^']+'
             v                   f[ -> c%(<C-r>")<Esc> -> i|\w<Esc>
             /\v'([^']|'\w)+'          c%        delete the +[^']+
                                       c         delete
                                       %         move A to B  [^']
                                                              A  B
                                       <C-r>"    yank the [^']
                                       <C-r>     insert the register text
                                       "         the delete and yank register
***** 统计当前的匹配个数 count the matches for the current pattern
      :PROPERTIES:
      :SUMMARY:    [[:substitude command]]   [[:vimgrep command]]
      :SOURCE:     buttons.js
      :OPERATE:    [[use 2 method to match every button]]
      :END:
      - match every button

        var buttons = viewport.buttons;
        viewport.buttons.previous.show();
        viewport.buttons.next.show();
        viewport.buttons.index.hide();

        - <<use 2 method to match every button>>
          /\<buttons\>                    match every single word of 'button'
          - 1. <<:substitude command>>    lets us know the *total number* of matches for a pattern
            - :%s///gn                    /5 matches on 4 lines/
                 //                       delimit the pattern field
                  //                      delimit the replace field
          - 2. <<:vimgrep command>>       populates the *quickfix* list with each match found in the current buffer
            - :vimgrep //g %              /(1 of 5) var buttons = viewport.buttons;/
                                          expands to the filepath of the current buffer
            :cnext                        /(2 of 5) var buttons = viewport.buttons;/
            :cprev                        /(2 of 5) var buttons = viewport.buttons;/
      :%s///gn
***** 查找高亮选区中的文本 search for the current visual selection
      :PROPERTIES:
      :SUMMARY:    [[the * command in visual mode]] [[visual-star]]
      :SOURCE:     visual-star.vim
      :OPERATE:    [[Search for the Current Selection]]
      :END:
      - match 'sea' in visual selection

        She sells sea shells by the sea shore.
        She sells sea^
        She sells sea shells by the s^        *  <<the * command in visual mode>>

        - <<Search for the Current Selection>>
          :vmap X y/<C-R>"<CR>      [fn:note]
                  y                 yank the current visual selection
                   /<C-r>"<CR>      bring up the search prompt, paste the contents of default register and execute the search

          - <<visual-star>>
            * 命令原有功能被覆盖 #命令被重新定义为反向查找文本 overriding the * command, customized the # command
            - paste this into your vimrc file directly or install the visual star search plugin  [fn:install]    <<use * command in visual mode for pattern searching>>
              xnoremap * :<C-u>call <SID>VSetSearch('/')<CR>/<C-R>=@/<CR><CR> xnoremap # :<C-u>call <SID>VSetSearch('?')<CR>?<C-R>=@/<CR><CR>
              function! s:VSetSearch(cmdtype)
              let temp = @s
              norm! gv"sy
              let @/ = '\V' . substitute(escape(@s, a:cmdtype.'\'), '\n', '\\n', 'g') let @s = temp
              endfunction

[fn:note] Note that special characters (like “.” and “*”) will cause problems.
[fn:install] https://github.com/nelstrom/vim-visual-star-search
**** 替换 substitution
     :PROPERTIES:
     :SUMMARY:      substitude 命令从简单到复杂
     :SOURCE:       substitution
     :END:
***** 结识 substitude 命令
      :PROPERTIES:
      :SUMMARY:    [[语法]] [[替换域特殊字符]]
      :SOURCE:     
      :OPERATE:    
      :END:
      - <<语法>>  syntax
        :[[[range]]]s[ubstitute]/{pattern}/{string}/[[[flags]]]

        - <<flags>>  Tweak the Substitute Command Using Flags
          g  [[全局]]  makes the substitute command act globally
          c  [[确认修改]]  gives us the opportunity to confirm or reject each change
          n  [[显示修改数]]  suppresses the usual substitute behavior, causing the command to report the number of command matches
          e  [[屏蔽无匹配错误]]  silence these errors that using a pattern that has no matches in the current file
          &  [[重用上次标志位]]  reuse the same flags from the previous substitute command.

      - <<替换域特殊字符>>  Special Characters for the Replacement String

        |----------------+----------------------------------------------------------------------+-----------------------|
        | \r             | Insert a carriage return                                             |                       |
        | \t             | insert a tab character                                               |                       |
        | \\             | Insert a single backslash                                            |                       |
        | \1             | Insert the first submatch                                            | [[\1 \2 in use]]          |
        | \2             | Insert the second submatch (and so on, up to \9)                     |                       |
        | \0             | Insert the entire matched pattern                                    |                       |
        | &              | Insert the entire matched pattern                                    |                       |
        | ~              | Use {string} from the previous invocation of :substitute             | [[how the ~ taken works]] |
        | \={Vim script} | Evaluate {Vim script} expression; use result as replacement {string} | [[example of usage]]      |
***** 在文件范围内查找并替换每一处匹配 find and replace every matches in a file
      :PROPERTIES:
      :SUMMARY:    [[文件二维平面]]  [[flags g]]
      :SOURCE:     get-rolling.txt
      :OPERATE:    
      :END:
      - 将所有单词 going 替换为 roling
        When the going gets tough, the tough get going.
             (1) rolling                     (2) rolling
        If you are going through hell, keep going.
               (3) rolling              (4) rolling
        - <<文件二维平面>>
          think of a file as a two-dimensional board made up of characters along the x-axis and lines down the y-axis

          [[o]]         [[x]]
             ------------ >
            |
          [[y]] |    file
            |
            v
                            [[x+y]]

          <<o>>    original      :s/going/rolling     (1)
          <<x>>    <<flags g>>   :s/going/rolling/g   (1)(2)  <<全局>>
          <<y>>    range %       :%s/going/rolling    (1)(3)
          <<x+y>>  g + %         :%s/going/rolling/g  (1)(2)(3)(4)
***** 手动控制每一次替换操作 Eyeball Each Substitution
      :PROPERTIES:
      :SUMMARY:    [[观察每一处匹配 再决定是否进行替换]] [[替换-确认模式和点范式]]
      :SOURCE:     
      :OPERATE:    
      :END:
      - 替换所有的 content 为 copy
        ...We're waiting for content before the site can go live...
        ...If you are content with this, let's go ahead with it...
        ...We'll launch as soon as we have the content...

      - <<观察每一处匹配 再决定是否进行替换>>
          :%s/content/copy/gc             <<确认修改>>

          - 所有回复选项
            | trigger | effect                                          |
            |---------+-------------------------------------------------|
            | y       | Substitute this match                           |
            | n       | skip this match                                 |
            | q       | Quit substituting                               |
            | l       | “last”—Substitute this match, then quit         |
            | a       | “all”—Substitute this and any remaining matches |
            | <C-e>   | scroll the screen up                            |
            | <C-y>   | scroll the screen down                          |

      - <<替换-确认模式和点范式>>
          <<替换-确认模式>>    最少的键盘操作完成任务    allows us to complete the task with a minimum of keystrokes
          [[点范式]]              自始至终都在普通模式下    we’re in plain old Normal mode throughout. Everything works just as we expect it to.
***** 重用上次的查找模式 reuse the last match pattern
      :PROPERTIES:
      :SUMMARY:    [[查找域留空]]  [[历史记录调取]]
      :SOURCE:     
      :OPERATE:    
      :END:
      - <<查找域留空>>
        substitution 命令包含两个步骤 The substitute command involves two steps:
          (1) 撰写查找模式 composing a pattern
          (2) 设计合适的替换字符 devising a suitable replacement string

         :[range]s[ubstitute]/{pattern}/{string}/[flags]
                              {pattern}                  (1)  [[use * command in visual mode for pattern searching]]
                                  v                           [[an effective workflow for building regular expressions]]
         :[range]s[ubstitute]/         /{string}/[flags] (2)

        - <<历史记录调取>>
          将查找任务与替换任务分离 会致使两组信息被单独存放 历史记录无法正确调用
          Decoupling the search and replacement tasks causes the two pieces of information to be placed in separate silos

          创建一项完整的记录
          :%s/<C-r>//“\1”/g
              <C-r>/          将 查找域的上次历史记录 传值到 当前替换域中  <<another example>>
***** 用寄存器的内容替换 replace with the contents of a register
      :PROPERTIES:
      :SUMMARY:    [[引用寄存器内容]]
      :SOURCE:     
      :OPERATE:    
      :END:
      - 把替换字符串复制到寄存器  用传值引用的方式将寄存器的内容应用至替换域
        - 传值 pass by value
          :%s//<C-r>0/g          [[another example]]
               <C-r>0            在执行substitute命令之前 对查找域的内容进行一番检查并存储在寄存器0中
                                 但会出现 寄存器0中的特殊含义字符无法进行转义 多行文本显示不全等问题
                                 examine the contents of register before we execute the substitute command.
                                 but can't edit the special meaning within the replacement field and a multiline excerpt of text might not fit on the command line

        - 引用 pass by reference
          :%s//\=@0/g
               \=@0              动态替换模式   [[动态替换与静态替换的区别]]

      - <<动态替换与静态替换的区别>>
        - 静态替换  历史记录一目了然 直接调用执行
          :%s/Pragmatic Vim/Practical Vim/g
        - 动态替换  执行结果随着 /查找域 和 a寄存器 的改变而改变
          :let @/='Pragmatic Vim'
          :let @a='Practical Vim'
          :%s//\=@a/g
***** 重复上一次substitute 命令
      :PROPERTIES:
      :SUMMARY:    [[g&]] [[&&]]
      :SOURCE:     mixin.js
      :OPERATE:    
      :END:
      - 扩展替换模式到整个文件
        (1) :s/target/replacement/g    ->                       <<g&>>    =    :%s//~/&    =    <<:%&&>>
                                                                      重复(1)命令 作用范围扩展到全文件
                                             (repeat last substitute with last search pattern on all lines with the same flags)

      - 扩展文本
        (1)
        mixin = {
            applyName: function(config) {
           ^
                return Factory(config, this.getName());
            },
        }

        (2)
        mixin = {
           applyNumber: function(config) {
                return Factory(config, this.getNumber());
           },
           applyNumber: function(config) {
                return Factory(config, this.getNumber());
           },
        }

        (3)
        mixin = {
            applyName: function(config) {
                return Factory(config, this.getName());
            },
            applyNumber: function(config) {
                return Factory(config, this.getNumber());
            },
        }

        (2) Vjj -> yP -> :%s/Name/Number/g
        (3) u -> gv -> :'<,'>&&
                 gv                         [[重选上一次高亮选取]]
                       :'<,'>&&             在当前高亮选区范围内 重复上次替换操作 ([[:%&&]] 作用于整个文件 )
                        '<,'>               当前高亮选区 (可视模式进入命令行模式自动填充)
                             &              :& 组成部分 重复上一次 :substitute 命令
                              &             重用上一次 :s 的标志位  <<重用上次标志位>>
***** 使用子匹配重排CSV字段 Rearrange CSV Fields Using Submatches
      :PROPERTIES:
      :SUMMARY:    
      :SOURCE:     subscribers.csv
      :OPERATE:    [[利用查找域子匹配 重排字段]]
      :END:
      - 修改字段排列顺序
        last name,first name,email
        neil,drew,drew@vimcasts.org
        doe,john,john@example.com

        email,first name,last name
        drew@vimcasts.org,drew,neil
        john@example.com,john,doe

        - <<利用查找域子匹配 重排字段>>
          /\v^([^,]*),([^,]*),([^,]*)$
                 \1      \2      \3      [[子匹配调用]]
              ([^,]*),                   匹配0次或多次连续的非逗号字符
                       v
                   :%s//\3,\2,\1
***** 在替换过程中执行算术运算 Perform Arithmetic on the Replacement
      :PROPERTIES:
      :SUMMARY:    [[匹配<h或<h/之后的数字]]  [[submatch函数执行算术运算]]
      :SOURCE:     subscribers.csv
      :OPERATE:    
      :END:
      - 提升每一处标题的层级
        <h2>Heading number 1</h2>
        <h3>Number 2 heading</h3>
        <h4>Another heading</h4>

        <h1>Heading number 1</h1>
        <h2>Number 2 heading</h2>
        <h3>Another heading</h3>

        - <<匹配<h或</h之后的数字>>
          */\v\<\/?h\zs\d*
             \<\/?                 < or </
                  h\zs\d           匹配紧随h后的任意数字(例 h1 1)
                   \zs             [[技巧77]]
             v
        - <<submatch函数执行算术运算>>
          :%s//\=submatch(0)-1/g
          submatch(0)       获得当前匹配内容  <<submatch函数>>

***** 交换两个或更多的单词 swap one or more words
      :PROPERTIES:
      :SUMMARY:    [[定义数据字典]]
      :SOURCE:     who-bites.txt
      :OPERATE:    [[substitute命令]] [[超级substitute命令]]
      :END:
      - 交换 man 和 dog
        The dog bit the man.

        - <<substitute命令>>
          查找
          /\v(<man>|<dog>)
             (           )    捕获匹配文本
              <man>|<dog>     匹配整个单词 man 或 dog

          替换
          :%s//\={"dog":"man","man":"dog"}[submatch(1)]/g
             /
               \=                                           调用vim脚本表达式
                 {"dog":"man","man":"dog"}                  <<定义数据字典>> [fn:example_dictionary]
                                          [submatch(1)]     [[submatch函数]]
        - <<超级substitute命令>>
          :%S/{man,dog}/{dog,man}/g

[fn:example_dictionary] :let swapper={"dog":"man","man":"dog"}
                        :echo swapper["dog"]
                        -> man
                        :echo swapper["man"]
                        -> dog
***** 多个文件中执行查找 Find and Replace Across Multiple Files                 :copen:cfdo:vimgrep:
      :PROPERTIES:
      :SUMMARY:    
      :SOURCE:     refactor-project/
      :OPERATE:    [[sustitute one file]]  [[search mutiple files]]  [[sustitute mutiple files]]
      :END:
      - 修改 Pragmatic Vim 为 Practical Vim    同时保持 Pragmatic Bookshelf不变
        refactor-project/
          about.txt
          Pragmatic Vim is a hands-on guide to working with Vim.

          credits.txt
          Pragmatic Vim is written by Drew Neil.

          license.txt
          The Pragmatic Bookshelf holds the copyright for this book.

          extra/
            praise.txt
            What people are saying about Pragmatic Vim...

            titles.txt
            Other titles from the Pragmatic Bookshelf...


        - <<substitude one file>>
          /Pragmatic\ze Vim                 (1)
                    \ze                     [[技巧77]]
             v
          :%s//Practical/g
        - <<search mutiple files>>
          (1)
          :vimgrep // **/*.txt              (2)
           [[vimgrep]]
                      **/*.txt              to tell vimgrep to look inside all files in current directory that use .txt extension
        - <<substitute mutiple files>>
          $ vim path/to/refactor-project/   open a *nerd tree* for 'refactor-project' folder

          *:copen*                            quickfix appearance
          (1)(2)                            add search txt file in quickfix, you can browse the content by click the file name

          :set hidden                       This setting enables us to navigate away from a modified file without first saving it.
          :cfdo %s//Practical/g | update
          :cfdo                             run the substitute command on every file that appears in the quickfix list.
                                |           combine   :cfdo %s//Practical/gc   and   :cfdo update
                                  update    saves the file, but only if it has been changed
**** Global 命令
     :PROPERTIES:
     :SUMMARY:      在 指定模式 所有匹配行上 运行 ex命令  runs an Ex command on each line that matches a specified pattern
     :SOURCE:       global
     :END:
***** 结识 global 命令
      :PROPERTIES:
      :SUMMARY:    [[语法]]
      :SOURCE:     
      :OPERATE:    
      :END:
      - <<语法>>
        *:[range]global[!]/{pattern}/[cmd]*    [fn:grep]
         [range]                             default range for the :global command is the entire file (%)
                          {pattern}          leave it blank and Vim will automatically use the *current search pattern*
                                    [cmd]    The [cmd] could be any Ex command except for another :global command, default use :print
                global!                      [[:vglobal]]
***** 删除所有包含模式的文本行 Delete Lines Containing a Pattern
      :PROPERTIES:
      :SUMMARY:    [[用 g/re/d 删除所有匹配行]]  [[用 v/re/d 只保留匹配行]]
      :SOURCE:     episodes.html
      :OPERATE:    [[:global和:delete组合使用]]
      :END:
      - 利用 global 命令  分别取出  主题标题 以及 URL
        <ol>
          <li>
            <a href="/episodes/show-invisibles/">
              Show invisibles
            </a>
          </li>
          <li>
            <a href="/episodes/tabs-and-spaces/">
              Tabs and Spaces
            </a>
          </li>
          <li>
            <a href="/episodes/whitespace-preferences-and-filetypes/">
              Whitespace preferences and filetypes
            </a>
          </li>
        </ol>

        (2)
        Show invisibles
        Tabs and Spaces
        Whitespace preferences and filetypes

        (3)
        <a href="/episodes/show-invisibles/">
        <a href="/episodes/tabs-and-spaces/">
        <a href="/episodes/whitespace-preferences-and-filetypes/">

        - <<:global和:delete组合使用>>
          - <<用 g/re/d 删除所有匹配行>> (2)
            */\v\<\/?\w+>*
               \<                       match <
                 \/?                    match / (option)
                    \w+                 match one or more word characters
                       >                match >
              v
            :g//d                       delete the global match line [fn:grep]
          - <<用 v/re/d 只保留匹配行>> (3)
            :v/href/d
            :v                          it executes a command on each line that does not match the specified pattern <<:vglobal>>

[fn:grep] :g/re/p
           g         global command
             re      regular expression
                p    print
***** 将todo项收集至寄存器 Collect TODO Items in a Register                     :global:args:argdo:
      :PROPERTIES:
      :SUMMARY:    
      :SOURCE:     markdown.js
      :OPERATE:    [[组合:global和:yank]]
      :END:
      - 收集TODO信息
        Markdown.dialects.Gruber = {
          lists: function() {
            // TODO: Cache this regexp for certain depths.
            function regex_for_depth(depth) { /* implementation */ }
          },
          "`":function inlineCode( text ) {
                var m = text.match( /(`+)(([\s\S]*?)\1)/ );
                if ( m && m[2] )
                  return [ m[1].length + m[2].length ];
                else {
                  // TODO: No matching end code found - warn!
                  return [ 1, "`" ];
                }
              }
        }

        (1)
        // TODO: Cache this regexp for certain depths.
        // TODO: No matching end code found - warn!

        (2)
        --- Registers ---
        "a

        (3)
        "a // TODO: Cache this regexp for certain depths.
           // TODO: No matching end code found - warn!

        - :g/TODO (1)
          - :g/TODO/yank A (3) <<组合:global和:yank>>
             g                 :global
                    yank       :yank
                         A     将:global命令复制的内容 A 附加到 寄存器a 中
                                                     a 覆盖  寄存器a 内容
          - :argdo g/TODO/yanl A    收集一组文件所有TODO项
          - :g/TODO/t$ (3)
                    t$         [[:t]]
        - :reg a (2)
***** 将CSS文件中所有规则的属性按字母排序 Alphabetize the Properties of Each Rule in a CSS File
      :PROPERTIES:
      :SUMMARY:    [[Sort Properties for a Single Block of Rules]]  [[Sort Properties for Every Block of Rules]]
      :SOURCE:     unsorted.css
      :OPERATE:    [[组合:global和:yank]]
      :END:
      - 每一组规则内的属性 按照字母顺序排序
        (1)
        html {
          margin: 0;
          padding: 0;
          border: 0;
          font-size: 100%;
          font: inherit;
          vertical-align: baseline;
        }
        body{
          line-height: 1.5;
          color: black;
          background: white;
        }

        (2)
        html {
          border: 0;
          font-size: 100%;
          font: inherit;
          margin: 0;
          padding: 0;
          vertical-align: baseline;
        }

        (3)
        html {
          border: 0;
          font-size: 100%;
          font: inherit;
          margin: 0;
          padding: 0;
          vertical-align: baseline;
        }
        body {
          background: white;
          color: black;
          line-height: 1.5;
        }

        - <<Sort Properties for a Single Block of Rules>> (1)(2)
          vi{ -> :'<,'>sort
        - <<Sort Properties for Every Block of Rules>> (1)(3)
          :g/{/ .+1,/}/-1 sort
           g                         global 命令           范围扩展至整个文件
            */{/     /}/*              pattern 查找匹配       查找匹配字符{ 或 }
            */{/ .+1*                  ex 命令                当前行直到匹配到}字符为止
*** 工具
    :PROPERTIES:
    :SUMMARY:      工具箱 外部协同工具  调用 make grep 外部程序  拼写检查自动补全和:vimgrep
    :SOURCE:       
    :END:
**** 通过 ctags 建立索引 并用其浏览源代码  Index and Navigate Source Code with ctags
     :PROPERTIES:
     :SUMMARY:      通过扫描代码库 生成关键字的索引
     :SOURCE:       ctags
     :END:
***** 结识 ctags
      :PROPERTIES:
      :SUMMARY:    [[标签文件]] [[关键字]]
      :SOURCE:     unsorted.css
      :OPERATE:    [[组合:global和:yank]]
      :END:
      - <<标签文件>>
        $ cd code/ctags
        $ ctags *.rb
        $ ls
          anglophone.rb francophone.rb speaker.rb [[ctags]]

        - <<ctags>>
          !_TAG_FILE_FORMAT      2       /extended format/
          ... metadata
          Anglophone      anglophone.rb   /^class Anglophone < Speaker$/;"        c
          ...keyword        filename                                          flags
            <<关键字>>
***** 配置vim使用ctags  Configure Vim to Work with ctags
      :PROPERTIES:
      :SUMMARY:    [[手动执行]] [[自动执行]] [[回调执行]]
      :SOURCE:     
      :OPERATE:    
      :END:
      - 查看 缺省标签文件 目录
        :set tags?
      - <<手动执行>>    最简单 定期更新索引
        :!ctags -R     更新当前文件夹索引
        :nnoremap <f5> :!ctags -R<CR>    设置快捷键F5
      - <<自动执行>>    保证了标签文件处于最新状态 只适用于规模较小的项目
        :autocmd BufWritePost * call system("ctags -R")    每次保存文件时自动调用ctags
      - <<回调执行>>    每当提交代码时 自动更新代码库 兼顾了以上两种方法的优缺点 [[http://tbaggery.com/2011/08/08/effortless-ctags-with-git.html][链接]]
***** 使用vim的标签跳转命令 来浏览关键字的定义
      :PROPERTIES:
      :SUMMARY:    [[普通模式]]  [[ex命令]]
      :SOURCE:     
      :OPERATE:    
      :END:
      - 跳转到关键字的定义处
        require './speaker.rb'

        class Anglophone < Speaker
        ^ (1)              ^ (2)
          def speak
            puts "Hello, my name is #{@name}"
          end
        end

        class Speaker
        ^ (3)
          def initialize(name)
               @name = name
             end
             def speak
               puts "#{name}"
          end
        end

        Anglophone.new('Jack').speak
        ^ (4)

        (5)
        # pri kind tag
        1 F C c    Anglophone        anglophone.rb
                        class Anglophone < Speaker
        2 F   c    Francophone       francophone.rb
                        class Francophone < Speaker
        Type number and <Enter> (empty cancels): (6)


        <<a>>    Jump to the *first tag that matches* the word under the cursor
                 (4) -> (1)    (2) -> (3)

        <<b>>    acts as the *back button* for our tag history
                 (1) -> (4)    (3) -> (2)

        <<c>>    Prompt user to select from *multiple matches* for the word under the cursor.
                 If only one match exists, jump to it without prompting.
                 (5)

        <<d>>    operate mutiple matches
                 (6)
      - <<普通模式>>
        <C-]>        [[a]]
        <C-t>        [[b]]
        g<C-]>       [[c]]
      - <<ex命令>>
        :tag {keyword} <tab>            [[a]]
        :tjump {keyword} <tab>          [[c]]
        :pop                            [[b]]
        :tnext :tprev :tfirst :tlast    [[d]]
        :tselect                        [[c]]
**** 编译代码 并通过quickfix浏览错误信息 Compile Code and Navigate Errors with the Quickfix List
     :PROPERTIES:
     :SUMMARY:      :make命令通过对编译器的错误信息进行解析 生成quickfix列表浏览
     :SOURCE:       quickfix
     :END:
***** 不离开vim也能编译代码 Compile Code Without Leaving Vim
      :PROPERTIES:
      :SUMMARY:    [[在shell中编译]]  [[在vim中编译]]
      :SOURCE:     
      :OPERATE:    
      :END:
      - <<在shell中编译>>
        $ cd code/quickfix/wakeup
        $ make
      - <<在vim中编译>>
        $ cd code/quickfix/wakeup
        $ pwd; ls
        $ vim -u NONE -N wakeup.c
        :make                        error
          :cnext                     amend
          :write                     save
          :make                      correct
***** 浏览quickfix列表 Browse the Quickfix List
      :PROPERTIES:
      :SUMMARY:    [[quickfix命令]]
      :SOURCE:     
      :OPERATE:    
      :END:
      - <<quickfix命令>>
        :cnext :cprev :cfirst :clast           item
        :5cnext
        :cnfile :cpfile  :cc N                 file
        :copen :cclose                         quickfix window
        k j <CR> :q
        :cdo {cmd}  :cfdo {cmd}                execute cmd in quickfix list
***** 回溯之前的quickfix列表 Recall Results from a Previous Quickfix List
***** 定制外部编译器 Customize the External Compiler
**** 通过grep、vimgrep以及其他工具对整个工程进行查找 Search Project-Wide with grep, vimgrep, and Others
     :PROPERTIES:
     :SUMMARY:      扫描多文件工具 grep ack
     :SOURCE:       
     :END:
***** 不必离开vim也能调用grep  Call grep Without Leaving Vim
      :PROPERTIES:
      :SUMMARY:    [[shell中]]  [[vim中]]
      :SOURCE:     
      :OPERATE:    
      :END:
      - <<shell中>>
        $ grep -n Waldo *
      - <<vim中>>
        :grep Waldo *
        :grep -i Waldo *    不区分大小写
***** 定制grep  Customize the grep Program
      :PROPERTIES:
      :SUMMARY:     [[ack插件]]
      :SOURCE:     
      :OPERATE:    
      :END:
***** 使用vim内部的grep  Grep with Vim’s Internal Search Engine
      :PROPERTIES:
      :SUMMARY:     [[语法]]  [[指定文件]]  [[查找域留空]]  [[调用查找历史]]
      :SOURCE:     
      :OPERATE:    
      :END:
      - 匹配所有含有going文件
        quotes/
          about.txt
            Don't watch the clock; do what it does. Keep going.
        <<tough.txt>>
            When the going gets tough, the tough get going.
          where.txt
            If you don't know where you are going,
            you might wind up someplace else.

      - <<语法>>
        :vim[grep][!] /{pattern}/[g][j] {file}
                                  [[g]]
                                     j
                                         [[##]]
      - <<指定文件>>    Specifying Which Files to Look Inside
        :vimgrep / going / about.txt tough.txt where.txt
        -> (1 of 3): Don't watch the clock; do what it does. Keep going.
        v
        add <<g>> flag    display all matches on quickfix line (the [[tough.txt]] contain two going)
        v
        :vim /going/g clock.txt tough.txt where.txt
        -> (1 of 4): Don't watch the clock; do what it does. Keep going.
        v
        :vim /going/g *.txt
        -> (1 of 4): Don't watch the clock; do what it does. Keep going.
      - <<查找域留空>>    Search in File, Then Search in Project
        /[Dd]on't
        :vim //g *.txt
      - <<调用查找历史>>
        :vim //g ##
        :vim /<C-r>//g ##
                     <<##>>    to represent the names of each file in the argument list, act as *.txt
**** 自动补全 Dial X for Autocompletion
***** 结识关键字自动补全 Meet Vim’s Keyword Autocompletion
      :PROPERTIES:
      :SUMMARY:    [[当前缓冲区关键字]]  [[操作补全菜单]]  [[标签文字关键字]]  [[补全字典项]]  [[补全整行]]  [[智能补全]]
      :SOURCE:     
      :OPERATE:    
      :END:
      - <<当前缓冲区关键字>>
        <C-x><C-n>
      - <<标签文字关键字>>
        <C-x><C-]>
      - <<补全字典项>>
        <C-x><C-k>
      - <<补全整行>>
        <C-x><C-l>
      - <<智能补全>>
        <C-x><C-o>
***** 与自动补全菜单交互 Work with the Autocomplete Pop-Up Menu
      :PROPERTIES:
      :SUMMARY:    [[操作]]
      :SOURCE:     
      :OPERATE:    
      :END:
      - <<操作>>  <<操作补全菜单>>
        <C-n>                    下一个匹配项
        <C-p>                    上一个匹配项
        <C-y>                    确认
        <C-e>                    取消
*** vimrc
    :PROPERTIES:
    :CLOCK:
    :SUMMARY: vim高度可配置文件
    :END:
**** 启动时不加载vimrc
     :LOGBOOK:  
     CLOCK: [2016-08-30 二 17:33]--[2016-08-30 二 17:38] =>  0:05
     :END:      
     :PROPERTIES:
     :CLOCK:
     :SUMMARY:    -u NONE 定制项不会生效  -N 防止进入vi兼容模式
     :SOURCE:     $ vim -u NONE -N
     :END:
**** 把所有数字当成10进制
     :LOGBOOK:  
     CLOCK: [2016-08-30 二 17:38]--[2016-08-30 二 17:40] =>  0:02
     :END:      
     :PROPERTIES:
     :CLOCK:
     :SUMMARY:    避免把0开头的数字当成8进制 例:007+001=010
     :SOURCE:     set nrformats=
     :END:
**** 启用 wildmode
     :LOGBOOK:  
     CLOCK: [2016-09-08 四 12:12]--[2016-09-08 四 12:16] =>  0:04
     :END:      
     :PROPERTIES:
     :SUMMARY:    ex自动补全列表自定义行为 [[vimrc相关配置1]]
     :END:
**** 提高命令的历史记录保存上限
     :LOGBOOK:  
     CLOCK: [2016-09-08 四 15:53]--[2016-09-08 四 15:56] =>  0:03
     :END:      
     :PROPERTIES:
     :SUMMARY:    缺省为20条 这里<<可以提高历史记录上限>>
     :SOURCE:     set history=200
     :END:
**** 轻松展开当前文件所在的目录
     :LOGBOOK:  
     CLOCK: [2016-09-18 日 16:18]--[2016-09-18 日 16:22] =>  0:04
     :END:      
     :PROPERTIES:
     :SUMMARY:    <<:edit 展开当前文件所在目录 vimrc 配置>> 使命令 %% 操作等效于 %:h<Tab>
     :SOURCE:     cnoremap <expr> %% getcmdtype( ) == ':' ? expand('%:h').'/' : '%%'
     :END:
**** 配置为可加载插件
     :LOGBOOK:  
     CLOCK: [2016-09-23 五 08:01]--[2016-09-23 五 08:04] =>  0:03
     :END:      
     :PROPERTIES:
     :SUMMARY:    <<加载 VIM 发行版中自带的标配插件>>
     :SOURCE:     set nocompatible
                  filetype plugin on
     :END:
**** 禁用光标键映射
     :PROPERTIES:
     :SUMMARY:    <<禁用光标键映射>>
     :SOURCE:     noremap <Up> <Nop>
                  noremap <Down> <Nop>
                  noremap <Left> <Nop>
                  noremap <Right> <Nop>
     :END:
**** 重新映射面向行的动作命令
     :LOGBOOK:  
     CLOCK: [2016-09-24 六 21:29]--[2016-09-24 六 21:31] =>  0:02
     :END:      
     :PROPERTIES:
     :SUMMARY:    <<重新映射面向行的动作命令>>
     :SOURCE:     nnoremap k gk
                  nnoremap gk k
                  nnoremap j gj
                  nnoremap gj j
     :END:       
*** :h
    :LOGBOOK:  
    CLOCK: [2016-08-30 二 16:14]--[2016-08-30 二 16:17] =>  0:03
    :END:      
    :PROPERTIES:
    :CLOCK:
    :SUMMARY: vim内置文档入口的超链接
    :SOURCE:  :h vimtutor
    :END:
**** <?>
***** .
      :LOGBOOK:  
      CLOCK: [2016-08-30 二 16:22]--[2016-08-30 二 16:23] =>  0:01
      :END:      
      :PROPERTIES:
      :CLOCK:
      :SUMMARY:    重复上次命令帮助文档
      :SOURCE:     :h .  <<:h .>>
      :END:
***** f{char}
      :LOGBOOK:  
      CLOCK: [2016-08-30 二 16:28]--[2016-08-30 二 16:30] =>  0:02
      CLOCK: [2016-08-30 二 16:24]--[2016-08-30 二 16:28] =>  0:04
      :END:      
      :PROPERTIES:
      :CLOCK:
      :SUMMARY:    让vim查找下一处字符出现的位置
      :SOURCE:     :h f  <<:h f>>
      :END:
***** *
      :LOGBOOK:  
      CLOCK: [2016-08-30 二 16:31]--[2016-08-30 二 16:33] =>  0:02
      :END:      
      :PROPERTIES:
      :CLOCK:
      :SUMMARY:    查找当前光标下的单词
      :SOURCE:     :h *  <<:h *>>
      :END:
***** aw
      :LOGBOOK:  
      CLOCK: [2016-08-30 二 16:36]--[2016-08-30 二 16:37] =>  0:01
      :END:      
      :PROPERTIES:
      :CLOCK:
      :SUMMARY:    删除光标下这个单词
      :SOURCE:     :h aw  <<:h aw>>
      :END:
***** count
      :LOGBOOK:  
      CLOCK: [2016-08-30 二 16:41]--[2016-08-30 二 16:43] =>  0:02
      :END:      
      :PROPERTIES:
      :CLOCK:
      :SUMMARY:    普通模式命令执行 次数前缀
      :SOURCE:     :h count  <<:h count>>
      :END:
***** 自定义操作符
      :LOGBOOK:  
      CLOCK: [2016-08-30 二 17:24]--[2016-08-30 二 17:26] =>  0:02
      :END:      
      :PROPERTIES:
      :CLOCK:
      :SUMMARY:    如何自己定义操作符
      :SOURCE:     :h :map-operator  <<:h :map-operator>>
      :END:
***** 自定义动作命令
      :LOGBOOK:  
      CLOCK: [2016-08-30 二 17:26]--[2016-08-30 二 17:27] =>  0:01
      :END:      
      :PROPERTIES:
      :CLOCK:
      :SUMMARY:    如何自己定义动作命令
      :SOURCE:     :h omap-info  <<:h omap-info>>
      :END:
***** operator
      :LOGBOOK:  
      CLOCK: [2016-08-30 二 16:44]--[2016-08-30 二 16:47] =>  0:03
      :END:      
      :PROPERTIES:
      :CLOCK:
      :SUMMARY:    操作符完整列表
      :SOURCE:     :h operator  <<:h operator>>
      :END:
***** ga
      :LOGBOOK:  
      CLOCK: [2016-08-30 二 20:24]--[2016-08-30 二 20:25] =>  0:01
      :END:      
      :PROPERTIES:
      :CLOCK:
      :SUMMARY:    查找光标下字符对应的字符编码(Unicode)
      :SOURCE:     :h ga  [[:h ga]]
      :END:
***** r{char} gr{char}
      :LOGBOOK:  
      CLOCK: [2016-08-31 三 09:16]--[2016-08-31 三 09:18] =>  0:02
      :END:      
      :PROPERTIES:
      :CLOCK:
      :SUMMARY:    单次替换文本 马上回到普通模式
      :SOURCE:     :h r  [[:h r]]
      :END:
***** U
      :LOGBOOK:  
      CLOCK: [2016-09-06 二 11:09]--[2016-09-06 二 11:10] =>  0:01
      :END:      
      :PROPERTIES:
      :CLOCK:
      :SUMMARY:    选中的字符变为大写
      :SOURCE:     :h v_U  [[:h v_U]]
      :END:
***** gU{motion}
      :LOGBOOK:  
      CLOCK: [2016-09-06 二 11:13]--[2016-09-06 二 11:14] =>  0:01
      :END:      
      :PROPERTIES:
      :CLOCK:
      :SUMMARY:    等同于可视模式下的 U
      :SOURCE:     :h gU  [[:h gU]]
      :END:
***** Ex命令
****** 全部功能列表
       :LOGBOOK:  
       CLOCK: [2016-09-06 二 15:50]--[2016-09-06 二 15:51] =>  0:01
       :END:      
       :PROPERTIES:
       :CLOCK:
       :SUMMARY:    相应功能ex命令列表
       :SOURCE:     :h ex-cmd-index  [[:h ex-cmd-index]]
       :END:
****** :copy :t
      :LOGBOOK:  
      CLOCK: [2016-09-07 三 13:30]--[2016-09-07 三 13:37] =>  0:07
      :END:      
      :PROPERTIES:
      :CLOCK:
      :SUMMARY:    ex 复制命令
      :SOURCE:     :h :copy  [[:h :copy]]
      :END:
******                                                                          :@:
       :LOGBOOK:  
       CLOCK: [2016-09-07 三 18:34]--[2016-09-07 三 18:38] =>  0:04
       :END:      
       :PROPERTIES:
       :SUMMARY:    重复上次的 ex 命令
       :SOURCE:     :h @:  [[:h @:]]
       :END:
****** 寄存器
       :LOGBOOK:  
       CLOCK: [2016-09-07 三 18:38]--[2016-09-08 四 10:05] => 15:27
       :END:      
       :PROPERTIES:
       :SUMMARY:    寄存器总保存最后执行的命令
       :SOURCE:     :h quote_:  [[:h quote_:]]
       :END:
****** 自动补全列表
       :LOGBOOK:  
       CLOCK: [2016-09-08 四 10:28]--[2016-09-08 四 10:56] =>  0:28
       :END:      
       :PROPERTIES:
       :SUMMARY:    显示可用的补全列表
       :SOURCE:     :h c_CTRL-D  [[:h c_CTRL-D]]
       :END:
****** 自动补全
       :LOGBOOK:  
       CLOCK: [2016-09-08 四 10:56]--[2016-09-08 四 10:59] =>  0:03
       :END:      
       :PROPERTIES:
       :SUMMARY:    ex命令自动补全
       :SOURCE:     :h :command-complete  [[:h :command-complete]]
       :END:
****** 多个补全项间选择
       :LOGBOOK:  
       CLOCK: [2016-09-08 四 10:59]--[2016-09-08 四 11:00] =>  0:01
       :END:      
       :PROPERTIES:
       :SUMMARY:    ex自定义补全行为
       :SOURCE:     :h 'wildmode'  [[:h 'wildmode']]
       :END:
**** <C-?>
***** <C-[>
      :PROPERTIES:
      :CLOCK:
      :SUMMARY:    返回普通模式 与<Esc>效果相同
      :SOURCE:     :h i_CTRL-[  <<内置链接1>>
      :END:
***** <C-o>
      :LOGBOOK:  
      CLOCK: [2016-08-30 二 17:02]--[2016-08-30 二 17:11] =>  0:09
      :END:      
      :PROPERTIES:
      :CLOCK:
      :SUMMARY:    插入模式下 执行一次普通模式命令 马上回到插入模式
      :SOURCE:     :h i_CTRL-O  <<:h i_CTRL-O>> 例:<C-o>zz
      :END:
***** <C-r>{register}
      :LOGBOOK:  
      CLOCK: [2016-08-30 二 17:11]--[2016-08-30 二 17:14] =>  0:03
      :END:      
      :PROPERTIES:
      :CLOCK:
      :SUMMARY:    插入模式下 用寄存器粘贴几个单词 {register}是寄存器的名字
      :SOURCE:     :h i_CTRL-R  <<:h i_CTRL-R>>
      :END:
***** <C-v>{code}
      :LOGBOOK:  
      CLOCK: [2016-08-30 二 20:16]--[2016-08-30 二 20:20] =>  0:04
      :END:      
      :PROPERTIES:
      :CLOCK:
      :SUMMARY:    用字符编码插入非常用字符
      :SOURCE:     :h i_CTRL-V_digit  [[:h i_CTRL-V_digit]]
      :END:
***** <C-k>{char1}{char2}
      :LOGBOOK:  
      CLOCK: [2016-08-31 三 08:29]--[2016-08-31 三 08:31] =>  0:02
      :END:      
      :PROPERTIES:
      :CLOCK:
      :SUMMARY:    用 二合字符 插入非常用字符
      :SOURCE:     二合字符规律 :h digraphs-default  [[:h digraphs-default]]  可用二合字符 :h digraph-table [[:h digraph-default]]
      :END:
**** <C-?><C-?>
***** <C-r><C-p>{register}
      :LOGBOOK:  
      CLOCK: [2016-08-30 二 17:22]--[2016-08-30 二 17:24] =>  0:02
      :END:      
      :PROPERTIES:
      :CLOCK:
      :SUMMARY:    插入模式下 按原义插入寄存器文本 {register}是寄存器的名字
      :SOURCE:     :h i_CTRL-R_CTRL-P  <<:h i_CTRL-R_CTRL-P>>
      :END:      
** CANCELLED mastering-emacs
   :LOGBOOK:  
   - State "CANCELLED"  from ""           [2017-09-17 日 10:45] \\
     emacs is so widely that one book can't override it
     so read the doc is the better choice
   :END:      
   :PROPERTIES:
   :COLUMNS:  %20ITEM %MEAN %SHOTCUTS
   :END:
*** first step
**** command to start
    :LOGBOOK:  
    CLOCK: [2016-08-13 六 08:30]--[2016-08-13 六 11:02] =>  2:32
    :END:      
    :PROPERTIES:
    :SHOTCUTS:   --help -nw -q -Q
    :END:
    + --help 显示帮助
    + -nw 强制在终端中执行
    + -q 不加载初始文件(init.el)
    + -Q 不加载站点范围内的文件(系统 运行环境相关)
**** modifier key use
     :LOGBOOK:  
     CLOCK: [2016-08-13 六 11:04]--[2016-08-13 六 11:17] =>  0:13
     :END:      
    + C- Control
    + M- Meta (“Alt” on most keyboards) 
    + S- Shift
    + s- Super (not shift!)
    + H- Hyper
    + A- Alt (redundant and not used)
**** move ctrl to capslock
     :LOGBOOK:  
     CLOCK: [2016-08-13 六 11:17]--[2016-08-13 六 11:20] =>  0:03
     :END:      
**** key chord
    :LOGBOOK:  
     CLOCK: [2016-08-13 六 13:09]--[2016-08-13 六 13:25] =>  0:16
     CLOCK: [2016-08-13 六 11:28]--[2016-08-13 六 11:40] =>  0:12
     :END:      
    :PROPERTIES:
    :SHOTCUTS:   M-x C-u M- C- C-M-
    :END:
    + M-x  Commands and functions
    + C-u  Universal Arguments
    + M- C- C-M-  sceen modefier
    + C-h  help system
**** customize
     :LOGBOOK:  
     CLOCK: [2016-08-13 六 13:25]--[2016-08-13 六 14:00] =>  0:35
     :END:      
    :PROPERTIES:
    :SHOTCUTS:   M-x customize
    :END:
    + M-x customize 自定义配置(学会elip配置前的过度)
**** something for evaluated
     :LOGBOOK:  
     CLOCK: [2016-08-14 日 21:42]--[2016-08-14 日 21:50] =>  0:08
     :END:      
    :PROPERTIES:
    :SHOTCUTS:   M-x eval buffer
    :END:
    + M-x eval buffer  在函数定义的buffer中不适用
**** package manage
     :LOGBOOK:  
     CLOCK: [2016-08-14 日 21:50]--[2016-08-15 一 07:24] =>  9:34
     :END:      
     :PROPERTIES:
     :SHOTCUTS:   M-x package-list-packages
     :END:
    + M-x package-list-packages  更新三方包
    + M-x package-install
**** info
     :LOGBOOK:  
     CLOCK: [2016-08-24 三 17:47]--[2016-08-24 三 19:18] =>  1:31
     :END:      
     :PROPERTIES:
     :MEAN:        emacs's info manual written in TeXinfo
     :SHOTCUTS:    M-x info   C-h i
     :END:
     + table of the keyboards shotcuts 65
**** apropos
     :LOGBOOK:  
     CLOCK: [2016-08-24 三 19:19]--[2016-08-25 四 08:28] => 13:09
     :END:      
     :Properties:
     :MEAN:       search aspects of Emacs’s self-documenting internals(part of symbol)
     :SHOTCUTS:   C-h a   M-x apropos-command  M-x apropos ..etc 69
     :END:
     + M-x apropos   list both variables command and function
     + M-x apropos-command   just list command
**** the describe system
     :PROPERTIES:
     :MEAN:        captures the Emacs’s self-documenting of command(total of sysbol)
     :SHOTCUTS:    M-x describe-mode  C-h m   M-x describe-funtion  C-h f .. 72
     :END:
*** the theory of movement
**** the basic
     :LOGBOOK:  
     CLOCK: [2016-08-25 四 08:52]--[2016-08-25 四 09:38] =>  0:46
     :END:      
     :PROPERTIES:
     :MEAN:        important commands of navigation and editing
     :SHOTCUTS:    C-x C-f|C-x C-s|C-x b|C-x k|C-x C-b|C-x C-c|C-/|F-10   .. 77
     :END:
***** find file
      :LOGBOOK:  
      CLOCK: [2016-08-25 四 09:53]--[2016-08-25 四 09:55] =>  0:02
      :END:      
      :PROPERTIES:
      :MEAN:        opening an existing file and creating a new file
      :SHOTCUTS:    C-x C-f  .. 78
      :END:
***** major mode load order
      :LOGBOOK:  
       CLOCK: [2016-08-25 四 09:39]--[2016-08-25 四 09:45] =>  0:06
       :END:      
      :PROPERTIES:
      :MEAN:       When you visit a file, Emacs will pick a major mode(can self-documnet)
      :SHOTCUTS:   #!/bin/bash magic-mode-alist auto-mode-alist  .. 80
      :END:
      - file local-variable
      - program loader directory  file begin with #! emacs will figure out the major mode
      - Magic mode detection  use the magic-mode-alist to detection mode
      - Automatic mode detection  open /etc/passwd emacs will detect this and open etc-passwd-generic-mode
***** Coding Systems and Line Endings
      :LOGBOOK:  
      CLOCK: [2016-08-25 四 09:45]--[2016-08-25 四 09:52] =>  0:07
      :END:      
      :PROPERTIES:
      :MEAN:       excellent Unicode support | determine the line endings used
      :SHOTCUTS:   C-h C <RET> .. 81
      :END:
***** Save Buffer
      :LOGBOOK:  
      CLOCK: [2016-08-25 四 09:56]--[2016-08-25 四 10:01] =>  0:05
      :END:      
      :PROPERTIES:
      :MEAN:       save it to a file associated with the buffer
      :SHOTCUTS:   <C-x C-s>  <C-x C-w>   <C-x s> .. 83
      :END:
      - C-x C-w  save a buffer to a different file
      - C-x s  to save each unsaved file
***** Exit Emacs
      :LOGBOOK:  
      CLOCK: [2016-08-25 四 10:02]--[2016-08-25 四 10:07] =>  0:05
      :END:    
      :Properties:
      :MEAN:       several options when Emacs asks you to save a file
      :SHOTCUTS:   C-x C-c  y  n  q  C-g  !  d .. 83
      :END:
***** Switch Buffer
      :LOGBOOK:  
      CLOCK: [2016-08-31 三 10:09]--[2016-08-31 三 10:21] =>  0:12
      CLOCK: [2016-08-25 四 10:07]--[2016-08-25 四 11:20] =>  1:13
      :END:      
      :PROPERTIES:
      :MEAN:       like ALT+TAB in windows
      :SHOTCUTS:   <C-x b> <C-x C-b>  <C-x C-f> .. 84
      :END:
      - buffers is different from files
      - buffer name format  *buffer name*
      - <C-x b>  swich buffer
      - <C-x C-b>  list all buffers
      - <C-x C-f>  ido mode  create a buffer from local file
***** kill buffer
      :LOGBOOK:  
      CLOCK: [2016-08-31 三 10:21]--[2016-08-31 三 10:24] =>  0:03
      :END:      
      :PROPERTIES:
      :MEAN:       close buffer
      :SHOTCUTS:   <C-x k> .. 86
      :END:
***** keyboard escape
      :LOGBOOK:  
      CLOCK: [2016-08-31 三 10:28]--[2016-08-31 三 10:30] =>  0:02
      :END:     

      :PROPERTIES:
      :MEAN:       go back to normal if something wrong with emacs
      :SHOTCUTS:   Esc Esc Esc .. 86
      :END:
***** Undo
      :LOGBOOK:  
      CLOCK: [2016-08-31 三 10:30]--[2016-08-31 三 10:35] =>  0:05
      :END:      
      :PROPERTIES:
      :MEAN:       undoing previous operate
      :SHOTCUTS:   <C-/> .. 86
      :END:
***** Redo
      :LOGBOOK:  
      CLOCK: [2016-08-31 三 10:35]--[2016-08-31 三 10:37] =>  0:02
      :END:      
      :PROPERTIES:
      :MEAN:       reversion of undo
      :SHOTCUTS:   <C-S-/> .. 86
      :END:
***** windows managment
      :LOGBOOK:  
      CLOCK: [2016-08-31 三 10:37]--[2016-08-31 三 10:54] =>  0:17
      :END:      
      :PROPERTIES:
      :MEAN:       manage windows in shotcut
      :SHOTCUTS:   <C-x> 0 1 2 3 .. 90
      :END:
      | key binding | purpose |
      |---+---|
      | C-x 0 | delete the active window |
      | C-x 1 | delete other windows  |
      | C-x 2 | split window below |
      | C-x 3 | split window right |
***** working with other windows
      :LOGBOOK:  
      CLOCK: [2016-08-31 三 11:19]--[2016-08-31 三 11:20] =>  0:01
      :END:      
      :PROPERTIES:
      :MEAN:       switch another window in split window
      :SHOTCUTS:    .. 93
      :END:
***** frame management
      :LOGBOOK:  
      CLOCK: [2016-08-31 三 11:21]--[2016-08-31 三 11:22] =>  0:01
      :END:      
      :PROPERTIES:
      :MEAN:       some operate about frame
      :SHOTCUTS:    .. 94
      :END:
***** moving
****** moving by character
      :LOGBOOK:  
      CLOCK: [2016-08-31 三 13:37]--[2016-08-31 三 13:38] =>  0:01
      :END:      
      :PROPERTIES:
      :MEAN:       
      :SHOTCUTS:    .. 97
      :END:
****** moving by line
      :LOGBOOK:  
      CLOCK: [2016-08-31 三 13:38]--[2016-08-31 三 13:39] =>  0:01
      :END:      
      :PROPERTIES:
      :MEAN:       
      :SHOTCUTS:    .. 98
      :END:
****** moving by mord
      :LOGBOOK:  
      CLOCK: [2016-08-31 三 13:38]--[2016-08-31 三 13:39] =>  0:01
      :END:      
      :PROPERTIES:
      :MEAN:       
      :SHOTCUTS:    .. 101
      :END:

****** moving by sentence
      :LOGBOOK:  
      CLOCK: [2016-08-31 三 13:38]--[2016-08-31 三 13:39] =>  0:01
      :END:      
      :PROPERTIES:
      :MEAN:       
      :SHOTCUTS:    .. 115
      :END:
****** moving by defun
      :LOGBOOK:  
      CLOCK: [2016-08-31 三 13:38]--[2016-08-31 三 13:39] =>  0:01
      :END:      
      :PROPERTIES:
      :MEAN:       
      :SHOTCUTS:    .. 116
      :END:      
****** moving by page
      :LOGBOOK:  
      CLOCK: [2016-08-31 三 13:38]--[2016-08-31 三 13:39] =>  0:01
      :END:      
      :PROPERTIES:
      :MEAN:       
      :SHOTCUTS: .. 117
      :END:
***** scrolling
      :LOGBOOK:  
      CLOCK: [2016-08-31 三 13:45]--[2016-08-31 三 13:56] =>  0:11
      :END:
      :PROPERTIES:
      :MEAN:       moveing in window
      :SHOTCUTS:   <C-v> <M-v> <C-x <> <M-<> .. 118
      :END:
      | key binding | puepose                             |
      |-------------+-------------------------------------|
      | C-v         | scroll down one page                |
      | M-v         | scroll up one page                  |
      | C-M-v       | scroll down other window            |
      | C-M-S-v     | scroll up other window              |
      |             |                                     |
      | C-x <       | scroll left                         |
      | C-x >       | scroll right                        |
      |             |                                     |
      | M-<         | move to the beginning of the buffer |
      | M->         | move to the end of buffer           |
      |             |                                     |
      |             |                                     |
***** bookmarks and registers
      :LOGBOOK:  
      CLOCK: [2016-08-31 三 13:58]--[2016-08-31 三 14:24] =>  0:26
      :END:      
      :PROPERTIES:
      :MEAN:       speed access to everywhere
      :SHOTCUTS:   <C-x r m|l|b>  <C-x r s|spc|j|w|f> .. 121
      :END:
      - bookmarks (permanent)
        | key binding  | purpose |
        |---+---|
        | C-x r m | set a bookmark |
        | C-x r l | list all bookmark |
        | C-x r b | jump to bookmark |
      - registers (transient)
        | key binding | purpose                                |
        |-------------+----------------------------------------|
        | C-x r s     | store region in register               |
        | C-x r spc   | store point in register                |
        | C-x r j     | jump to register                       |
        | C-x r w     | store window configuration in register |
        | C-x r f     | store frameset in register             |
        |             |                                        |
***** selections and regions
      :LOGBOOK:  
      CLOCK: [2016-08-31 三 14:25]--[2016-08-31 三 14:31] =>  0:06
      :END:      
      :PROPERTIES:
      :MEAN:       mark and select a region
      :SHOTCUTS:   .. 127
      :END:
***** setting the mark (relate up section)
      :LOGBOOK:  
      CLOCK: [2016-08-31 三 14:33]--[2016-08-31 三 14:36] =>  0:03
      :END:      
      :PROPERTIES:
      :MEAN:       make precise selections
      :SHOTCUTS:   .. 131
      :END:
***** searching and indexing
      :LOGBOOK:  
      CLOCK: [2016-08-31 三 14:36]--[2016-08-31 三 14:52] =>  0:16
      :END:      
      :PROPERTIES:
      :MEAN:       precise tool getting you from a to b
      :SHOTCUTS: <C-s>  <C-r> <C-M-s> <C-M-r> .. 134
      :END:
      - isearch
      | key binding | purpose            |
      |-------------+--------------------|
      | C-s         | down search        |
      | C-r         | up search          |
      | C-M-s       | regexp down search |
      | C-M-r       | regexp up search   |
      | ret         | pick select match  |
      | C-g         | exit search        |
      - control how isearch behaves using its toggles 139
***** Occur
      :LOGBOOK:  
      CLOCK: [2016-08-31 三 14:52]--[2016-08-31 三 14:56] =>  0:04
      :END:      
      :PROPERTIES:
      :MEAN:       print lines matching an expression
      :SHOTCUTS:   <M-s o> .. 142
      :END:
***** Imenu
      :LOGBOOK:  
      CLOCK: [2016-08-31 三 14:57]--[2016-08-31 三 15:00] =>  0:03
      :END:      
      :PROPERTIES:
      :MEAN:       
      :SHOTCUTS:   .. 146
      :END:      
** vim wiki
*** tips
**** modes
     : search and move *
**** regex
     : match group *
     : backtracking *
     : possessive quantifiers *
     : atomic groups *
**** php
     : move to next variable on current line *
* lang
** shell
*** PROJECT TLCL (bash & zsh)
**** bash
***** shell
****** navigate                                                                 :code:
       pwd cd ls / . ..
****** file system                                                              :code:
       ls less file
****** Manipulating files and directories                                       :code:
       : cp
       copy files and directories
         cp item... directory
       cp options
       cp examples
       : unix glob
       wildcards
       character classes
       examples
       : NOTE
       you should avoid using [A-Z] (or [0-9] [a-z] etc.)
         and use character classes instead
       : mkdir
       create directories
       : mv
       Move/rename files and directories
       file renaming
       file moving
       mv options
       mv examples
       : rm
       Remove files and directories
       remove (delete)
       rm options
       rm examples
       : NOTE
       Once you delete something with rm, it’s *gone* (can't get back)
       : TIP
       Be particularly careful *with wildcards*, test the wildcard first with ls
       rm * .html
           ^       there is a addtion writespace
       : ln
       create hard and symbolic links
       : ln hard link
       create a hard link
       : TIP
       how to confirms two files are the same
       : NOTE
       hard link have two important *limitations* (but symbolic link not have):
         A hard link cannot reference a file outside its own file system.
           This means a link may not reference a file
           that is not on the same disk partition as the link itself.
         A hard link may not reference a directory.
       : ln symbolic link
       Symbolic links work by creating a special type of file
         that contains a text pointer to the referenced file
         or directory (like a Windows shortcut)
       create a symbolic link
       symbolic link example
       : NOTE
       if you write some something to the symbolic link
         the referenced file is also written to
       when you delete a symbolic link
         only the link is deleted, not the file itself
       : RM symbol link
       : NOTE
       most file operations are carried out on the link’s target, rm is an exception
         When you delete a link, it is the link that is deleted, not the target
****** use command                                                              :code:
       : type
       display the kind of command
         Where “command” is the name of the command you want to examin
       type example
       : which
       display the position of an executable program
       which example
       : NOTE
       which only works for executable programs
       : help
       a build-in help facility for each shell builtins
       help examples
       : NOTE
       When square brackets appear in the description of a command’s syntax
         they indicate optional items
       A vertical bar character indicates mutually exclusive items
       : man
       provide a formal piece of documentation called a manual or man page
       man examples
       : apropos
       It is also possible to search the list of man pages
         for possible matches based on a search term
       apropos examples
       : NOTE
       the man command with the “-k” option performs the exact same function as apropos
       : whatis
       displays the name
         and a one line description of a man page
           matching a specified keyword
       : info
       The GNU Project provides an alternative to man pages for their program
       : alias
       create a command of our own using the alias command
       : NOTE
       unalias: the alias command must be not used
****** redirect
       : stdout stdin stderr
       Keeping with the Unix theme of “everything is a file"
       stdout
         programs such as ls actually send their results to a special file
           called standard output
       stderr
         their status messages to another file called standard error
       stdin
         many programs take input from a facility called standard input
       : NOTE
       By default, both standard output and standard error are linked to the screen
         stdin attached to the keyboard

       : >
       : redirect stdout
       To redirect standard output to another file besides the screen
       example
       : NOTE
       if have a error message while use stdout, it will rewrite the file and stopped
       : >>
       redirected output to a file instead of overwriting the file from beginning

       : file descriptor
       redirect stdout and stderr
         2    standard error
         1    standard output
       : NOTE
       the order of the redirections is significant
       : TIP
       : &>
       combined redirection
       use the single notation &> to redirect
         both standard output and standard error
         to the file ls-output.txt

       : /dev/null
       This file is a system device called a bit bucket
         which accepts input and does nothing with it
       To suppress error messages from a command
       : TIP
       /dev/null is a Unix Culture, read wiki article on "/dev/null"

       : cat
       reads one or more files and copies them to standard output
       display files without paging
       join large files together
         movie.mpeg.001 movie.mpeg.002 … movie.mpeg.099
       no arguments
         If cat is not given any arguments, by default, attached to the keyboard
         Next, type a Ctrl-d to tell cat that it has reached end of file (EOF)
           on standard input
       create a file
         create a file called “lazy_dog.txt” containing the text
       : <
       change the source of standard input
         Using the “<” redirection operator
           we change the source of standard input from the keyboard
           to the file lazy_dog.txt

       : |
       : pipe line
       standard output into another standard input
         the standard output of one command can be piped into
           the standard input of another
       : uniq
       : remove any duplicates from the output of the sort command
       the "-d" option
         If we want to see the list of duplicates instead, we add the “-d” option
       : wc
       : display the number of lines, words, and bytes contained in files
       The “-l” option
         The “-l” option limits its output to only report lines
       : grep
       : find text patterns within files
       find all file have "zip" keyword
         find all the files in our list of programs
           that had the word “zip” embedded in the name
       “-i” which causes grep to ignore case
       “-v” which tells grep to only print lines that do not match the pattern
       : head / tail
       : Print the beginning / end of the file
       The head command prints the first ten lines of a file
         and the tail command prints the last ten lines
       “-f” option, tail continues to monitor the file and when new lines are appended
       : NOTE
       use C-c to stop the immediately appear on the display
       : tee
       : reads standard input and copies it to both standard output
       :   and to one or more files
       read stdin and copy stdout to ls.txt
         capture the entire directory listing to the file ls.txt
           before grep filters the pipeline’s contents
****** expansions and quoting                                                   :code:
       : echo
       : display a line of text
       Any argument passed to echo gets displaye

       : filepath expansions
       the shell expands the “*” into something else (match the name of file)
         before echo command is executed
       listing of hidden files
         provide a correct listing of hidden files

       : (“~”)
       home directory of the named user
       When used at the beginning of a word
         it expands into the name of the home directory of the named user

       : arithmetic expansion
       use as a calculator
       a few of the supported operators
         + - * / % **

       : brace expansion
       comma-separated list of string
       a range of integers or single characters
       make lists of files or directories
         The most common application
           is to make lists of files or directories to be created

       : parameter expansion
       Many variables are available for your examination

       : command substitution
       allows us to use the output of a command as an expansion

       : quoting
       extra whitespace
       *word-splitting* by the shell
         removed extra whitespace
         from the echo command’s list of arguments
       The shell provides a mechanism called quoting
         to selectively suppress unwanted expansions

       : double quotes
       If you place text inside double quotes
         all the special characters used by the shell lose their special meaning
         and are treated as ordinary characters
       unpuoted spaces, tabs, and newlines

       : single quotes
       suppress all expansions

       : escape character
       prevent an expansion by precede a character with a backslash
       To include a special character in a filename
       backslash escape sequences
         \a \b \n \r \t
****** keyboard tricks
       : doing the most work with the fewest number of keystrokes

       : command line editing
       - the keys used to move the cursor
         C-a         beginning line
         C-e         end line
         C-f         forward character, right arrow key
         C-b         backward character, left arrow key
         M-f         forward one word
         M-b         backward word one
         C-l         clear screen
       - lists keyboard are used to edit characters on the command line
         C-d         delete character
         C-t         exchange character
         M-t         exchange word
         M-l         lowercase word
         M-u         uppercase word
       - cutting and pasting
         C-k         kill to end line
         C-u         kill to begin line
         M-d         kill to end word
         M-delete    kill to begin word
         C-y         yank kill-ring
       - completion
         M-?         Display list completions
         M-*         insert all completions
       - programmable completion
         set | less

       : history of command
       - By default, bash stores the last *five hundred* commands you have entered
       - view the contents of the history
         [me@linuxbox ~]$ history | less
       - filter history command
         [me@linuxbox ~]$ history | grep /usr/bin
       - history epansion
         !!          repeat last command
         !number     repeat item number
         !string     repeat item starting with string
         !?string    repeat last command item containing string

       : script [file]
       : be used to record an entire shell session and store it in a file
****** permission                                                               :code:
       : id
       : display user identity
       Fedora and Ubuntu user accounts

       : read, write and execute
       The first ten characters of the listing are the file attributes
       the first one of ten file attributes is access rights to files
       The remaining nine characters of the file attributes
         called the owner, the group, and the world permissions

       : chmod
       To change the mode (permissions) of a file or directory
       chmod supports three distinct ways of specifying mode changes
         octal number representation
         three octal digits
         symbolic representation

       : umask
       control the default permissions given to a file when it is created
         it uses octal notation to express
         a mask of bits to be removed from a file's attributes
         (where a 1 appears in the binary value
            the corresponding attrubute is unset)

       : alternate identity
       There are three ways to take on an alternate identity
         Log out and log back in as the alternate user
         su
         sudo

       : chown
       change the owner and group owner of a file or directory
       chown [[owner]:[group]] file...
       argument example

       : chgrp
       change group owner of a file or directory

       : share directory usecase
       To make this directory sharable

       : passwd
       setting passwords for yourself
         and for other users if you have access to superuser privileges
       passwd [user]
****** process                                                                  :code:
       : display process
       : ps
       Report a snapshot of current processes
       : top
       the top program displays a continuously updating (every 3 seconds)
         display of the system processes listed in order of process activity
       : C-c
       aske the program to terminate

       : control process
       : &
       To launch a program so that it is immediately placed in the background
       : jobs
       see the background program list
       : fg
       To return a process to the foreground
       : kill
       to “kill” programs
       common signals
***** configuration file and shell environment
****** shell environment                                                        :code:
       : printenv
       Print part or all of the environment

       : set
       Set shell options

       : export
       Export environment to subsequently executed programs

       : alias
       Create an alias for a command

       : how to create (modify) shell environment
       Startup Files For Login Shell Session
       Startup Files For Non-Login Shell Sessions
       .bash_profile
       PATH variable
       source
****** vi
       : common operator
       [me@linuxbox ~]$ vi  =# start=
       :q   =# exit=
       :q!  =# force exit=
       :w   =# written to hard drave=
       : cursor movement
       C-f  =# down one page=
       C-b  =# up one page=
       : text deletion
       3x   =# current charaacter and the next two characters=
       : join line together
       J
       : search
       f    =# search within a line=
       /    =# search entire file, type n and the cursor will move to match=
       : replace
       :%s/Line/line/g
        %   =# specifies the range of lines=
        g   =# global=
****** the shell prompt                                                           :[[http://billie66.github.io/TLCL/book/chap14.html][custom shell prompt]]:
***** common task and basic tool
****** package management
       Debian style (.deb)    Debian Ubuntu
       Red Hat style (.rpm)   Fedora CentOS
****** networking system
       when it comes to networking
         there is probably nothing that cannot be done with linux
         linux is used to build all sorts of networking systems and appliances
           including firewalls, routers, name servers, NAS boxes and on and on
       : ping
       send an ICMP ECHO_REQUEST to network hosts
       even if you're not the system administrator
         it's often helpful to examine the performance and operation of a network
       NOTE
       it is possible to configure most network devices to ignore these packets
         this is usually done for security reasons
           to partially obscure a host from potential attacker

       : traceroute
       print the route packets trace to a network host
       the traceroute program (some systems use the similar tracepath program instead)
         display a listing of all the "hops" network traffic
         takes to get from the local system to a specified host
       : netstat
       print network connections
             routing tables
             interface statistics
             masquerade connecttions
             and multicast memberships
       : ftp
       internet file transfer program
       : wget
       non-interactive network downloader
       : ssh
       OpenSSH SSH client (remote login program)
****** find file
       : locate
       find files by pathnames

       : find
       search for files based on a variety of attrubutes
       : logical operator
       even with all the tests that find provides
         we may still need a better way to describe the logical relationships
         between the tests
       : predefined actions
       find allows actions to be performed based on the search results
       : user-defined actions
       in addition to the predefined actions, we can also invoke arbitrary commands
       : combine the results of the search

       : xargs
       build and execute command lines from standard input
       : dealing with funny filenames
       unix-like systems allow embedded spaces (newlines) in filenames
         this cause problems for programs like xargs
           that construct argument lists for other programs

       : the find practical use
       : touch
       change file times
       : stat
       display file or file system status
       : find options
****** compile program
       : histiry of programming language
       how is the programming language evolution

       : interpreted program and compiled program
       compare the running speed of interpreted program and compiled program

       : compiler a gnu c program
       : |- gcc
       before compile something, we need a C compiler
       : |- source code
       create a directory for our source code named src
         and using the get command within ftp
           we copy the file from the ftp server to the local machine
       : |- unpack
       once the tar file is doownloaded, use tar to unpack it
       : |- source tree
       unpacking the tar file results in the creation of a new directory
         which contains many files from source tree
       :    |- GNU Project file
       :    |- .c file
       :    |- .h file
       : |- build code
       :    |- ./configure
       output the message of tests and configure the build
       :    |- make
       using the contents of Makefile to guide its actions
       :    |- make install
       install the final product in a system directory for use
** c
*** PROJECT unix环境高级编程 advanced programming in the unix environment
**** question record
***** include apue.h header
      cp ./apue.3e/include/apue.h /usr/local/include =# NOTE: not directory copy to /usr/include=
**** unix基础知识 unix system overview
***** 引言 introduction
      本书集中阐述不同unix操作系统所提供的服务
      The focus of this text is to describe the services provided by various versions of the UNIX operating system
***** 体系结构 architecture
    - 内核 kernel
      an operating system can be defined as the software, we call this software the kernel
    - 系统调用 system call
      The interface to the kernel is a layer of software called the system calls
    - 公用函数库 libraries of common functions
      Libraries of common functions are built on top of the system call
    - 外壳 shell
      The shell is a special application that provides an interface for running other applications.
    - 应用程序 system utilities
      In a broad sense, an operating system consists of the kernel and all the other software that makes a computer useful and gives the computer its personality

[P] architecture of the unix operating system
***** 登陆 logging in
****** 登陆名 login name
       - 口令文件 password file
         When we log in to a UNIX system, we enter our login name, followed by our password
         The system then looks up our login name in its password file, usually the file /etc/passwd
         If we look at our entry in the password file, we see that *it’s composed of seven colon-separated fields*:
         =the login name | encrypted password | numeric user ID (205) | numeric group ID (105) | a comment field | home directory (/home/sar) | and shell program (/bin/ksh)=
               =1                   2                     3                        4                   5                      6                             7=
         =sar:x:205:105:Stephen Rago:/home/sar:/bin/ksh=
          =1  2  3   4       5           6        7=
****** shells
       - shell是一个命令行解析器
         Once we log in and then we can type commands to the shell program
         A shell is a command-line interpreter that reads user input and executes commands
         The user input to a shell is normally from the *terminal* (an interactive shell) or sometimes from a file (called a *shell script*).

         [T] conmmon shells used on unix systems
       - shell版本历史
***** 文件和目录 files and directories
****** 文件系统 file system
       - 根目录 root directory
         The UNIX file system is a hierarchical arrangement of directories and files. Everything starts in the directory called root, whose name is the single character /
       - 目录 directory
         A directory is a file that contains directory entries
         each directory entry containing a filename along with a structure of information describing the attributes of the file.
         The attributes of a file are the size of the file,
                                      the owner of the file,
                                      permissions for the file (whether other users may access this file),
                                      and when the file was last modified
****** 文件名 filename
       - 组成文件名的字符 recommends restricting filenames to consist of the following characters
         a~z A~Z      letter
         0~9          number
         .            period
         -            dash
         _            underscore
         .            current directory
         ..           parent directory
       - 当前目录和父目录 current directory and parent directory
         Two filenames are *automatically created* whenever a new directory is created: . (called dot) and .. (called dot-dot)
       : NOTE
       - 斜线和空字符 slash and the null character
         The only two characters that *cannot appear in a filename* are the slash character (/) and the null character
         The slash separates the filenames that form a pathname
         and the null character terminates a pathname
****** 路径名 pathname                                                          :ATTACH:
       :PROPERTIES:
       :Attachments: ls.c
       :ID:       34688ED3-CE5E-45B1-A2AE-FD4134A5E0E8
       :END:
       - 路径名 pathname
         A sequence of one or more filenames, separated by slashes and optionally starting with a slash, forms a pathname
       - 绝对路径 absolute pathname
         A pathname that *begins with a slash* is called an absolute pathname
       - 相对路径 relative pathname
         Relative pathnames refer to files *relative to the current directory*

       - ls command [C]
         - 联机手册 manuals online
           man l ls
           man -sl ls
         - 编译c源文件 If the source file is named myls.c, we compile it into the default a.out by running
           $ cc myls.c
           $ ./a.out /dev
           : NOTE
           the C compiler is gcc. Here, cc is usually linked to gcc
****** 工作目录 working directory
       当前目录
****** 起始目录 home directory
       When we log in, the working directory is set to our home directory
***** 输入和输出 input and output
****** 文件描述符 file descriptors
       - 标识特定进程正在访问的文件
         File descriptors are normally small non-negative integers that the kernel uses to *identify the files accessed by a process*
****** 标准输入 标准输出和标准错误 Standard Input, Standard Output, and Standard Error
       - 每当运行一个新程序 所有的shell都为其打开标题所提到的3个描述符
         By convention, all shells open three descriptors whenever a new program is run: standard input, standard output, and standard error
       - 3个描述符默认都链接向终端
         If nothing special is done, as in the simple command
           ls
         then all three are connected to the terminal
       - 能重定向到某个文件
         executes the ls command with its standard output redirected to the file named file.list.
           ls > file.list
****** 不带缓冲的I/O unbuffered I/O                                             :ATTACH:
       :PROPERTIES:
       :Attachments: stdin_stdout.c
       :ID:       A9124B15-00F0-4176-B90C-B89FF3BF74A3
       :END:
       : Unbuffered I/O is provided by the functions *open, read, write, lseek, and close*
       : These functions all work with file descriptors
       - copies any regular file on a UNIX system
         - Copy standard input to standard output [C]
         - compile the program into the standard name (a.out) and execute it to the file data
           : standard input is the terminal, standard output is redirected to the file data, and standard error is also the terminal
           : If this output file doesn’t exist, the shell creates it by default
           : can use the end-of-file character (usually Control-D) to stop it
           ./a.out > data
         - the file named infile will be copied to the file named outfile
           ./a.out < infile > outfile
****** 标准I/O standard I/O
       : The standard I/O functions provide a buffered interface to the unbuffered I/O functions
       : The most common standard I/O function is *printf*
       - copies any regular file on a UNIX system
         - Copy standard input to standard output, using standard I/O [C]
           =/* apue.h include <stdio.h> */=
           =/* <stdio.h> contains the function prototypes for all the standard I/O functions */=
           =/* <stdio.h> defined the standard I/O constants stdin, stdout and EOF */=
           #include "apue.h"
           int
           main(void)
           {
               int c;  =// Using standard I/O relieves us from having to choose optimal buffer sizes, such as the BUFFSIZE constant=

               while ((c = getc(stdin)) != EOF)  =// if the last byte of input has been read, getc return the constant EOF=
                   if (putc(c, stdout) == EOF)   =// The function getc reads one character at a time, and this character is written by putc=
                       err_sys("output error");
               if (ferror(stdin))
                   err_sys("input error");
               exit(0);
           }
***** 程序和进程 programs and processes
****** 程序 program
       - 磁盘上某个目录中的可执行文件
         A program is an executable file residing on disk in a directory
       - 通过exec函数将程序读入内存 并执行程序
         A program is read into memory and is executed by the kernel as a result of one of the seven exec functions
****** 进程和进程ID processes and process ID                                    :ATTACH:
       :PROPERTIES:
       :Attachments: getpid.c
       :ID:       8D8EA637-AC09-479F-A42F-ADEE04DECB29
       :END:
       - 进程  程序的执行实例
         An executing instance of a program is called a process
         Some operating systems use the term task to refer to a program that is being executed
       - 进程ID  唯一的数字标识符
         The UNIX System guarantees that every process has a unique numeric identifier called the process ID.
         The process ID is always a non-negative integer
         - Print the process ID [C]
         - compile this program into the file a.out and execute it
           $ ./a.out
           hello world from process ID 851
           $ ./a.out
           hello world from process ID 854
****** 进程控制 process control                                                 :ATTACH:
       :PROPERTIES:
       :Attachments: execute_cmd.c
       :ID:       BABB93D5-2F2A-400F-AF0D-129AF5372E25
       :END:
       : There are three primary functions for process control: fork, exec, and waitpid
       - Read commands from standard input and execute them [C]
       - run the program, use % refer to execute line
         $ ./a.out
         % date
         Sat Jan 21 19:42:07 EST 2012 % who
         sar console Jan 1 14:59 sar ttys000 Jan 1 14:59 sar ttys001 Jan 15 15:28 % pwd
         /home/sar/bk/apue/3e
         % ls
         Makefile
         a.out
         shell1.c
         % ˆD
         $
****** 线程和线程ID threads and thread IDs
       - 线程 某一时刻执行一组机器指令
         Usually, a process has only one thread of control—one set of machine instructions executing at a time
         Some problems are easier to solve when more than one thread of control can operate on different parts of the problem
       - 进程内所有线程共享进程属性
         All threads within a process share the same address space, file descriptors, stacks, and process-related attributes
         Because they can access the same memory, the threads need to *synchronize access* to shared data among themselves to avoid inconsistencies
       - 线程ID只在所属的进程内起作用
         Thread IDs, however, are local to a process. A thread ID from one process has no meaning in another process
***** 出错处理 error handling
    - 出错返回负值
      When an error occurs in one of the UNIX System functions, a negative value is often returned
    - errno显示错误信息
      the integer errno is usually set to a value that tells why the error happened
      - The file <errno.h> defines the symbol errno and constants for each value that errno can assume
        For example, if errno is equal to the constant EACCES, this indicates a permission problem
      - 局部errno
        - each thread needs its own local copy of errno to prevent one thread from interfering with another [C]
          extern int *__errno_location(void);
          #define errno (*__errno_location())
      : NOTE
      - There are *two rules* to be aware of with respect to errno
        First, its value is *never cleared by a routine if an error does not occur*
          Therefore, we should examine its value only when the return value from a function indicates that an error occurred
        Second, the value of errno is *never set to 0* by any of the functions, and none of the constants defined in <errno.h> has a value of 0
    - 出错函数
      - *strerror* function
        #include <string.h>
        char *strerror(int errnum);  =// This function maps errnum, which is typically the errno value, into an error message string and returns a pointer to the string=
      - *perror* function
        #include <stdio.h>
        void perror(const char *msg);  =// The perror function produces an error message on the standard error, based on the current value of errno, and returns=
      - Demonstrate strerror and perror [C]
        #include "apue.h"
        #include <errno.h>

        int
        main(int argc, char *argv[])
        {
            fprintf(stderr, "EACCES: %s\n", strerror(EACCES));
            errno = ENOENT;
            perror(argv[0]);  =// argv[0], whose value is ./a.out, as the argument to perror. this program is executed as part of a pipeline[fn:pipeline]
            exit(0);
        }
      - compile the code
        $ ./a.out
        EACCES: Permission denied
        ./a.out: No such file or directory
    - 出错恢复 error recovery
      The typical recovery action for a resource-related nonfatal error is to delay and retry later

[fn:pipeline] prog1 < inputfile | prog2 | prog3 > outputfile  =//we are able to tell which of the three programs generated a particular error message=
***** 用户标识 user identification
      - 用户ID
        识别不同用户
        不能更改
        - 超级用户
          We call the user whose user ID is 0 either root or the superuser.
          The entry in the password file normally has a login name of root, and we refer to the special privileges of this user as superuser privileges
      - 组ID
        系统分配
        - 共享资源
          Groups are normally used to collect users together into projects or departments.
          This allows the sharing of resources, such as files, among members of the same group.
          we can set the permissions on a file so that all members of a group can access the file, whereas others outside the group cannot.
      - [C]打印用户ID和组ID
        #include "apue.h"
        int
        main(void)
        {
             printf("uid = %d, gid = %d\n", getuid(), getgid());
             exit(0);
        }

        $ ./a.out
        uid = 205, gid = 105
***** 信号 singnals
      - 发送信号处理进程
        Many conditions generate signals. Two terminal keys,
          called the interrupt key— often the DELETE key or Control-C—and the quit key—often Control-backslash—are used to interrupt the currently running process.
          Another way to generate a signal is by calling the kill function
      - singnal函数
        - [C]read commands from standard input and execute them [En 53]
***** 时间值 time values
      - 进程时间 process time
        - clock time
          The clock time, sometimes called wall clock time, is the amount of time the process takes to run,
            and its value depends on the number of other processes being run on the system
        - user cpu time
          The user CPU time is the CPU time attributed to user instructions
        - system cpu time
          - measure
            $ cd /usr/include
            $ time -p grep _POSIX_SOURCE */*.h > /dev/null
***** 系统调用和库函数 system calls and library functions
      - 系统调用
        - c语言最小接口 内核入口
          All operating systems provide service points through which programs request services from the kernel.
          All implementations of the UNIX System provide a well-defined, limited number of entry points directly into the kernel called /system calls/
      - 库函数
        - c语言复杂接口 调用1或多个内核调用
          Section 3 of the UNIX Programmer’s Manual defines the general-purpose library functions available to programmers.
          These functions aren’t entry points into the kernel, although they may invoke one or more of the kernel’s system calls
**** unix标准及实现 UNIX Standardization and Implementations
***** unix标准化 unix standardization
****** ISO C
       - 跨平台C标准
         the ISO C standard is to provide portability of conforming C programs to a wide variety of operating systems, not only the UNIX System
       [T] Headers defined by the ISO C standard En 61
****** IEEE POSIX
       - 可移植操作系统借口
         POSIX standard specifies an interface and not an implementation
         no distinction is made between system calls and library functions.
         All the routines in the standard are called functions
         Standards are continually evolving
       [T] Required headers defined by the POSIX standard (En 63)
       [T] XSI option headers defined by the POSIX standard (En 64)
****** Single UNIX Specification
**** 文件I/O file I/O
     - 不带缓冲的I/O
       The term unbuffered I/O means that each read or write invokes a system call in the kernel
***** 文件描述符 file descriptors
      - 引用文件
        A file descriptor is a non-negative integer
        When we open an existing file or create a new file, the kernel returns a file descriptor to the process
        When we want to read or write a file, we identify the file with the file descriptor that was returned by open or creat as an argument to either read or write
      - 幻数
        the magic numbers 0, 1, and 2
          should be replaced in POSIX-compliant applications with the symbolic constants STDIN_FILENO, STDOUT_FILENO, and STDERR_FILENO to improve readability.
        These constants are defined in the <unistd.h> header
      - 允许每个进程打开文件数
        the limit is essentially infinite,
          bounded by the amount of memory on the system, the size of an integer, and any hard and soft limits configured by the system administrator
**** 文件和目录 files and directories
***** 函数stat、fstat、fstatat和lstat  stat, fstat, fstatat, and lstat Functions :ATTACH:
      :PROPERTIES:
      :Attachments: stat_fstat_fstatat_lstat.c
      :ID:       6E93C1CB-BF50-4849-BFF4-084E9C51CF95
      :END:
      - 提供路径 显示文件信息
        that most members of the stat structure are specified by a primitive system data type
        The biggest user of the stat functions is probably the ls -l command, to learn all the information about a file
**** 标准I/O库 standard I/O library
     标准I/O库处理细节
***** 流和file对象 streams and file objects
      - file对象指针引用流
        When a file is opened, a file descriptor is returned, and that descriptor is then used for all subsequent I/O operations
        With the standard I/O library, the discussion centers on streams
        When we open or create a file with the standard I/O library, we say that we have associated a stream with the file

        With the ASCII character set, a single character is represented by a single byte. With international character sets, a character can be represented by more than one byte
        Standard I/O file streams can be used with both single-byte and multibyte (‘‘wide’’) character sets

        fwide function can be used to set a stream's orientation [C]
**** 系统数据文件和信息 system data files and information
***** 引言 introduction
      the portable interface to these data files are the subject of this chapter
***** 口令文件 password file
**** 进程环境 process environment
***** main函数 main function
      a C program starts execution with a function called /main/
      the prototype for the main function [prototype]

      - exec functions
        _a special start-up routine_ is called before the main function
        the executable program specifies this routine as the _starting address_
        this is set up by the link editor invoked by the C compiler
        used for taking values from kernel
                 --the command-line argument and the environment)--
***** 进程终止 process termination
**** 进程控制 process control
***** 引言 introduction
      the creation of new processes
      program execution
      process termination
      various IDs that are the property of the process
      how affected by the process control primitives
***** 进程标识 process identifiers
**** 进程关系 process relationships
***** 引言 introduction
      process groups in more detail
      the concept of sessions that was introduced by POSIX.1
      the relationships between the login shell that is invoked for us when we log in
        and all the processes that we start from our login shell
***** 终端登录 terminal logins
**** 信号 signals
***** 引言 introduction
      signals are software interrupts
      signals provide a way of handling asynvchronous events
        a user at a terminal typing the interrupt key to stop a program
        or the next program in a pipeline ternimating prematurerly

      start with an overview of signals and a description of what each sugnal is normally used for
      then look at the problem wih earlier implementations
      it is often important to understand what is wrong with an implementation
        before seeing how to do thing correctly
***** 信号概念 signal concepts
**** 线程 threads
***** 引言 introduction
      look inside a process further to see how we can use multuple _threads of control_
        to perform multiple tasks within the environment of a single process
      look at the synchronization mechanisms available to prevent multiple threads
        from viewing inconsistencies int their shared resouurces
***** 线程概念 thread concept
**** 线程控制 thread control
***** 引言 introduction
      how threads can keep data private from other threads in the same process
      how some process-based system calls interact with threads
***** 线程限制 thread limits
**** 守护进程 daemon processes
***** 引言 introduction
      daemons are processes that live for a long time
        they are often started when the system is bootstrapped and terminate
        only when the system is shut down

      because they don't have a controlling terminal
        we say that they run in the background

      UNIX systems have numerous daemons that perform day-to-day activities
***** 守护进程的特征 daemon characteristics
**** 高级I/O advanced I/O
***** 引言 introduction
      cover numerous topics and functions that we lump under the term advanced I/O
***** 非阻塞I/O nonblocking I/O
**** 进程间通信 interprocess communication
***** 引言 introduction
      summary of UNIX system IPC [T]

      classical IPC (interprocess communication)
***** 管道 pipes
**** 网络IPC: 套接字 network IPC: sockets
***** 引言 introduction
      TCP/IP protocol suite in network IPC
***** 套接字描述符 socket descriptors
**** 高级进程间通信 advanced IPC
***** 引言 introduction
      the UNIX domain socket
        with this form of IPC, we can pass open file descriptors
        between processes running on the same computer system
        server processes can associate names with their file descriptors
        and client processes running on the same system can use these names
          to rendezvous with the servers
***** UNIX域套接字 UNIX domain socket
**** 终端I/O terminal I/O
***** 引言 introduction
      the POSIX.1 terminal functions and some of the platform-specific additions
***** 综述 overview

**** 伪终端 pseudo terminals
***** 引言 introduction
***** 概述 overview
**** 数据库函数库 a database library
***** 引言 introduction
      develop a simple, multiuser databse library of C functions
        that any program can call to fetch and store records in a database
***** 历史 history
**** 与网络打印机通信 communicating with a network printer
***** 引言 introduction
      develop a program that can communicate with a network printer
***** 网络打印协议 the internet printing protocol
**** 附录A 函数原型 appendix A function prototypes [En 879]
     the arguments to a functions
     the return value
     which headers need to be included
       to obtain the definitions of any special constants
**** 附录B 其他源代码 appendix B miscellaneous source code [En 929]
***** 本书使用的头文件 our header file
      the <apue.h> include
        <stdio.h> <stdlib.h> (for the exit function prototype)
        <unisted.h> (for all the standard UNIX function prototypes)
        <string.h>
**** 索引 index [En 989]
*** WAITING c程序设计语言 The C Programming Language
    CLOSED: [2017-04-16 日 14:10]
**** 基础 basic
***** 编译 加载 运行 compile load run
      *.c
      cc *.c
      *.out
***** 转义序列 escape sequence
      \n  newline
      \t  tab
      \b  backspace
      \"  double quote
      \\  backslash
***** 注释 comment
      /* ...
         ... */
***** 变量 variable
      int     16位   －32768～32767
      float   32位    10^-38~10^38
      char    single byte
      short   short integer
      long    long integer
      double  double-precision floating
***** 公式 formula
      5*18/9 = 10
      5/9*10 = 0     5/9 = 0
***** 格式化输出 format output
      printf("%3d %6d\n", number, string);   打印区域内右对齐
      %d     print as decimal integer
      %6d    ... at least 6 characters wide
      %f     print as floating point
      %6f    ... at least 6characters wide
      %.2f   ... 2 characters after decimal point
      %6.2f  ... 6 wide and 2 after deciaml point
***** for语句 the for statement
      for (  fahr = 0;      fahr <= 300;     fahr = fahr + 20  )
          initialization    control loop      increment step
***** 符号常量 symbolic constants
      #define name replacementlist

      #define LOWER 0
      #define UPPER 300
      #define STEP  20
      ...
      for( fahr = LOWER; fahr <= UPPER; fahr =fahr + STEP)
      ...
***** 字符输入／输出 character input and output
      getchar();
      putchar();
***** 文件复制 file copying
      : /* copy input to output */
      int c;
      while((c = getchar()) != EOF)
        putchar(c);
***** 字符计数 character counting
      : /* count characters in input */
      : /* while version */
      long nc;
      nc = 0;
      while(getchar() != EOF)
        ++nc;
        printf("%ld\n", nc); // ld
      : /* for version */
      double nc;
      for(nc = 0; getchar( != EOF; ++nc))
        ;
      printf("%.0f\n", nc); // .0
***** 行计数 line counting
      : /* count lines in input */
      int c, nl;
      nl = 0;
      while((c = getchar()) != EOF)
        if (c == '\n') // == '\n' ascii 10
           ++nl; // ++
      printf("%d\n", nl);
***** 单词计数 word counting
      #define IN  1 // inside a word
      #define OUT 0 // outside a word
      ...
      : /* count lines, words, and characters in input */
      int c, nl, nw, nc, state;
      state = OUT;
      nl = nw = nc = 0; // nl = (nw = (nc = 0))
      while ((c = getchar()) != EOF){
        ++nc;
        if (c == '\n')
          ++nl;
        if (c == ' ' || c == '\n' || c = '\t') // && precedence is just higher than ||
          state = OUT;
        else if (state == OUT){ // else if
          state = IN;
          ++nw;
        }
      }
***** 数组 arrays
      : /* count digits, white space, others */
      : int ndigit[10]; // array subscripts always start at 0 in c
      if (c >= '0' && c <= '9')
        ++ndigit[c - '0']; // c - '0'  the numeric value of that digitis
***** 函数 functions
      int power(int m, int n);
      : /* test power function */
      main(){
        ...
        return 0;
      }
      : /* power  base^n */
      int power(int base, int n)
      {
        int i, p;
        p = 1;
        for (i = 1; i <= n; ++i)
          p = p * base;
        return p;
      }
***** 参数-传值调用 arguments-call by value
      : /* power  pass the n value */
      int power(int base, int n)
      {
        int p;
        for (p = 1; n > 0; --n)
          p = p * base;
        return p;
      }
***** 字符数组 character arrays
      #define MAXLINE 1000  =// maximum input line length=
      : /* print the longest input line */
      int getline(char line[], int maxline);
      void copy(char to[], char from[]);  =// void  return nothing=
      - main()
        {
          int len;  =// current line length=
          int max;  =// maximum length seen so far=
          char line[MAXLINE];     =// current input line=
          char longest[MAXLINE];  =// longest line saved here=

          max = 0;
          while ((len = getline(line, MAXLINE)) > 0)
             if (len > max){
                max = len;
                copy (longest, line);
             }
          if (max > 0)
             printf("%s", longest);
          return 0;
        }
      : /* getline:  read a line into s, return length */
      - int getline(char s[], int lim)  =// s[]  its size is set in main.getline=
        {
          int c, i;
          for (i = 0; i < lim-1 && (c=getchar()!=EOF) && c!='\n'; ++i)
              s[i] = c;
          if (c == '\n') {
             s[i] = c;
             ++i;
          }
          s[i] = '\0';  =// '\0' null character, mark the end of the string of characters=
          return i;
        }
      : /* copy:  copy 'from' into 'to'; assume to is big enough */
      - void copy(char to[], char from[])
        {
          int i;
          i = 0;
          while ((to[i] = from[i]) != '\0')
            ++i;
        }
***** 外部变量与作用域 external variables and scope
      : <<header>>
      #include <stdio.h>

      #define MAXLINE 1000    =/* maximum input line size */=

      : <<external variable>>  are globally accessible, can be used to to communicate data between functions
      : NOTE
      : external variables can be changed in unexpected and even inadvertent ways, and the program is hard to modify
      int max;                =/* maximum length seen so far */=
      char line[MAXLINE];     =/* current input line */=
      char longest[MAXLINE];  =/* longest line saved here */=

      int getline(void);
      void copy(void);

      =/* print longest input line; specialized version */=
      - main()
        {
            : <<automatic variable>> (or call local variable)  come and go with function invocation
            :                                              they do not retain their values from one call to the next and must be explicitly set upon each entry
            int len;
            max = 0;

            : <<extern>>  the keyword define the variable refer to the [[external variable]]
            : NOTE
            : the extern declaration can be omitted
            : if the definition of the [[external variable]] occurs in the source file before its use in a particular function
            : or to collect extern declarations of variables and functions in a separate file, called a [[header]], that is included by #include at the front of each source file.
            extern int max;
            extern char longest[];

            while ((len = getline()) > 0)
                if (len > max) {
                    max = len;
                    copy();
                }
            if (max > 0) =/* there was a line */=
                printf("%s", longest);
            return 0;
        }
      =/* getline:  specialized version */=
      - int getline(void)
        {
            : [[automatic variable]]
            int c, i;

            : [[extern]]
            extern char line[];
            for (i = 0; i < MAXLINE - 1
                && (c=getchar)) != EOF && c != '\n'; ++i)
                   line[i] = c;
            if (c == '\n') {
               line[i] = c;
               ++i;
            }
            line[i] = '\0';
            return i;
        }
      =/* copy: specialized version */=
      - void copy(void)
        {
            : [[automatic variable]]
            int i;

            : [[extern]]
            extern char line[], longest[];

            i = 0;
            while ((longest[i] = line[i]) != '\0')
               ++i;
        }
**** 类型 运算符 与表达式 types, operators and expressions
***** 变量名 variable names
      - 变量名
        the names of variables are made up of letters and digits; the first character must be a letter; The underscore '_' counts as a letter;
        Don't begin variable names with underscore, since library routines often use such names
        since library routines often use such names
        Upper and lower case letters are distinct, so x and X are two different names.
      - 常量名
        symbolic constants must be all upper case
      - 关键字
        Keywords like if, else, int, float, etc., are reserved: you can't use them as variable names. They must be in lower case
***** 数据类型及长度 data types and sizes
      - 字符型
        char      a single byte, capable of holding one character in the local character set
      - 整型
        int       an integer, typically reflecting the natural size of integers on the host machine
      - 单精度浮点型
        float     single-precision floating point
      - 双精度浮点型
        double    double-precision floating point
      - 限定符
        short     16 bit int or float or others (depends implementing on machine)
        long      32 bit int or float or others (depends implementing on machine)
        unsigned  always positive or zero (8 bit  between 0~255)
        signed    positive and negtive (8 bit  between -127~128)
***** 常量 constants
      - 整型常量
        1234 is an int, *A long constant* is written with a terminal l (ell) or L, as in 123456789L
        *Unsigned constants* are written with a terminal u or U, and the suffix ul or UL indicates unsigned long
        A leading 0 (zero) on an integer constant means *octal* (037 equal 31 decimal)
        a leading 0x or 0X means *hexadecimal* (0xFUL equal 15 decimal)
      - 浮点数常量
        contain a decimal point (123.4) or an exponent (1e-2) or both
        The suffixes f or F indicate a float constant; l or L indicate along double
      - 字符常量
        A character constant is an integer, written as one character within single quotes, such as 'x'
        in the *ASCII character* set the character constant '0' has the value 48, which is unrelated to the numeric value 0
        Character constants participate in *numeric operations* just as any other integers, although they are most often used in *comparisons with other characters*
        - The complete set of *escape sequences* is
          \0    octal digits (like '\013')
          \x    hexadecimal (like '\xb')
          \a    alert(bell) character
          \b    backspace
          \f    formfeed
          \r    carriage return
          \t    horizontal tab
          \v    vertical tab
          \\    backslash
          \?    question mark
          \'    single quote
          \"    double quote
          \0    null character
      - 常量表达式
        A constant expression is an expression that involves only constants
        Such expressions may be evaluated at during compilation rather than run-time, and accordingly may be used in any place that a constant can occur
            #define MAXLINE 1000
            char line[MAXLINE+1];
      - 字符串常量
        A string constant, or string literal, is a sequence of zero or more characters surrounded by double quotes
            "I am a string"
            "" =/* the empty string */=
        The quotes are not part of the string
        The same escape sequences used in character constants apply in strings; \" represents the double-quote character
        String constants can be *concatenated* at compile time:
            "hello, " "world"
            "hello, world"
        - The standard library function *strlen(s)*
          : strlen and other string functions are declared in the standard header <string.h>
          #include <string.h>
          =/* strlen:  return length of s */=
          int strlen(char s[])
          {
              int i;
              : returns the length of its character string argument s, excluding the terminal '\0'
              while (s[i] != '\0')
                     ++i;
              return i;
          }
        : NOTE
        'x' is not the same as "x"
      - 枚举常量
        the enumeration constant. An enumeration is a list of constant integer values
        The first name in an enum has value 0, the next 1, and so on
            enum months { JAN = 1, FEB, MAR, APR, MAY, JUN,
                   JUL, AUG, SEP, OCT, NOV, DEC };
                         // FEB = 2, MAR = 3, etc.
        : NOTE
        Names in different enumerations must be distinct. Values need not be distinct in the same enumeration
        : TIP
        an alternative to #define with the advantage that *the values can be generated* for you
        enumeration variables *offer the chance of checking* and so are often better than #defines
** c++
*** PROJECT C++ Primer
**** contents (En 4)
**** getting started
***** writing a simple c++ program                                              :code:
      : compiling and executing our program
      different compilers use different suffix conventions
        the most common include .cc, .cxx, .cpp, .cp and .C
      $ CC progn1.cc              # use clang
      $ g++ -o prog1 prog1.cc     # use GNU
      $ ./a.out
      $ echo $?
      0
***** a first look at input / output                                            :code:
      : using the IO library
      : <iostream>
      tell the compiler that we want to use the iostream library
      the name inside angle brackets refers to a header
      : #include
      the name of the header and the #include mustappear on the same line
      all the #include directives for a program at the beginning of the source file
      : writing to a stream
      : <<
      the << output operator takes two operands
        the left-hand operand must be an ostream objects
        the right-hand operand is a value to print
      - the expression is equivalent to
           // we can chain together output requests
           (std::cout << "Enter two numbers:") << std::endl;
           // each operator in the chain has the same object as its left-hand operand
           std::cout << "Enter two numbers:";
           std::cout << std::endl;
      : endl
      which is a special value called a manipulator
      writing endl has the effect of ending the current line
        and flushing the buffer ensures that
          all the output the program is actually written to the output stream
          rather than sitting in memory waiting to be written
      : using names from the standard library
      : std::cout  std::endl
      the prefix std:: indicates that
        the names cout and endl are defined inside the namespace named std
      : reading from a stream
      : >>
      the input operator >> takes
        an istream as its left-hand operand
        and an object as its right-hand operand
      it reads data from the given istream
        and stores what was read in the given object
      our input operation reads two values from std::cin
        storing the first in v1 and the second in v2
      - this expression is equivlent to
        (std::cin >> v1) >> v2;
        std::cin >> v1;
        std::cin >> v2;
      : << v1 + v2
      some operands of output operator are string literals, such as "the sum of"
        ohters are int values, such as v1, v2 and
          the result of evaluating the arithmetic expression v1 + v2
      : output
      Enter two number:
      3 7
      the sum of 3 and 7 is 10
***** a word about comments
      : kinds of comments in c++
      single-line and paired
      : comment pairs do not nest
      : comment out a block of code during debugging
***** flow of control
      statements normally execute sequentially
        programming languages provide various flow-of-control statements
          that allow for more complicated execution paths
****** the while statement                                                   :while.cc:
      a while statement repeatedly executes a section of code
        so long as a given condition is ture
****** the for statement                                                     :for.cc:
****** reading an unknown number of input                                    :reading_unknown_number_of_input.cc:
       : std:cin >> value
       the expression reads the next number from the standard input
         and stores that number in value
       when we use an istream as a condition
         the effect is to test the state of the stream
         if the stream is valid, the stream hasn't encountered an error
         an istream becomes invalid when we hit end-of-file or encounter an invalid input
       : entering an end-of-file
       windows  ctrl-z
       unix     ctrl-d
****** the if statement                                                      :if:
***** introducing classes
      to use a library facility, we must include the associated header
      header files that we write usually have a suffix .h
        but someone use .H, .hpp, .hxx
        the standard library headers typically have no suffix at all
****** the sales_item class
       the purpose of the sales_item class is to represent the total revenue
         number of copies sold, and average sales price for a book
******* reading and writing sales                                               :code:
        : header file
        headers from the standard library are enclosed in angle brackets <>
        those that are not part of the library are enclosed in double quotes ""
        : main
        inside main we define an object, named book
          that we'll use to hold the data that we read from the standard input
******* adding sales_items                                                      :code:
        a example adds two Sales_item objects
        : item1, item2
        we read two inputs and write their sum
        : using file redirection
        assuming our addition program has been compiled
          into an executable file named addItems
          this command will read transactions from a file named infile
            and write its output to a file named outfile in the current directory
****** a first look at member funtions                                          :code:
       our program that adds two Sales_item should check
         whether the objects have the same ISBN
       : item1.isbn()
       a member function is a funtion that is defined as part of a class
         member function are sometimes referred to as methods
       this operator . means "the isbn member of the object named item1"
       the call operator is a pair of parentheses
         that enclose a (possibly empty) list of arguments
***** the bookstore program                                                     :code:
**** the basics
***** variables and basic types
****** primitive build-in types
******* arithmetic types
        the minimum size of arithmetic types (En 61)
        the basic character type is char
          a char is guaranteed to be big enough to hold numeric values
            corresponding to the charaters in the machine's basic character set
        an int will be at least as large as short
        a long at least as large as integer
        and long long at least as large as long
        : signed and unsigned types
        the integral types may be signed or unsigned type
          represents only values greater than or equal to zero
        the types int, short, long and long long are all signed
          we obtain the corresponding unsigned type by adding unsigned to the type
        there are three distinct basic character types
          char, signed char, and unsigned char
          in particular, char is not the same type as signed char
          an 8-bit unsigned char can hold the values from 0 through 255 inclusive
        : deciding which type to use
        use an unsigned type when you know that the values connot be negative
        use =int= for integer arithmetic
          =short= is usually too smaall
          in practice, long often has the same size as int
          if your data values are larger than the minimum guaranteed size of an int
            then use =long long=
        do not use plain =char= or =bool= in arithmetic expressions
          use them only to hold characters or truth values
          because char is unsigned on some machines
          if you need a tiny integer
            explicitly specify either signed char or unsigned char
        use =double= for floating-point computations
          =float= usually does not have enough precision
          and the cost of double-precision calculations versus single-precision
            is negligible
          the precision offered by =long double= usually is unnecessary
            and often entails considerable run-time cost
******* type conversions                                                        :code:
        : assign one arithmetic type to another
        nonbool -> bool
          the result is false if the value is 0 and true otherwise
        bool -> arithmetic types
          the result is 1 if the bool is true and 0 if the bool is false
        floating-point -> integer
          the value is truncated
          the value that is stored is the part before the decimal point
        integer -> floating-point
          the fractional part is zero
          precision may be lost
        out-of-range value -> unsigned type
          the result is the remainder of the value
            modulo the number of values the target type can hold
            unsigned char can hold values from 0 through 255
              the -1 modulo 256 gives the values 255
        out-of-range value -> signed type
          the result is undefined
          the program might crash or it may produce garbage values
        : avoid undefined and implementation-defined behavior
        assuming that the size of an int is a fixed and known value
          such programs are said to be nonportable
          when the program is moved to another machine
            code that relied on implementation-defined behavior may fail
        : expression involving unsigned types
        converting a negative number to unsigned behaves exactly as if
          we had attempted to assign that negative value to an unsigned object
          the value "wraps around" as described above
            (add negative sign to unsigned value)
        assuming 32-bit ints, the result of --u, when u is 0, is 4294967295
          one way to write this loop is to use a =while= instead of a =for=
        : NOTE
        don't mix signed and unsigned types
******* literals                                                                :code:
        a value, such as 42, is knnown as a literal because its value self-evident
          every literal has a type
        : integer literals
        : floating-point literals
        : character and character string literals
        the compiler appends a null character '\0' to every string literal
          thus, the literal 'A' represents the letter A and the null character
        : multiline string literal
        two string literals that appear adjacent to one another
          and that are separated only by spaces, tabs, or newline are
            concatenated into a single literal
        : escapse sequence
        some characters, such as backspace or control characters are nonprintable
        other characters (single and double quotation marks, and backslash)
          have special meaning in the language
          our programs cannot use any of these characters directly
          instead, we use an =escape sequence= to represent such characters
        several escape sequences (En 69)
        we can also write a generalized escape sequence
          which is \x followed by one or more hexadecimal
          or a \ followed by one, two, or three octal digits
        : NOTE
        if a \ is followed by more than three octal digits
          only the first three are associated with the \
          \1234 represent \123 and 4
        \x uses up all the hex digits following it
          \x1234 represent a single, 16-bit character
          because most machines have 8-bit chars
          such values are unlikely to be useful
        : specufying the type of a literal
        the type of specify literals (Cn 63)
        : NOTE
        when you write a long literal, use the uppercase L
          the lowercase letter l is too easily mistaken for the digits 1
        : boolean and pointer literals
        the words =true= and =false= are literals of type =bool=
        we'll have more to say about pointers and nullptr in 2.3.2
****** variables
******* variable definitions                                                    :code:
        a simple variable definition consists of a _type specifier_
          followed by a list of one or more variable names separated by commas
          and ends with a semicolon
        : std::string
        the definition of _book_ uses the std::string library type
        like iostream, string is defined in namespace std
        the string library gives us several ways to initialize string objects
          one of these ways is as a copy of a string literal
          thus, _book_ is initialized to hold the characters _0-201-78345-X_
        : initializer
        an object that is initalized gets the specified value
          at the moment it is created
        Warning
        initialization is not assignment
          initialization happens when a variable is given a value when it is created
          assignment obliterates an object's current value
            and replaces that value with a new one
        : list initialization
        the following four different ways is to define
          an int variable named _units_sold_ and initialize it to 0
        the generalized use of curly braces ({})
          for initialization was introduced as part of the new standard
          this form of initialization is referred to as list initialization
        NOTE
        when use list initialization
          if the initializer might lead to the loss of information
          the compiler will not let us list initialize variables
          for example, the variable _a_ and _b_
            using a long double to initialize an int is likely to lose data
        : default initialization
        when define a variable without an initializer
          the variable is default initialized
          what that default value is depends on the type of the variable
            and may also depend on where the variabel is defined
        NOTE
        object of class type that we do not explicitly initialize
          have a value that is defined by the class
******* variable declarations and definitions                                   :code:
        : separate compilation
        separate compilation lets us split our programs into several files
          each of which can be compiled independently
        when we separate a program into multiple files
          we need a way to share code across those files
          consider std::count and std::cin
            these are objects defined somewhere in the standard library
            yet our programs can use these objects
        to support separate compilation
          C++ distinguishes between declarations and definitions
          a file that wants to use a name
            defined elsewhere includes a declaration for that name
          a declaration makes a name known to the program
          a definition creates the associated entity
        TIP
        we recommend initializing every object of build-in type
          it is not always necessary
          but it is more safer
        : extern
        to obtain a declaration that is not also a definition
          we add the extern keyword and may not provide an explicit initializer
        any declaration that includes an explicit initializer is a definition
        to use a variable in more than one file retuires declarations
          that are separate from the variable's definition
        to use the same variable in multiple files
          we must define that variable in one (and only one) file
          other files that use that variable must declare but not define
        NOTE
        variables must be defined exactly once but can be declared many times
        : static typing
        C++ is a _statically typed_ language
          which means that types are checked at compile time
          the process by which types are checked is referred to as _type checking_
        the type of an object constrains the operations that the object can perform
          in C++, the compiler checks whether the operations we write
            are supported by the types we use
******* identifiers                                                             :code:
        : define variables
        identifiers in C++ can be composed of letters, digits, and the underscore
          the language imposes no limit on the name length
          identififers must begin with either a letter or an underscore
            and also case-sensitive
        the language reserves a set of names, listed in En 78
          these names may not be used as identifiers
          the identifiers we define can not
            contain two consecutive underscores
            begin with an underscore followed immediately by an uppercase letter
            defined outside a function begin with an underscore
        : conventions for variable names
        following thses conventions for naming variables
          can improve the readability of a program
          variable names normally are lowercase--index, not Index or INDEX
          like Sales_item class, we define usually begin with an uppercase letter
          identifiers with multiple words should visually distinguish each word
            for example, student-loan or studentLoan, not studentloan
******* scope of a name                                                         :code:
        each name that is use refers to a specific entity
          a variable, function, type, and so on
        : scope
        a scope is a part of the program in which a name has a particular meaning
          most scopes in C++ are delimited by curly braces
        the same name can refer to different entities in different scopes
          names are visible from the point where they are declared
            until the end of the scope in which the declaration appears
        TIP
        define variables where you first use them
        it is usually a good idea to define an object
          near the point at which the object is first used
        : std namespace scope
        program uses the namespace name _std_
          along with two names from that namespace -- _count_ and _endl_
        : main scope
        the name main--like most names defined outside a function--has global scope
        the name _sum_ is defined within the scope of the block
          that is the body of the _main_ function
          it is accessible from its point of declaration
            throughout the rest of the main function but not outside of it
        : for scope
        the name _val_ is defined in the scope of the _for_ statement
          it can be used in that statement but not elsewhere in main

        : nested scopes
        scopes can contain other scopes
          the contained (or nested) scope is referred to as inner scope
          the containing scope is the outer scope
          names declared in the outer scope can also be redefined in an inner scope
        : global scope
        print the global variable _reused_ and local variable _reused_
        WARNING
        it is almost always a bad idea
          to define a local variable with the same name as a global variable
****** compound types
       a compound type is a type that defined in terns of another type
         (like references and pointers)
       definition the value of compound is more complicate
******* references                                                              :code:
        a reference defines an alternative name for an object
          a reference type "refers to" another type
        : &
        we define a reference type by writing a declarator of the form &d
          where d is the name being declared
        : a reference is an alias
        ordinarily, when we initialize a variable
          the value of the initializer is copied into the object we are creating
        when we define a reference
          instead of copying the initializer's value
          we bind the reference to its initializer
          because there is no way to rebind a reference
            references must be initialized
        NOTE
        a reference is not an object
          instead, a reference is just another name for an already existing object
        because references are not objects
          we may not define a reference to a reference
        after a reference has been defined
          all operations on that reference are actually
            operations on the object to which the reference is bound
        : reference definitions
        we can define multiple references in a single definition
          each identifier that is a reference must be preceded by the & symbol
        the type of a reference and the object to which the reference refers
          must match exactly
        a reference may be bound only to an object
          not to a literal or to the result of a more general expression
******* pointers                                                                :code:
        a pointer is a compound type that "point to" another type, like references
        unlike reference, a pointer is an object in its own right
          pointers can be assigned and copied
          a single pointer can point to several different object over its lifetime
          a pointer need not be initialized at the time it is defined
        : *
        we define a pointer type by writing a declarator of the form *d
          where d is the name being defined
          the * must be repeated for each pointer variable
        : &
        taking the address of an object
          a pointer holds the address of another object
          we get the address of an object by using the address of operator (&)
        NOTE
        this & is not a reference
          because references are not object
          they don't have addresss
          hence, we may not define a pointer to a reference
        : type matched
        the types of the pointer and the object to which it points must match
          because the type of the pointer is used to infer the type of the object
            to which the pointer points
          if a pointer addressed an object of another type
            operations performed on the underlying object would fail
        : pointer value
        the value (the address) stored in a pointer can be in one of four states
          it can point to an object
          it can point to the location just immediately past the end of an object
          it can be a null pointer, indicating that it is not bound to any object
          it can be valid, values other than the preceding three are invalid
        NOTE
        it is an error to copy or otherwise try to access
          the value of an invalid pointer
          this error is one that the compiler is unlikely to detect
        although pointers in cases 2 and 3 are valid
          there are limits on what we can do with such pointers
          because these pointers do not pointer to any object
            we may not use them to access the object to which the pointer points
        : using pointer to access an object
        when a pointer points to an object
          we can use the /dereference operator/ (*) to access that object
        dereferencing a pointer yields the object to which the pointer points
          we can assign to that object assigning to the result of the dereference
          when we assign to *p, we are assigning to the object to which p points
        NOTE
        we may dereference only a valid pointer that points to an object
        : some symbols have multiple meanings
        some symbols, such as & and *
          are used as both an operator in an expression and as part of a declaration
        : null pointers
        a null pointer does not point to any object
          code can check whether a pointer is null before attempting to use it
        the most direct approach is to initialize the pointer using the literal _nullptr_
          nullptr is a literal that has a special type
            that can be converted to any other pointer type
          alternatively, we can initialize a pointer to the literal 0
          older programs sometimes use a preprocessor variable named _NULL_
            which the _cstdlib_ header defines as 0
        TIP
        modern C++ programs generally should avoid using NULL and use nullptr instead
          NULL is a preprocessor variable
          the preprocessor automatically replaces the variable by its value
          hence, initializing a pointer to NULL is equivalent to initializing it to 0
        NOTE
        it is illegal to assign an int vairable to a pointer
          even if the variable's value happens to be 0
        TIP
        initialize all pointers
        under most compilers
          when we use an uninitialized pointer
          the bits in the memory in which the pointer resides are used as an address
          using an uninitialized pointer is a request to access a supposed object
            at that supposed location
          there is no way to distinguish a valid address from an invalid one
            formed from the bits that happen to be in the memory
            in which the pointer was allocted
        : assignment and pointers
        both pointers and references give indirect access to other objects
          however, there are important differences in how they do so
        the most important is that a reference is not an object
          once we have defined a referencem
            there is no way to make that reference refer to a different object
          we always get the object to which the reference was initially bound
        there is no such identity between a pointer and the address that it holds
          when we assign to a pointer, we give the pointer itself a new value
          assignment makes the pointer point to a different object
        it can be hard to keep straight whether an assignment
          changes the pointer or the object to which the pointer points
          the important thing to keep in mind is that
            assignment changes its left-hand operand
        : other pointer operations
        given two valid pointers of the same type
          we can compare them using the equality (==) or inequality (!=) operators
          two pointers hold the smae address if they are both null
        because these operations use the value of the pointer
          a pointer used in a condition or in a comparsion must be a valid pointer
        : void* pointers
        there are only a limited number of things we can do with a void* pointer
          we can compare it to another pointer
          we can pass it to or return it from a function
          and we can assign it to another void* pointer
          we cannot use a void* to operate on the object it address
            we don't know that object
******* understanding compound type declarations                                :code:
        : type modification
        a variable definition consistes of a base type and a list of declarators
          each declarator can relate its variable to the base type
            differently from the other declarators in the same definition
        TIP
        many programmers are confused by the interaction between
          the base type and the type modification that may be part of a declarator
        : pointers to pointers
        a pointer is an object in memory, so like any object it has an address
          therefore, we can store the address of a pointer in another pointer
        we indicate each pointer level by its own *
          we write ** for pointer to a pointer
          *** for a pointer to a pointer to a pointer, and so on
        : dereference
        just as dereferencing a pointer to an int yields an int
          dereferencing a pointer to a pointer yields a pointer
          to access the underlying object
            we must dereference the original pointer twice
        : references to pointers
        a reference is not an object
          hence, we may not have a pointer to a reference
          however, because a pointer is an object
            we can define a reference to a pointer
        TIP
        it can be easier to understand complicated pointer or reference declarations
          if you read them from right to left
****** const qualifier
******* const qualifier                                                         :code:
        : buffer size
        sometimes we want to define a variable whose value we know cannot be changed
          for example, we might want to use a variable
            to refer to the size of a buffer size
          using a variable makes it easy for us to change the size of the buffer
            if we decided the original size wasn't what we needed
          on the other hand, we'd also like to prevent code from inadvertently
            giving a new value to the variable we use to represent the buffer size
            we can make a variable unchangeable by defining the variable's type as const
        : initialization and const
        as we have observed many times
          the type of an object defines the operations
            that can be performed by that object
        a const type can use most but not all of the same operations
          as its nonconst version
          the one restriction is that
            we may use only those operations that cannot change an object
          we can use a const int in arithmetic expressions in exactly
            the same way as nonconst int
          a const int converts to bool the same way as a plain int, and so on
        : by default, const objects are local to a file
        the compiler will usually replace
          uses of the variable with its corresponding value during compilation
        in order to see the initializer
          the variable must be defined in every file
            that wants to use the variable's value
          to support this usage
            yet avoid multiple definitions of the same variable
            const variables are defined as local to the file
        sometimes we want to define the const in one file
          and declare it in the other files that use that object
          to define a single instance of a const variable
            we use the keyword extern on both its definition and declaration
        NOTE
        to share a const object among multiple files
          you must define the variable as extern
******* references to const                                                     :code:
        : cannot change
        a reference to const cannot be used to change
          the object to which the reference is bound
        : const reference is a reference to const
        C++ programmers tend to abbreviate
          the phrase "reference to const" as "const reference"
        technically speaking, there is no const references
          a reference is not an object
            so we cannot make a reference itself const
          because there is no way to make a reference refer to a different object
            in some sence all reference are const
          whether a reference refers to a const or nonconst type affects
            what we can do with that reference
            not whether we can alter the binding of the reference itself
        : initialization and references to const
        we noted that there are
          two exceptions to the rule
          that the type of a reference must match the type of the object
          to which it refers
        the first exception is that we can initialize a reference to const
          from any expression that can be converted to the type of the reference
        : a reference to const may refer to an object that is not const
        binding a reference to const to an object
          says nothing about whether the underlying object itself is const
        because the underlying object might be nonconst
          itmight be changed by other means
******* pointers and const                                                      :code:
        : unchange values
        a pointer to const may not be used to
          change the object to which the pointer points
        : exception of type match
        we can use a pointer to const to point to a nonconst object
        : const pointers
        unlike references, we can have a pointer that is itself const
        : change the object which pointer is point to
        the fact that a pointer is itself const says nothing about
          whether we can use the pointer to change the underlying object
******* top-level const                                                         :code:
        : top-level const and low-level const
        as we've seen, a pointer is an object that can point to a different object
          as a result, we can talk independently about
            whether a pointer is const
            and whether the objects to which it can point are const
        we use the term top-level const to indicate that the pointer itself is const
        when a pointer can point to a const object
          we refer to that const as a low-level const
        : the distinction between top-level and low-level
        : top-level [const *]
        when we copy an object, top-level consts are ignored
          because copying an object doesn't change the copied object
          as a result, it is immaterial whehter
            the object copied from or copied into is const
        : low-level [* const]
        low-level const is never ignored
          when we copy an object
            both objects must have the same low-level const qualification
            or there must be a conversion between the types of the two objects
            in general, we can convert a nonconst to const
              but not the other way round
        : both top-level and low-level [const *const]
        p3 has both a top-level and low-level const
          when we copy p3
            we can ignore its top-level const
            but not the fact that it points to a const type
******* constexpr and constant expressions                                      :code:
        : constant expressions
        whether a given object (or expression) is a constant expression
          depends on the types and the initializers
        : constexpr variables
        under the new standard
          variables declared as constexpr are implicitly const
            and must be initialized by constant expressions
        TIP
        generally, it is a good idea to use constexpr for variables that
          you indend to use as constant expressions
        : literal types
        because a constant expression is one that can be evaluated at compile time
          there are limits on the types that we can use in a constexpr declaration
        the types we can use in a constexpr are known as "literal types"
          of the types we have used so far, the arithmetic, reference, and pointer types are literal types
          our sales_item class and the library IO and string types are not literal types
        although we can define both pointers and reference as constexprs
          the objects we use to initialize them are strictly limited
          we can initialize a constexpr pointer from the _nullptr_ literal or the literal _0_
          we can also point to (or bind to) an object that remains at a fixed address
        : pointers and constexpr
        it is important to understand that
          when we define a pointer in a constexpr declaration
          the constexpr specifier applies to the pointer
            not the type to which the pointer points
****** dealing with types
******* type aliases                                                            :code:
        type aliases let us simplify complicated type definitions
          making those type easier to use
          type aliases also let us emphasize the purpose for which a type is used
        : typedef
        declarations that include typedef define type aliases rather than variables
        : using
        an alias declaration starts with
          the keyword using followed by the alias name and an =
        : type name
        a type alias is a type name and can appear wherever a type name can appear
        : compound type
        declarations that use type aliases that represent compound types
        and const can yield surprising results
        : alias error
        it will make a interpret error
          when declaration uses a type alias by conceptually replacing
            the alias with its corresponding type
******* the auto type specifier                                                 :code:
        : auto
        auto tells the compiler to deduce the type from the initializer
        : a single base type
        a declaration can involve only a single base type
          the initializers for all the vairables in the declaration must
            have types that are consistent with each other
        : use a reference as an initializer
        the reference's object type is auto's type deduction
        : drop top-level
        auto ordinarily ignores top-level consts
        : reference to auto
        when we ask for a reference to an auto-deduced type
          top-level consts in the initializer are not ignored
        : & and * in auto
        when we define several variables in the same statement
          it is important to remember that a reference or pointer is part of
            a particular declarator
          and not part of the base type for auto declaration
******* the decltype specifier                                                  :code:
        : decltype
        sometimes we want to define a variable with
          a type that the compiler deduces from an expression but
            do not want to use that expression to initialize the variable
        : return type
        decltype returns the type of that variable
          including top-level const and reference
        : reference and decltype
        decltype returns a reference type for expressions that
          yield objects that can stand on the left-hand side of the assignment
        : the expression in decltype
        when we apply decltype to a variable without any parentheses
          we get the type of that variable
        if we wrap the variable's name in one or more sets of parentheses
          the compiler will evaluate the operand as an expression
****** defining our own data structures
       in c++, we define our own data types by defining a class
******* defining the Sales_data type                                            :fragment:
        : Sales_data.h
        : struct
        our class begins with the keyword struct
          followed by the name of the class and a class body
        the keyword class that can be used to define our own data structures
          we'll explain in that section why we use struct here in chapter 7
        : semicolon at the end of a class
        it is a common mistake among new programmers to forget
          he semicolon at the end of a class definiton
        : data member
        our class has three data members
          a member of type string named bookNo
          an unsigned member named units_sold
          and a member of type double named revenue
        : in-class initializer
        we can supply an in-class initializer for a data member
          when we create objects
            the in-class initializers will be used to initialize the data members
        so we can define units_sold, revenue to be initialized to 0
          bookNo will be initialized to the empty string
******* using the Sales_data class                                              :fragment:
        : Sales_data.cpp
        : this program structure
        : adding two Sales_data objects
        because Sales_data provides no operations
          we will have to write our own code to do
            the input, output, and addition operations
        : reading data into a Sales_data object
        : printing the sum of two Sales_data objects
        check the transactions are for the same ISBN
          if so, we'll print their sum
          otherwise, we'll print an error message
******* writing our own header files                                            :fragment:
        : Sales_data.h
        : define class
        classes are usually defined in header files
          ensure that the class definition is the same in each header file
        : header name
        typically, classes are stored in headers whose name
          derives from the name of the class
          our Sales_data class in a header file named Sales_data.h
        : the entities contain in header file
        headers (usually) contain entities
          such as class definitions and const and constexpr variables
            that can be defined only once in any given file
        headers often need to use facilities from other headers
          like Sales_data.h include string header
        NOTE
        whenever a header is updated
          the source files that use that header must be recompiled to
            get the new or changed declarations

        : preprocessor
        the preprocessor is a program that runs before the compiler and
          changes the source text of our programs
          when preprocessor see #include
            it replaces _#inlcude_ with the contents of the specified header
        WARMMING
        preprocessor variable names do not respect c++ scoping rules
        : header guards
        header guards rely on preprocessor variables
        _#define_ take a name and defines that name as a preprocessor vairable
        _#ifdef_ is true if the variable had been defined
        _#ifndef_ is true if the variable has not been defined
        if test is true, everything end up to _#endif_
        TIP
        header should have guards, even if they are not included by another header
        : preprocessor variable
        preprocessor variables have one of two possible state
          defined or not defined
        TIP
        to avoid name clashes with other entities
          preprocessor variables usually are written in all uppercase (like SALES_DATA_H)
***** strings, vectors, and arrays
****** namespace using declarations
       : std namespace
       up to now, our program use the library is in the std namespace
       std::cin says that we want to use the name cin from the namespace std
                and indicate to read from the standard input
       : using declaration *
       a using declaration lets us use a name from a namespace without
         qualifying the name with a namespace_name::prefix
         using namespace::name;
       : headers should not include using declarations
       the reason is that the contents of a header are copied
         into the including program's text
       if a header has a using declaration
         then every program that includes that header gets that same using declaration
         it might encounter unexpected name conflicts
       NOTE
       from this point on
         to keep the code example short, we won't show the using declarations
         nor will we show the necessary #include directives
       Table [En 866] in appendix
         include a lists of namespace which we use in this primer
       WARNING
       readers should be aware that they must add appropriate #include and
         using declarations to our examples before compiling them
**** library string type
     : using string type
     to use the string type
       we must include the string header
         #include <string>
       because it is part of the library, string is defined in the std namespace
         using std::string;
       our examples assume the above two line code
     NOTE
     library types are efficient enough for general use

     : ways to initialize a string *
     : direct and copy forms of initialization *

     : string operations *
     : reading and writing strings *
     : reading an unknown number of strings *
     : using getline to read an entire line *
     : the string empty and size operations *
     : the string::size_type type *
     it's the return value of size() function
     : comparing strings *
     : assignment for strings *
     : adding two strings *
     : adding literals and strings *

     : dealing with the characters in a string
     : cctype library *
     the header file contain part of processing characters function
     cctype functions [En 135]
     : processing every character use range-based for *
     : using a range for to change the characters in a string *
     : processing only some characters *
     : using a subscript for iteration *
     : using a subscript for random access *
** lisp
*** An Introduction to Programming in Emacs Lisp
**** what is lisp                                                               :code:
***** what is lists
      : four different flowers *
      a simple example of list
      : numbers list *
      list can also have numbers in them
      : lists inside of lists *
      since a program looks like data
        one program may easily serve as data for another

      : lisp atoms
      a list in lisp consists of parentheses surrounding atoms separated by whitespace
        or surrounding other lists
        or surrounding both atoms and other lists
      there are many kinds of atom in nature but only a few in lisp
        "number", such as 37, 511, or 1729
        and "symbols", such as '+', 'foo', or 'forward-line'
        the meaning of the component letters of a lisp atom
          are different from the meaning the letters make as a word
          like the word for South American sloth, the 'ai'
            is completely different from the two words, 'a' and 'i'
      : empty list *
      a list with nothing in it
      : quoted text *
      in lisp, all of the quoted text including
        the punctuation mark and the blank space is a single atom

      : format lists
      the <TAB> key automatically indents the line the cursor is on
      the command 'M-C-\' to properly indent the code in a region
***** any list in lisp is a program ready to run
      : evaluate
      a list in lisp-any list-is a program ready to run
        if you run it (for which the lisp jargon is "evaluate")
        the computer will do one of three things
          do nothing except return to you the list itself
          send you a error message
          treat the first symbol in the list as a command to do something
      : '
      the single apostrophe, ‘'’
        that I put in front of some of the example lists
        in preceding sections is called a "quote"
        when it precedes a list
          it tells lisp to do nothing with the list
          other than take it as it is written
        but if there is no quote preceding a list
          the first item of the list is special
            it is a command for the computer to obey
      : C-x C-e *
      how to evaluate a list
***** generate an error message
      : error and help
      once you understand the jargon
        error messages can be informative
        instead of being called "error" messages
          they should be called "help" messages
      : debugger *
      the error message is generated by a build-in GNU Emacs debugger
        we will enter the debugger
***** symbol names and fucntion definitions
      in lisp, one set of instructions can be attacked to several names
      on the other hand
        a symbol can have only one function definition attached to it at a time
***** the lisp interpreter
      : how lisp interpreter works *
      : special forms, macros, ordinary function *
      : byte compiled code and humanly readable code *
***** running a program
      : evaluation
      when the lisp interpreter works on an expression
        the term for the activity is called "evaluation"
      : side effect
      at the same time the interpreter returns a value
        it may do something else as well
          such as move a cursor or copy a files
        this other kind of action is called a "side effect"
      : eval-last-sexp (C-x C-e)
      the letters 'sexp' are an abbreviation for "symbolic expression"
      and 'eval' is an abbreviation for "evaluate"
      the command evaluates the last symbolic expression
      : evaluating inner lists *
      as a experiment, you can try evaluating the expression
        by putting the cursor at the beginning of the next line
          immediately following the expression
        or inside the expression
***** returnning a value from a variable
      : variable
      a symbol that has a value is often called a "variable"
      : the symbol drawers
      a symbol can have a value attached to it
        just as it can have a function definition attached to it
        or both of them at the sane time
      imagine a symbol as being a chest of drawers
        the function definition is put in one drawer
        the value in another, and so on
        the value can be changed without affecting the content of the drawer

      : a value attached to a symbol *
      : 1. error message for a symbol without a function *
      : 2. error message for a symbol without a value *
      : more detail for 1 and 2
***** passing information to a function
      : types of data passed to a function *
      the type of data that should be passed to
        a function depends on what kind of information it uses
      : an argument as the value of a variable or list *
***** some functions may take any number of arguments
      : take any number of arguments *
***** passing an argument of the wrong type to a function
      when a function is passed an argument of the wrong type
        the lisp interpreter produces an error message
      : add string to number *
***** a useful function for sending messages
      : print message in the echo area *
      : quoted string *
***** setting the value of a variable
      there are several ways by which a variable can be given a value
      : set *
      set the value of symbol

      : setq *
      like 'set' except that the first argument is quoted automatically
      : multiple assignments *
      : using setq to count *
**** practicing evaluation                                                      :code:
***** how to evaluate
      : typing editing commands or 'C-c C-e' cause evaluation
***** buffers and files are different
      : file *
      : buffer *
      : evaluate the result after the expression *
***** getting a buffer itself, not merely its name
      : get current buffer *
      : get other buffer you recently selected *
***** how to change to another buffer
      : switch to buffer you specific *
      : call
      when you evaluate a list in which the first symbol is a funtion
        you are calling that function
***** buffer size and location of point
      : buffer size *
      : point *
**** how to write function definitions                                          :code:
     : function definition *
     : primitive functions *

     : defun *
     : make a function interactive
     : message function *
     : interactive options *

     : let *

     : if *
     : equal *
     : else *
     : nil *

     : point *
     : mark *
     : region *
     : save-execursion *
**** buffer related functions                                                   :code:
     : find more information *

     : what the function definition has to contain *
     : beginning-of-buffer definition *
     : mark-whole-buffer *
     : append-to-buffer *
**** a few more complex buffer related functions                                :code:
     : copy-to-buffer *

     : insert-buffer *
     : old version *
     : "or" expression *
     : two "save-excursion" *
     : new version *

     : beginning-of-buffer *
     : optional arguments *
     : interactive "P" *
     : the reference of documentation string *
**** Narrowing and widening                                                     :code:
     : narrowing and widen a buffer *
     : get rid of the narrowing in effect *
     : use both 'save-excursion and 'save-restriction *
**** car, cdr, cons: fundamental functions                                      :code:
     : report the first item from the list *
     : report the list besides the first item *

     : build a list *

     : find the length of a list *

     : report a copy of list without nth element *
     : report a single element of list *

     : make a list and then set the value of a variable to the list *
**** storing text in a list                                                     :code:
     : zap-to-char *
     : kill-region *
     : lisp macro *
     : copy-region-as-kill *
     : delete-and-extract-region *
     : initializing a variable with defvar *
**** how lists are implemented
** java
*** CANCELLED java编程思想 thinking in java
    CLOSED: [2017-09-17 日 11:40]
    :LOGBOOK:  
    - State "CANCELLED"  from ""           [2017-09-17 日 11:40] \\
      some idea of this book is out of date
    :END:      
**** 对象入门 introduction to object
***** 抽象的进步 the progress of abstraction
      一切皆为对象
      everything is an object
      程序是一大堆对象的组合 通过消息传递 各对象指导自己该做些什么
      a program is a bunch of objects telling each other what to do by sending messages
      每个对象都有自己的存储空间
      each object has its own memory made up of other objects
      每个对象都有一种类型
      every object has a type
      同一类所有对象都能接收相同的消息
      all objects of a particular type can receive the same messages
***** 对象的接口 an object has an interface
      我们向对象发出的请求是通过它的'接口'定义的 对象的类型或类则规定了它的接口形式
      the requests you can make of an object are defined by its interface, and the type is what determines the interface
      - 以灯泡为例
        type name        light
        interface        on()  off() brighten() dim()
        light it = new light();
        it.on();
***** an object provides services
      : it helps to improve the cohesiveness of the object
      : it mean the various aspects of a software componet "fit together" well
      some of these objects always exist and for the ones that don't, what would they look like?
      what services would those objects provide and what objects would they need to fulfill their obligations?
***** 实现方案的隐藏 the hidden implementation
      强制客户端程序员遵守任何约束
      to enforce rules for client programmer
      防止程序员接触他们不该接触的东西
      to keep client programmers' hands off protions they shouldn't touch
      允许库设计人员修改内部结构 不用担心他会对客户程序员造成什么影响
      to allow the library designer to change the internal workings of the class without worrying about how it will affect the client programmer
      - java uses three explicit keywords to set the boundaries in a class
        public         element is available to everyone
        private        no one can access that element except you
        protected      an inheriting class has access to protexted members, but not private members
      - java also has a "default" access if you don't use one of the specifiers
        package access       classes can access the members of other classes in the same package (library component)
***** 方案的重复使用 reusing the implementation
      : 为重复使用一个类 直接使用那个类的对象 或由任意数量和类型的其他对象构成新类
      : the simplest way to reuse a class is to just use an object of that class directly
      : or the new class made up of any number and type of other objects
      : 新建类的时候 首先应考虑‘组织’对象 一辆车包含乐一个变速箱
      : you should first look to composition when creating new classes
***** 继承: 重新使用接口 inheritance
****** 重新使用接口 reuse base-class method
       - 使用继承时 相当于创建了一个新类 包含了类的所有成员(private成员被隐藏) 复制了基础类的接口
         when you inherit from an existing type, you create a new type.
         this new type contains not only all the members of the existing type(although the private ones are hidden away and inaccessible),
         but more important it duplicates the interface of the base class
       - 可向基础类的对象发送的所有消息亦可发给衍生类的对象
         all the messages you can send to objects of the base class you can also send to objects of the derived class
       - 继承过程中 原始类发生了变化 继承类也会反映出这种变化
       - 为衍生类添加新函数
         simply add brand new methods to the derived class
****** 改善基础类 overrideing the base-class method
       尽管使用的函数接口未变 但它的新版本具有不同的表现
       I'm using the same interface method here, but I want it to do something different for my new type
***** 多形对象互换使用 interchangeable objects with polymorphism
      - 代码示例
        =// Shape class have erase() and draw() method=
        void doSomething(Shape shape) {
          : interface for <<abstract object>>  just define the abstract name of method, there is no need to implement it
          shape.erase();
          // ...
          shape.draw();
        }
        : <<upcasting>>
        =// Circle Triangle Line is heritanced Shape=
        =// any message that doSomething() can send to a Shape, a Circle can accept=
        =// We call this process of treating a derived type as though it were its base type *upcasting*=
        Circle circle = new Circle();
        Triangle triangle = new Triangle();
        Line line= new Line();
        : <<polymorphism>>
        =// when the Java compiler is compiling the code for doSomething( ), it cannot know exactly what types it is dealing with=
        =// you’d expect it to end up calling the version of erase() and draw() for the base class Shape, and not for the specific Circle, Square, or Line. And yet the right thing happens because of polymorphism=
        doSomething(circle);
        doSomething(triangle);
        doSomething(line);
****** 上溯造型 The singly rooted hierarchy
       - [[upcasting]]
****** 动态绑定(多形性) polymorphism
       - [[polymorphism]]
****** 抽象基础类和接口 containers
       - 使用抽象类 使用抽象方法
         抽象类(基础类)不能创建对象 只为自己的衍生类提供一个接口(抽象方法)
         继承一个抽象类后抽象方法必须实现 否则继承的类也会变成抽象类
         this [[abstract object]], generally called a container, will expand itself whenever necessary to accommodate everything you place inside it.
         So you don’t need to know how many objects you’re going to hold in a container. Just create a container object and let it take care of the details.
***** 对象的创建和存在时间 object creation & lifetime
***** 违例控制: 解决错误 exception handling: dealing with errors
      - 违例控制模块是封装好的 只需编写代码调用
        Java’s exception handling stands out among programming languages, because in Java, exception handling was wired in from the beginning and you’re forced to use it
        single acceptable way to report errors. If you don’t write your code to properly handle exceptions, you’ll get a compile-time error message.
***** 多线程 concurrent programming
      java多线程机制已内建到语言中
      - 资源锁定方案
        使用synchronized 同一时间只能有一个线程使用特定的内存空间
***** java和因特网 java and the internet
      - 服务器
        Taken together, the information repository, the software that distributes the information,
          and the machine(s) where the information and software reside are called *“the server”*
      - 客户端
        The software that resides on the consumer machine, communicates with the server,
          fetches the information, processes it, and then displays it on the consumer machine is called *the client*
      - 中间件
        To minimize latency, programmers work hard to offload processing tasks,
          often to the client machine, but sometimes to other machines at the server site,
          using so-called middleware. (Middleware is also used to improve maintainability.)
      - 通用网关接口 CGI
        This submission passes through the Common Gateway Interface (CGI) provided on all Web servers
        a cgi programs can be written in most languages.
        Perl has been a common choice because it is designed for text manipulation and is interpreted.
        However, Python (www.Python.org) has been making inroads because of its greater power and simplicity.
      - 插件 plug-ins
        This is a way for a programmer to add new functionality to the browser by downloading a piece of code that plugs itself into the appropriate spot in the browser.
      - 脚本编制语言
        Plug-ins resulted in the development of browser scripting languages
        With a scripting language, you embed the source code for your client-side program directly into the HTML page,
          and the plug-in that interprets that language is automatically activated while the HTML page is being displayed
        One scripting language that you can expect a Web browser to support without a plug-in is *JavaScript*
        - 创建更丰富 更具有互动能力的图形界面
        - 能快速的解决80%的问题
          However, a scripting language might solve 80 percent of the problems encountered in client-side programming.
          Your problems might very well fit completely within that 80 percent, and since scripting languages can allow easier and faster development,
            you should probably consider a scripting language before looking at a more involved solution such as Java programming
      - java
        - 解决剩下的20%的问题
          Java is a popular solution for this.
          Not only is it a powerful programming language built to be secure, cross-platform, and international,
            but Java is being continually extended to provide language features and libraries that elegantly handle problems that are difficult in traditional programming languages,
            such as concurrency, database access, network programming, and distributed computing. Java allows client-side programming via the *applet* and with Java Web Start
        - 程序片 applet
          - 客户端程序管理
            An applet is a mini-program that will run only under a Web browser.
            When the applet is activated, it executes a program.
            This is part of its beauty—it provides you with a way to automatically distribute the client software from the server at the time the user needs the client software, and no sooner.
          - 编译形式
            Since Java is a full-fledged programming language, you can do as much work as possible on the client before and after making requests of the server
              For example, you won’t need to send a request form across the Internet to discover that you’ve gotten a date or some other parameter wrong,
              and your client computer can quickly do the work of plotting data instead of waiting for the server to make a plot and ship a graphic image back to you
            Not only do you get the immediate win of speed and responsiveness,
              but the general network traffic and load on servers can be reduced, preventing the entire Internet from slowing down
      - 服务器端编程
        - 数据库编程
          事务处理
        - 小服务程序 servlet
      - 应用程序
      - 因特网和内联网
**** 一切都是对象 everything is an object
     - Although it is based on C++, Java is more of a “pure” object-oriented language
       Both C++ and Java are hybrid languages, but java is easier by shift your mindset into an object-oriented world
***** 用句柄操纵对象 you manipulate objets with references
      - 对象引用
        You treat everything as an object, using a single consistent syntax.
        Although you treat everything as an object, the identifier you manipulate is actually a “reference” to an object
        You might imagine a television (the object) and a remote control (the reference)
        - a example of String obejct reference [C]
          =// So if you want to hold a word or sentence, create a String reference=
          String s;
          =// But here you’ve created only the reference, not an object, a safer practice is always to initialize a reference when you create it=
          String s = "asdf";
***** 所有对象都必须创建 you must create all the objects
      - 创建句柄 同新对象连接
        When you create a reference, you want to connect it with a new object
        =// The keyword new says, “Make me a new one of these objects.”=
        String s = new String("asdf");
        : TIP
        What’s more important is that you can create your own types
****** 保存到什么地方 where storage lives
       - 各个对象的存储方式
         - 寄存器 registers
           fastest  inside the processor
           number limit
           compiler control
         - 堆栈 the stack
           random-access memory (RAM)
           via stack pointer  create memory
           fast second only to registers
           object referennces
         - 堆 the heap
           RAM
           more flexibility  take more time
           create object by using *new*
         - 静态存储
           固定位置  随时调用
         - 常数存储 constant storage
           read-only memory (ROM)
         - 非RAM存储 Non-RAM storage
           outside program
           stream objects  be sent to another machine
           persistent objects  hold state when program is terminated
****** 主类型 special case: primitive types                                     :ATTACH:
       :PROPERTIES:
       :Attachments: primitive_type.java
       :ID:       EB6455DC-6B7F-4FF6-80AC-FE533C8C17AF
       :END:
       - 不用new创建的对象
         - instead of creating the variable by using new, an "automatic" variable is create that is not a reference
           boolean char byte short int long float double void
       convert from primitive to a wrapper type [C]
******* 高精度数字 high-precision numbers
        BigInterger BigDecimal -> int float
***** 绝对不要清除对象 you never need to destroy an object
      java greatly simplifies the issue by doing all the cleanup work for you
****** 作用域 scoping                                                           :ATTACH:
       :PROPERTIES:
       :Attachments: scoping.java
       :ID:       1947A0DA-50F3-4E3A-8300-699F38D40B7B
       :END:
       primitive lifetimes [primitive]
       object lifetimes [object]
***** 新建类 creating new data tyoes: *class*                                   :ATTACH:
      :PROPERTIES:
      :Attachments: Class.java
      :ID:       31072962-644D-4206-ABA6-CF4A09CFA484
      :END:
      create a class [class]
****** fields [fields]
****** default values for primitive members [primitive]
****** methods, arguments, and return values [methods]
****** the argument list [argument]
***** 构建java程序 building a java program                                      :ATTACH:
      :PROPERTIES:
      :Attachments: Build.java
      :ID:       B221B12F-F956-4910-AA02-F54F5F53EFA5
      :END:
      there are several other issues you must understand before seeing your first java program
****** 名字的可见性 name visibility
       - the domain extensions *com, edu, org, net, etc* are capitalized
         NET.mindview.utility.foibles
****** 使用其他组件 using other components [compoment]
****** static关键字 the static keyword [static]
***** 第一个java程序 your first java program                                    :ATTACH:
      :PROPERTIES:
      :Attachments: ShowProperties.java Data.java
      :ID:       A9E19240-2CE3-43E8-8811-321777570A77
      :END:
      using the *Data* class from the java standard library [Data]
      displays all of the "properties" from the system where you are running the program [ShowProperties]
***** compiler and running
      JDK installed
      javac HelloWorld.java
      java HelloWorld.java
***** 注释和嵌入文档 comments and embedded doucumentation                       :ATTACH:
      :PROPERTIES:
      :Attachments: Comment.java
      :ID:       E97EAE80-53D4-4F6F-A9E8-B67D78E6B6D9
      :END:
      C and C++ comment style [comment]
****** comment documentation [javadoc]
****** some example tags [tags]
****** documentation example [example]
***** 编码样式 coding style                                                     :ATTACH:
      :PROPERTIES:
      :Attachments: coding.java
      :ID:       CC8A4357-F80F-495D-B72A-B0D389FB5A30
      :END:
      class and method name [C]
**** 操作符 operators
     at the lowest level, data in java is manipulated using operators
***** simpler print statements                                                  :ATTACH:
      :PROPERTIES:
      :Attachments: Print.java
      :ID:       7021B646-1487-4415-B4B2-975DEC1AA0AA
      :END:
      static import new library, simplify writing print statements
***** 使用Java运算符 using Java operators
****** 优先级 precedence
       
**** 执行控制 controlling execution
     like a sentient creature, a program must manipulate its world and make choices during execution
***** true and false
**** 初始化和清除 initialization & cleanup
     - as the computer revolution progresses, "unsafe" programming has become one of the major culprits that makes programming expensive
       two of these safety issures are initialization and cleanup
***** 用构建起自动初始化 guaranteed initialization with the constructor         :ATTACH:
      :PROPERTIES:
      :Attachments: SimpleConstructor.java SimpleConstructor2.java
      :ID:       3A94608B-89F0-4223-89CA-6C9505B84B40
      :END:
      - 创建对象时 自动调用的方法
        - simple constructor [C]
          SimpleConstructor.java
        - simple constructor with argument [C]
          SimpleConstructor2.java
        : NOTE
        - the constructor has no return value
          but you still have theoption to make it return something else
        the name of the constructor must math the name of the class exactly
***** 方法过载 method overloading                                               :ATTACH:
      :PROPERTIES:
      :Attachments: Overloading.java
      :ID:       7121ABC5-24AF-43D3-B279-A095A25C1CCD
      :END:
      - 同名方法 不同参数
        - here's an example that shows both overloaded constructors and overloaded methods [C]
          Overloading.java
****** 区分过载方法 distinguishing overloaded methods
**** 隐藏实施过程 access control
     access control (or implementation hiding) is about "not getting it right the first time"
***** 包: 库单元 package: the library unit
**** 类再生 reusing classes
     one of the most compelling features about java is code reuse
***** 合成的语法 composition syntax
**** 多形性 polymorphism
     polymorphism is the essential feature of an object-oriented after data abstraction and inheritance
***** 上溯造型 upcasting revisited
**** 接口 interfaces
     interface and abstract classes provide more structured way to separate interface from implementation
***** 抽象类和方法 abstract classes and methods
**** 内部类 inner classes
      it's possible to place a class definition within another class definition. This is called an inner class
***** creating inner classes
**** 对象的容纳 holding your objects
     - it's a fairly simple program that only has a fixed quantity of objects with known lifetimes
       because your programs will always be ccreating new objects based on some criteria that will be known only at run time
       to solve the general programming problem, you need to create any number of objects, anytime, anywhere
       : TIP
       the java.util library has a reasonably complete set of container classes to solve this problem
       the basic types of which are *List, Set, Queue, and Map*
***** generics and type-safe containers
**** 违例差错控制 error handling with exceptions
     the basic philosophy of java is that "badly formed code will not be run"
**** strings
**** 运行期类型鉴定 type information
**** generics
**** arrays
**** containers in depth
**** java I/O系统 I/O
**** enumerated types
**** annotations
**** 多线程 concurrency
**** 创建窗口和程序片 graphical userInterfaces
*** PROJECT core java volume I
**** an introduction to java                                                    :code:
     : robust
     java provide many measures to protect the programming environment
     : secure
     the subtle flaws of java have spotted by hacker
       care about remote code
     : aarchitecture-neutral
     the compiled code of java can run in any platform
     : portable
     the java's primitive data type and the interfaces of java libraries
       are all platform-independent
     : interpreted
     before you run java bytecodes
       you should translate them into specific machine code
     : high-performance
     java has a just-in-time compiler
       the compiler can translate bytecodes into machine code on the fly (at runtime)
     : multithreaded
     java was the first mainstream language
       to support concurrent programming
     : dynamic
     java can add code to a running program
     : applets and the internet
     a applets is a java program that work on web
       it can embed into a web page and react the programmer's commands
     : common misconceptions about java
     the misunderstanding concept of java
**** the java programming environment                                           :code:
     : java jargon
     : pick the right JDK
     : using the command-line tools
*** fundamental programming structures in java
**** first sample                                                               :code:
     : FirstSample.java
     print a message to console
     : case sensitive
     typing such as Main instead of main, the program will not run
     : access modifier
     the keyword public is called an access modifier
       these modifiers control the level of access
         other parts of a program have to this code
     : the building blocks of class
     everything in a java program must be inside a class
     : the rules for class names
     names must begin with a letter
       and after that, they can combination of letters and digits
     : many words in class name
     if a class name is called "camel case"
       you should write "CamelCase"
     : source code
     you need to make the file name for
       the source code the same as the name of the public class
       with the extension .java appended
     : main method
     according to the java language specification
       the main method must be declared public
     : braces
     the braces {} delineate the parts (usually called block) in your program
     C++
     there are a few differences between c++ and java classes
     unlike c/c++, the main method does not return an "exit code" to the operating system
     : object and method
     using the System.out object and calling its println method
     notice the general syntax:
       object.method(parameters)
**** data types                                                                 :code:
     : strongly language
     this means that every variable must have a declared type
     : primitive types *
     there are eight primitive types in java

     : integer types
     the integer types are for numbers without fractional parts
     negative values are allowed
     : java integer types *
     : not depend on the machine
     the ranges for the various types are fixed
     C++
     the sizes of types such as int and long depend on the target platform
     : long integer
     have a suffix L or l      (for example, 40000000000L)
     : hexadecimal numbers
     have a prefix 0x or 0X    (for example, 0xCAFE)
     : octal numbers
     have a prefix 0           (for example, 010 is 8)
     : human readable
     you can add underscores to number literals, such as 1_000_000
     the java compiler simply removes them

     : floating-point types
     the floating-point typs denote numbers with fractional parts
     : floating-point types *
     : the float type limit
     : the suffix F or f
     : three special floating-point errors *
     : roundoff errors *

     : the char type *
     : literal values of char *
     : unicode sequences *
     values of type char can be expressed as
       hexadecimal values that run from \u0000 to \uFFFF
     NOTE
     unicode escape sequences are processed before the code is parsed
     : escape sequence and unicode value

     : unicode and the char type
     unicode was designed to contain the char type all over the world
     in java, the char type describes a code unit in the utf-16 encoding
     : the unicode history *

     : the boolean type
     the boolean type has two values, false and true
       it is used for evaluating logical conditions
     you cannot convert between integers and boolean values
     C++
     in c++, numbers and even pointers can be used in place of boolean values
       the value 0 is equivalent to the bool value false
       and a nonzero value is equivalent to true
       this is not the case in java:
         if (x = 0) // oops... meant x == 0
**** variables                                                                  :fragment:
     : a variable name begin with
     a letter is defined as A-Z , a-z, _, $ or any Unicode character
     TIP
     if you are really curious as to
       what unicode characters are "letters"
         as far as java is concerned
     even though $ is a valid java letter
       you should not use it in your own code
       it is intended for names that are generated by
         the java compiler and other tools
     : reserved word
     you also cannot use a java reserved word as a variable name
     : case sensitive
     names are case sensitive
       hireday and hireDay are two separate names

     : InitializingVariables.java
     : uninitialized variable *
     you can never use the value of an uninitialized variable
     : declare and initialize a variable *
     C++
     in c and c++
       int i = 10;   // is a definition
       extern int i; // is a declaration
     in java, no declaretions are separate from definition
     : good style
     in java, it is considered good style to
       declare variables as closely as possible to the point where they are first used

     : Constants.java
     : constant variables *
     : final
     the keyword final indicates that you can assign to the variable once
       and then its value is set once and for all
     : static final
     define outside the main method
       also be used in other methods of the same class
       furthermore, if the constant is declared, public
         method of other classes can also use it
     : class constants *
     it is probably more common in java to create a constant
       so it's available to multiple methods inside a single class
       these are usually called class constants
     set up a class constant with the keywords static final
**** operators                                                                  :fragment:
     : integer and floating-point division
     15 / 2 is 7, 15.0 / 2 is 7.5
     NOTE
     integer division by 0 raises an exception
       whereas floating-point division by 0 yields an infinite or NaN result
     : strictfp
     method tagged with the strictfp keyword must use strict floating-point operations
       public static strictfp void main (String[] args)
     : strict floating-point operations
     many intel processors compute floating-point and
       leave the result in an 80-bit register
       then finally truncate the result back to 64 bits
     the numeric community hated it
       not only can the truncated computations cause overflow
       they are actually slower than the more precise computations
         because the truncation operations take time
     all of this called strict floating-point operation
     : java floating-point operation
     java is portability
       a floating-point computation should yield the same results (64-bit)
         no matter which virtual machine executes it
     and it is also the default floating-point operation

     : MathematicalFunctions.java
     : static method
     the method in the Math class does not operate on any object
       such a method is called a static method
     : trigonometric function
     Math.(sin | cos | tan | atan | atan2)
     : function with its inverse
     Math.(exp | log | log10)
     : mathematical constants π and e
     Math.(PI | E)
     : source file *
     you can avoid the Math prefix by adding the Math source file
     : StrictMath class
     it implements the algorithms from "freely distributable math library" fdlibm
       guaranteeing identical results on all platforms

     : ConvertNumericType.java
     legal conversions between numeric types [En 86]
     : information loss *
     the three dotted arrows in [En 86] denote conversions that may lose precision
     : combined binary operator
     when two values are combined with a binary operator
       such as integer + floating-point
       both operands are converted to a common type before the operation is carried out

     : Cast.java
     numeric conversions are possible in java
     : syntax
     the syntax for casting is to give the target type in parentheses
       followed by the variable name
     C++
     you cannot cast between boolean values and any numeric type
       except a conditional expression such as    b ? 1 : 0
     : information may be lost *
     : round a floating-point number *
     if you want to round a floating-point number to the nearest integer

     : CombiningAssignmentWithOperators.java
     a convenient shortcut for using binary operators in an assignment

     : RelationalAndBooleanOperators.java
     : relational operators *

     : BitwiseOperators.java
     the operators that can work directly with the bits that make up the integers
     : bitwise operators *

     : OperatorHierarchy.java
     : parentheses and operator hierarchy
     C++
     unlike c or c++
       java does not have a comma operator
     : operator precedence [En 91]
     : associativity *
     the operator's running order

     : EnumeratedTypes.java
     a variable only hold a restricted set of values
**** strings                                                                    :code:
     : the standard java library
     java does not have a build-in string type
       instead, the standard java library contains
         a predefined class called, naturally enough, String
       each quoted string is an instance of the String class
     : Unicode characters *

     : substrings *
     : computing the length of the substring *

     : use + join two strings *
     : the join value is automatically convert to a string *
     : output statements *
     : .join method
     if you need to put multiple strings together
       sepatated by a delimiter
       use the static join method

     : strings are immutable *
     the string class gives no methods that
       let you change a character in an existing string
     : how to change string value and not create new one *
     C++
     if you use pointer to change string value
       it may cause a memory leak
     fortunately, java does automatic garbage collection

     : testing string for equality *
     : ignore upper/lower case distinction *
     : do not use the == operator to test whether two string are equal *
     it only determines whether or not the string are stored in the same location

     : empty and null strings
     : empty strings
     the empty string "" is a string of length 0
     : test whether a string is empty *
     : null strings
     a string variable can also hold a special value, called null
       that indicates that no object is currently associated with the variable
     : test whether a string is null *
     : test a string is neither null nor empty *

     : code points and code units
     : UTF-16 encoding
     each code point represent one character
       the range of code point is 0~0x10FFFF
     the character is inside of range use one char to store
       the character is out of range use two chars to store
       char is also called code unit
     : return the code units at position n *
     where n is between 0 and s.length() -1
     : to get ith code point *
     : to get the character with two code units *

     : the String api [En 99~100]
     the following api note summarizes the ones we found most useful
     : reading the online api document
     https://docs.oracle.com/javase/8/docs/api/ (already bookmark in safari)
     consult all method of String class

     : building strings
     : StringBuilder class
     occasionally, you need to build up string from shorter strings
       every time you concatenate strings, a new String object is constructed
       this is time consuming and wastes memory
       using the StringBuilder class avoid this problem
     : construct an empty string builder *
     : add another part *
     : get all String sequences contained in builder *
     : the most important methods for StringBuilder class [En 105]
**** input and output                                                           :fragment:
     : InputTest.java
     : reading input
     : System.in *
     standard input stream
     : Scanner *
     to read console input, you first construct a Scanner that is attached to System.in
     : nextLine *
     read a line of input
     : next *
     read a single word
     : nextInt *
     read a integer
     : java.util package *
     the Scanner class is defined in the java.util package
       whenever you use a class that is not defined in the basic java.lang package
       you need to use an import directive
     : Console *
     : java.util.Scanner [En 108]
     all important method of Scanner class
     : java.lang.System [En 108]
     returns a Console object for interacting with the user through a console window
     : java.io.Console [En 108]
     displays the prompt and reads the user input until the end of the input line

     : FormattingOutput.java
     : System.out.print *
     print to the console
     : System.out.printf *
     format output using printf method from the C library
     conversions for printf [En 109]
     flags for printf [En 111]
     data and time conversion characters [En 112]
     a syntax for format specifiers [En 113]
     NOTE
     argument index values start with 1, not with 0
       avoid confusion with the 0 flag

     : FileInputAndOutput.java
     : Scanner
     to read from a file
     : PrintWriter
     to write to a file
**** control flow
***** block scope
      : nested block *
      : not declare identically named variables in two nested blocks *
***** NEXT conditional statements
** go
*** WAITING go语言圣经 the go programming language
    CLOSED: [2017-04-16 日 14:10]
**** 入门 tutorial
***** hello world
      go run helloworld.go
        execute program one time
      go build helloworld.go
        create an executable binary file
***** 命令行参数 8 command-line arguments 34
      - os package
        dealing with the operating system in a platform-independent fashion
      - os.arg
        get arguments of os package
      - s[m:n]
        a slice of strings, return value of subsequence m to n-1
        a = [1, 2, 3]
        a[0, 2] = [1, 2]
        s[1:] = s[0:len(s)]
      : implementation of the unix echo command
      gopl.io/ch1/echo1
      // Echo1 prints its command-line arguments
      - package main
        import (
            "fmt"
            "os"
        )
      - func main() {
            var s, sep string  // the var declaration declares two variables s and sep, of type string
            // for loop   := give i appropriate types based on the initializer values
            for i :=1 i < len(os.Args); i++ {  // j = i++  or ++i --i is illegal
                s += sep + os.Args[i]  // the + operator concatenates the values of strings
                sep = " "
                fmt.Println(s)
            }
        }
      : second version of echo command (over a range of value from a string or a slice)
      ...
      - func main() {
            s, sep := "". ""  // [[declare and initialize]]
            for _, arg := range os.Args[1:]{  // _ blank identifier  used whenever syntaax requires a variable name but program logic does not
                             // os.Args[1:]  indexing over os.Args is implicit, not explicit
                s += sep + arg  // [[a simpler and more efficient solution to use involved large amount of data]]
                sep = " "
            }
            fmt.PrintIn(s)
        }
      ...
      : <<declare and initialize>>
      there are several ways to declare a string variable, these are all equivalent:
        s := ""             // with implicit to specified variable type: used only witin a function, not for package-level variables
        var s string        // with explicit to specified variable type
        var s = ""          // in practice, you should not use this form: implicit inialization to say that the initial value doesn't matter
        var s string = ""   // in practice, you should not use this form: explicit inialization to say that the initial value doesn't matter
      : <<a simpler and more efficient solution to use involved large amount of data>>
      fmt.PrintIn(strings.Join(os.Args[1:], " "))
      : one of for loop statement forms
      for initialization; condition; post {
          // zero or more statements
      }
      : a traditional "while" loop
      for condition {
          // ...
      }
      : atraditional infinite loop
      for {
          // ...
      }
      : 
***** 查找重复的行 finding duplicate lines
      : Dup1 prints the text of each line that appears more than
      : once in the standard input, preceded by its count.
      gopl.io/ch1/dup1
      - package main
        import (
            "bufio"
            "fmt"
            "os"
        )
      - func main() {
           counts := make(map[string]int)  =// the build-in function make create a new empty [[map]]=
           =// <<map>>  holds a set of key/value pairs and provides constant-time operations to store=
           =//          the default value of key is 0=
           input := bufio.NewScanner(os.Stdin)  =// bufio Scanner: read input and breaks it into lines or words=
           for input.Scan() {  =// each call to input.Scan() reads the next line and removes the newline character from the end=
               counts[input.Text()]++  =// equivalent to line :=input.Text()=   =counts[line] = count[line] + 1=
           }
           // NOTE: ignoring potential errors from input.Err()
           for line, n := range counts {  =// range loop: the order of map iteration is random=
               if n > 1 {
                   fmt.Printf("%d\t%s\n", n, line)  =// fmt.Printf like printf in C and have over a dozen such conversions call [[verbs]]=
           }
         }
      : Dup2 prints the count and text of lines that appear more than once
      : in the input.  It reads from stdin or from a list of named files.
      gopl.io/ch1/dup2
      - package main
        import (
            "bufio"
            "fmt"
            "os"
        )
      - func main() {
            counts := make(map[string]int)
            files := os.Args[1:]
            if len(files) == 0 {             =// a map type counts is passed to a function, the function receives a copy of the reference (like C pointer)=
               countLines(os.Stdin, counts)  =// so any changes the called function makes to the underlying data structure will be visible through the caller's map reference=
            } else {
                for _, arg := range files {
                    f, err := os.Open(arg)  =// os.Open: return two values  an open file (*os.file) read by Scanner  build-in error type=
                    =// if the returned error type is nil, the file was opened successfully=
                    =// else using Fprintf and the verb %v to format error stream, and dup then carries on with the next file=
                    if err != nil {
                        fmt.Fprintf(os.Stderr, "dup2: %v\n", err)
                        continue
                    }
                    countLines(f, counts)  =// call countLines precedes its declaration, functions and other package-level entities may be declared in any order=
                    f.Close()
                }
            }
            for line, n := range counts {
                if n > 1 {
                    fmt.Printf("%d\t%s\n", n, line)
                }
            }
        }
      - func countLines(f *os.File, counts map[string]int) {
            input := bufio.NewScanner(f)
            for input.Scan() {
                counts[input.Text()]++
            }
           // NOTE: ignoring potential errors from input.Err()
        }
      : Dup3 it only reads named files, not the standard input
      : moved the counting of the lines into main, since it is nedded in only one place
      gopl.io/ch1/dup3
      - package main
        import (
            "fmt"
            "io/ioutil"
            "os"
            "strings"
        )
      - func main() {
            counts := make(map[string]int)
            for _, filename := range os.Args[1:] {
                data, err := ioutil.ReadFile(filename)  =// ReadFile returns a byte slice that must be converted into a string so it can be split by [[strings.Split]]=
                if err != nil {
                    fmt.Fprintf(os.Stderr, "dup3: %v\n", err)
                    continue
                }
                for _, line := range strings.Split(string(data), "\n") { =// <<strings.Split>>=
                    counts[line]++
                }
            }
            for line, n := range counts {
                if n > 1 {
                    fmt.Printf("%d\t%s\n", n, line)
                }
            }
        }
      : <<verbs>>
      - many of the features
        %d              decimal integer
        %x, %o, %b      integer in hexadecimal, octal, binary
        %f, %g, %e      floating-point number: 3.141593 3.141592653589793 3.141593e+00
        %t              boolean: true or false
        %c              rune (Unicode code point)
        %s              string
        %q              quoted string "abc" or rune 'c'
        %v              any value in a natural format
        %T              type of any value
        %%              literal percent sign (no operand)
** perl
*** perl doc
**** what's important in perl
     : the capability to manage complicate data structures *
     : the syntax for managing references *
     : reformatting a file of city and country names *
**** complex data structure
**** perl regular expression
     : rules for regular expression *
     : the sequences pattern *
     : the interactive pattern *
     : the wildcard *
     : the quantifiers *
     : grouping in patterns *
     : alternatives *
     : character classes *
     : character class shortcuts *
     : Unicode properties *
     : anchor *
*** learning perl
**** introduction
***** compile
      $ perl my_program
***** bin path
      #!/usr/bin/env perl
      #!/usr/bin/perl || #!/use/local/bin/perl
***** a whirlwind tour of perl
      #!/usr/bin/perl                  =# perl bin path, you should change it for your system=
      =# an array variable called @lines get message about the function atan2=
      @lines = `perldoc -u -f atan2`;  =# runs a external command, named within backquotes (``)=
                                       =# the perldoc command is to read and display the docmentation for perl=
      foreach (@lines) {
        s/\w<([^>]+)>/\U$1/g;
        print;
      }
**** scalar data
***** scalar
      - 对于大部分标量来说 要么是数字 要么是有字符组成的序列
        a scalar is the simplest kind of data that perl manipulates
        most scalars atr either a number or astring of characters
      - 不区分变量类型
        not like C has char, int, and so on. perl doesn't make distinctions among single things
***** numbers
      : NOTE
      - 内部不存在整数值 总是按双精度浮点数进行运算
        Perl relies on the underlying C libraries for its numbers and uses a double-precision floating-point value to store the numbers.
        it does mean Perl has some limitations in precision and magnitude of the numbers that are related to how you compiled and installed the perl interpreter instead of a limitation of the language itself.
      - 没有专门的整型运算
        you can specify both integers and floating-point numbers.
        but internally, perl computers with double-precision floating-point values
****** 整数直接量 integer literals
       - 直接量 literals
         a literal is how you represent a value in your source code.(like int datatype)
       - 插入下划线 将若干位数分开
         61298040283
         61_298_040_283
****** 非十进制整数直接量 nondecimal interger literals
       - 八进制 octal
         start with a leading 0 and use the digits from 0 to 7
         0377 # same as 255 decimal
       - 十六进制 hexadecimal
         start with a leading 0x and use the digits 0 to 9 and the letters A through F (or a through f) to represent the values from 0 to 15:
         0xff # FF hex, also 255 decimal
       - 二进制 binary
         start with a leading 0b and use only the digits 0 and 1.
         0b11111111 # also 255 decimal
       - 下划线分隔符
         When a nondecimal literal is more than about four characters long, it may be hard to read, so underscores are handy
         0x1377_0B77
         0x50_65_72_7C
       : NOTE
       - 前置0只对直接量有效
         The “leading zero” indicator works only for literals
         not for automatic string-to-number conversions
****** 浮点数直接量 floating-point literals
       - hexadecimal floating-point literals
         Instead of an e to mark the exponent, you use a p for the power of 2 exponent
         0x1f.0p3
****** 数字操作符 numeric operators
       - 乘幂操作符号 exponentiation
         So, 2**3, is two to the third power, or eight
       : Note
       - 模操作符 modulus operator (%)
         Both values are first reduced to their integer values, so 10.5 % 3.2 is computed as 10 % 3.
         For -10 % 3, is the remainder 2 because it’s two places above -12 or -1 because it’s one place from -9? It’s best to avoid finding out accidentally.
***** strings
      - 创建 扫描 操控 二进制数据
        For example, you could update a graphical image or compiled program by reading it into a Perl string, making the change, and writing the result back out.
      - 需要手动设置unicode编码文本文件读入
        If you want to use Unicode literally in your program, you need to add the utf8 pragma.
        use utf8;
      : NOTE
      - 无内置限制 no build-in limits
        The longest string fills all of your available memory
****** 单引号内的字符串直接量 signle-quoted string literals
       - 转义
         If you want a literal single quote or backslash inside your string, you need to escape it with a backslash:
         'Don\'t let an apostrophe end this string prematurely!'
         'the last character is a backslash: \\'
         '\'\\'    # single quote followed by backslash
       - 换行符
         You can spread your string out over two (or more) lines.
         'hello
         there'    # hello, newline, there (11 characters total)
       : NOTE
       - 无法转义控制字符
         Note that Perl does not interpret the \n within a single-quoted string as a newline
         'hello\nthere'    # hellonthere
****** 双引号内的字符串直接量 double-quoted string literals
       - 控制字符转义
         "hello world\n" # hello world, and a newline
         "coke\tsprite"  # coke, a tab, and sprite
         : Table doubel-quoted string backslash escapes (En 47)
       - 进制表示法
         "\x{2668}"      # Unicode HOT SPRINGS character code point
         "\N{SNOWMAN}"   # Unicode Snowman by name
****** 字符串操作符 string operators
       - 字符串连接
         You can concatenate, or join, string values with the . operator
         "hello" . "world"       # same as "helloworld"
         "hello" . ' ' . "world" # same as 'hello world'
         'hello world' . "\n"    # same as "hello world\n"
       - 重复操作符
         This operator takes its left operand (a string) and makes as many concatenated copies of that string as indicated by its right operand (a number)
         "fred" x 3       # is "fredfredfred"
         "barney" x (4+1) # is "barney" x 5, or "barneybarneybarneybarneybarney"
         5 x 4.8          # is really "5" x 4, which is "5555"
         : NOTE: The copy count (the right operand) is first truncated to an integer value (4.8 becomes 4) before being used.
***** automatic conversion between numbers and strings
      - 操作符类型转换
        Perl automatically converts between numbers and strings as needed.
        It all depends upon the operator that you apply to the scalar value.
        If an operator expects a number (like + does), Perl will see the value as a number.
        If an operator expects a string (like . does), Perl will see the value as a string.
      - 字符串十进制浮点数进行运算
        Perl automatically converts the string to its equivalent numeric value, as if you had entered it as a decimal floating-point value
        So "12" * "3" gives the value 36.
        : Trailing nonnumber stuff and leading whitespace are discarded
        so "12fred34" * " 3" will also give 36 without any complaints
        : something that isn’t a number at all converts to zero.
        so "fjdi12" * "fjdks" will give 0
      - 数字运算字符串连接
        "Z" . 5 * 7 # same as "Z" . 35, or "Z35"
      : NOTE
      - 前置0按十进制数字处理
        0377    # that's octal for 255 decimal
        '0377'  # that's 377 decimal
***** perl's build-in warnings
      - 发现程序不对劲时 让perl发出警告
        - turn on warnings with a pragma
          : only With Perl 5.6 and later
          : for the file
          #!/usr/bin/perl
          use warnings;
        - use the -w option on the command line
          : for the file
          $ perl -w my_program
        - specify the command-line switches on the shebang line
          : for the entire program
          #!/usr/bin/perl -w
        - to load the pragma only when needed instead of editing the source code each time to enable and disable diagnostics
          $ perl -Mdiagnostics ./my_program
***** perl's build-in warnings
****** interpreting nondecimal numerals
       : if you have a string that represents a number as another base
       hex('DEADBEEF')    # 3_735_928_559 decimal
       hex('OxDEADBEEF')  # 3_735_928_559 decimal
       oct('0377')        # 255 decimal
       oct('377')         # 255 decimal
       oct('0xDEADBEEF')  # 3_735_928_559 decimal, saw leading 0x
       oct('0b1101')      # 13 decimal, saw leading 0b
       oct("0b$bits")     # convert $bits from binary
       hex( 10 );         # decimal 10, converted to "10", then decimal 16
       hex( 0x10 );       # hex 10,     converted to "16", then decimal 22
***** scalar variables
      - 标量定义
        : not like a variable is a name for a container that holds one or more values
        a scalar variable holds exactly *one value*
        : Uppercase and lowercase letters are distinct
        Scalar variable names begin with a dollar sign, called the sigil
        - these are different
          $name
          $Name
          $NAME
****** 给变量娶个好名字 choosing good variable names
       - 增加可读性
         : properly placed underscores can make a name easier to read and understand
         $super_bowl is a better name than $superbowl
       - 特殊含义的变量
         Using all uppercase (like $ARGV) generally indicates that there’s something special about that variable
       - perlvar documentation
         lists all of the Perl’s special variable names, and perlstyle has general programming style advice
****** 标量的赋值 scalar assignment
       - 如何赋值
         a variable name on the left side, and gives it the value of the expression on the right
         $fred   = 17;
         $barney = 'hello';
         $barney = $fred + 3;
         $barney = $barney * 2;
****** 双目赋值操作符 compound assignment operators
       - 双目赋值操作符
         - the compound assignment operator
           $fred  = $fred + 5; # without the binary assignment operator
           $fred += 5;         # with the binary assignment operator
           $str  = $str . " "; # append a space to $str
           $str .= " ";        # same thing with assignment operator
***** output with print
      - print操作符
        it takes a scalar argument
          and puts it out without any embellishment onto standard output
        : NOTE
        - You can give print a series of values separated by commas
          print "The answer is ", 6 * 7, ".\n";
****** 字符串中的标量变量内插 interpolation of scalar variables into strings
       - 变量内插 variable interpolation
         - a scalar variable name in the string is replaced with its current value
           $meal   = "brontosaurus steak";
           $barney = "fred ate a $meal";    # $barney is now "fred ate a brontosaurus steak"
           $barney = 'fred ate a ' . $meal; # another way to write that
         : NOTE
         - If the scalar variable has never been given a value, the *empty string* is used instead
           $barney = "fred ate a $meat"; # $barney is now "fred ate a "
         - Don’t bother with interpolating if you have just the *one lone variable*
           print "$fred"; # unneeded quote marks
           print $fred;   # better style
         - To put *a literal dollar sign* into a double-quoted string
           $fred = 'hello';
           print "The name is \$fred.\n";    # prints a dollar sign
         - *delimiter or separated* the variable
           $what = "brontosaurus steak";
           $n = 3;
           print "fred ate $n $whats.\n";        # use the value of $whats
           print "fred ate $n ${what}s.\n";      # now use the value of $what
           print "fred ate $n $what" . "s.\n";   # another way to do it
****** 借助代码点创建字符 creating characters by code point
       - 通过代码点(code point)输入键盘上没有的那些字符
         - it’s easier to create them by their code point with the chr() function
           $alef  = chr( 0x05D0 );
           $alpha = chr( hex('03B1') );
           $omega = chr( 0x03C9 );
         : NOTE
         - You can *interpolate* these into double-quoted strings just like any other variable
           "$alpha$omega"
           "\x{03B1}\x{03C9}"
       - 通过特殊字符查找相应代码点
         - with the ord() function, which turns a character into its code point
           $code_point = ord( 'α' );
****** 操作符优先级与结合性 operator precedence and associativity
       - 优先级
         : the same as C
         Associativity and precedence of operators [T En 57]
       - 结合性
         - Just like precedence, associativity resolves the order of operations when *two operators of the same precedence*
           4 ** 3 ** 2      # 4 ** (3 ** 2), or 4 ** 9 (right associative)
           72 / 12 / 3      # (72 / 12) / 3, or 6/3, or 2 (left associative)
           36 / 6 * 3       # (36/6)*3, or 18
       : TIP
       : 直接括号明确顺序
****** 比较操作符 comparison operators
       数值与字符串的比较操作符 [T En 58]
       - example
         35 != 30 + 5        # false
         35 == 35.0          # true
         '35' eq '35.0'      # false (comparing as strings)
         'fred' lt 'barney'  # false
         'fred' lt 'free'    # true
         'fred' eq 'fred'    # true
         'fred' eq 'Fred'    # false
         ' ' gt ''           # true
***** the if control structure
      - example
        if ($name gt 'fred') {
          print "'$name' comes after 'fred' in sorted order.\n";
        } else {
          print "'$name' does not come after 'fred'.\n";
          print "Maybe it's the same string, in fact.\n";
        }
      : NOTE
      : You must have those block curly braces around the conditional code, unlike C
****** 布尔值 boolean values
       - perl没有专用的布尔数据类型 它靠一些简单的规则进行判断
         If the value is a *number*, 0 means false; all other numbers mean true
         Otherwise, if the value is a *string*, the empty string ('') and the string '0' means false; all other strings mean true
         If the variable doesn’t have a value yet, it’s false
       - 布尔if判断
         if (! $is_bigger) {
           # Do something when $is_bigger is not true
         }
       - !反转操作
         - use ! return some scalar to represent true and false(1 and 0)
           $still_true  = !! 'Fred';
           $still_false = !! '0';
***** getting use input
      - 操作符 <STDIN> 获取键盘输入
        Each time you use <STDIN> in a place where Perl expects a scalar value
        Perl reads the next complete text line from *standard input* (up to the first newline), and uses that string as the value of <STDIN>
        - example
          $line = <STDIN>;
          if ($line eq "\n") {                        =# But in practice, you don’t often want to keep the newline, so you need the chomp() operator=
              print "That was just a blank line!\n";
          } else {
              print "That line of input was: $line";
          }
***** the chomp operator
      - 去掉字符串变量末尾换行符
        : It works on a variable. The variable has to hold a string
        :   and if the string ends in a newline character, chomp() removes that newline
        - example
          $text = "a line of text\n";    # Or the same thing from <STDIN>
          chomp($text);                  # Gets rid of the newline character
        : NOTE
        : If a string ends with two or more newlines, chomp() removes only one
      - 连用
        - 赋值运算表达式 代替变量参数
          : In fact, there’s an easier way to use chomp() because of a simple rule:
          : any time that you need a variable in Perl, you can use an assignment instead
          - So the most common use of chomp() looks like this
            =# First, Perl does the assignment. Then it uses the variable in whatever way you requested=
            chomp($text = <STDIN>); =# Read the text, without the newline character=

            $text = <STDIN>;        =# Do the same thing...=
            chomp($text);           =# ...but in two steps=
      - 返回值 省略括号
        =# chomp() is actually a function. As a function, it has a return value, which is *the number of characters removed*.=
        =# If there’s no newline, it does nothing, and *returns zero*. For the most part, you don’t care what chomp() returns=
        $food = <STDIN>;
        $betty = chomp $food; =# gets the value 1 - but you knew that!=
        =# As you see, you may write chomp() with or *without the parenthesess*, except in cases where it changes the meaning to remove them=
***** the while control structure
      - while循环
        : The while loop repeats a block of code as long as a condition is true
        $count = 0;
        while ($count < 10) {
            $count += 2;
            print "count is now $count\n"; =# Gives values 2 4 6 8 10=
        }
        : NOTE
        : Eventually you’ll create an infinite loop by accident
        : You can stop it in the same way you’d stop any other program
        : Often, typing Control-C will stop a runaway program
***** the undef value
      - 空无一物
        : Variables have the special undef value before they are first assigned
        :   which is just Perl’s way of saying
        :     “Nothing here to look at—move along, move along.”
        - If you try to use this “nothing” as a “numeric something,” it acts like zero
           =# Add up some odd numbers=
           $n = 1;
           while ($n < 10) {
             $sum += $n;
             $n += 2; =# On to the next odd number=
           }
           print "The total was $sum.\n";
        - If you try to use it as a “string something,” it acts like the empty string
          $string .= "more text\n";         =# If $string is undef, this will act as if it already held the empty string, putting "more text\n" into that variable=
        - make your own undef values, you can use the obscurely named undef operator
          $next_line = undef; =# As if it had never been touched=
        : NOTE
        : undef is neither a number nor a string
        : it’s an entirely separate kind of scalar value
***** the defined function
      - 判断 undef
        - use the defined function, which returns false for undef, and true for everything else
          $next_line = <STDIN>;
          if ( defined($next_line) ) {
             print "The input was $next_line";
          } else {
             print "No input available!\n";
          }
**** lists and arrays
     - 多个标量组成
       : The list is the data and the array is the variable that stores that data
       : Each element of an array or list is a separate scalar value, The elements of an array or a list are indexed by integers starting at zero and counting by ones
       : Arrays and lists can have any number of elements. The smallest one has no elements, while the largest can fill all of available memory
***** accessing elements of an array
      - 下标 subscript
        $fred[0] = "yabba";
        $fred[1] = "dabba";
        $fred[2] = "doo";
      - 表达式赋值 change that value by expressions
        $fred[1] .= "whatsis";     # $fred[1] + "whatsis"
      - 舍去小数
        : if the subscript may be any expression not a numeric value
        : Perl will automatically truncate it (not round!) to the whole number portion
        $number = 2.71828;
        print $fred[$number - 1];  # Same as printing $fred[1]
      - 超出下标范围
        $blank = $fred[ 142_857 ]; # unused array element gives undef
        $blanc = $mel;             # unused scalar $mel also gives undef
***** special array indices
      - 自动扩展数组长度
        $rocks[0]  = 'bedrock';
        $rocks[1]  = 'slate';
        $rocks[2]  = 'lava';
        $rocks[99] = 'schist';           =# now there are 96 undef elements=
      - 最后一个元素的索引值
        : Sometimes, you need to find out the last element index in an array
        : For the array of rocks , the last element index is $#rocks
        $end = $#rocks;                  # $end = 99, which is the last element's index
        $number_of_rocks = $end + 1;     # OK, but you'll see a better way later
        $rocks[ $#rocks ] = 'hard rock'; # useing the $#name value as an index
      - 负数索引
        : If you have three elements in the array
        : the valid negative indices are -1 (the last element)
        :                                -2 (the middle element)
        :                            and -3 (the first element)
        :                     If you try -4 and beyond, you just get undef
        $rocks[ -1 ]   = 'hard rock';   # easier way to do that last example
        $dead_rock     = $rocks[-100];  # gets 'bedrock'
        $rocks[ -200 ] = 'crystal';     # fatal error!
***** list literals
      - 列表元素
        (1, 2, 3)      # list of three values 1, 2, and 3
        (1, 2, 3,)     # the same three values (the trailing comma is ignored)
        ("fred", 4.5)  # two values, "fred" and 4.5
        ( )            # empty list - zero elements
      - 范围操作符
        (1..100)          # list of 100 integers
        (1..5)            # same as (1, 2, 3, 4, 5)
        (1.7..5.7)        # same as above; both values are truncated
        (0, 2..6, 10, 12) # same as (0, 2, 3, 4, 5, 6, 10, 12)
        : NOTE
        : The range operator only counts up, so this won’t work and you’ll get the empty list
        (5..1)            # empty list; .. only counts "uphill"
      - 表达式元素
        : The elements of a list literal are not necessarily constants
        :   they can be expressions that will be newly evaluated each time the literal is used
        ($m, 17)       # two values: the current value of $m, and 17
        ($m+$o, $p+$q) # two values
        ($m..$n)       # range determined by current values of $m and $n
        (0..$#rocks)   # the indices of the rocks array from the previous section
****** qw简写 the qw shortcut
       - 单引号字符串
         : The qw shortcut makes it easy to generate them without typing a lot of extra quote marks
         : NOTE
         : Perl treats it like a single-quoted string (so, you can’t use \n or $fred inside a qw list as you would in a double-quoted string)
         ("fred", "barney", "betty", "wilma", "dino")  =# A list may have any scalar values=
         qw( fred barney betty wilma dino )            =# same as earlier, but less typing=
         : The whitespace (characters like spaces, tabs, and newlines) disappear and whatever is left becomes the list of items
         : Some people like to format their lists with one element per line, which makes it easy to operate as a column
         qw(
             fred
             barney
             betty
             wilma
             dino
         )
         : Perl lets you choose any punctuation character as the delimiter
         qw! fred barney betty wilma dino !
         qw/ fred barney betty wilma dino /
         qw# fred barney betty wilma dino #   =# like in a comment!=
         qw( fred barney betty wilma dino )
         qw{ fred barney betty wilma dino }
         qw{
             /usr/dict/words
             /home/rootbeer/.ispell_english
         }

         : include the closing delimiter within the string as one of the characters by using the backslash
         qw! yahoo\! google ask msn !  =# include yahoo! as an element=
         qw( This as a \\ real backslash )
***** list assignment
      - 多重变量赋值
        : All three variables in the list on the left get new values, just as if you did three separate assignments
        ($fred, $barney, $dino) = ("flintstone", "rubble", undef);
        : swap two variables
        ($fred, $barney) = ($barney, $fred); =# swap those values=
        ($betty[0], $betty[1]) = ($betty[1], $betty[0]);
        : In a list assignment, extra values are silently ignored
        ($fred, $barney) = qw< flintstone rubble slate granite >; =# two ignored items=
        : if you have too many variables, the extras get the value undef (or the empty list)
        ($wilma, $dino)  = qw[flintstone];                        =# $dino gets undef=
        : use with qw
        ($rocks[0], $rocks[1], $rocks[2], $rocks[3]) = qw/talc mica feldspar quartz/;
        : Use the at sign (@) before the name of the array (and no index brackets after it) to refer to the entire array at once
        : TIP  This works on either side of the assignment operator
        @rocks  = qw/ bedrock slate lava /;
        @tiny   = ( );                       =# the empty list=
        @giant  = 1..1e5;                    =# a list with 100,000 elements=
        @stuff  = (@giant, undef, @giant);   =# a list with 200,001 elements=
        $dino   = "granite";
        @quarry = (@rocks, "crushed rock", @tiny, $dino)
        : copy an array to another array, it’s still a list assignment
        @copy = @quarry; =# copy a list from one array to another=
****** pop和push操作符 the pop and push operators
       - 数组末尾添加删除操作
         : You could add new items to the end of an array by simply storing them as elements with new, larger indices
         : The pop operator takes the last element off of an array and returns it
         @array  = 5..9;
         $fred   = pop(@array);  =# $fred gets 9, @array now has (5, 6, 7, 8)=
         $barney = pop @array;   =# $barney gets 8, @array now has (5, 6, 7)=
         : That last example uses pop in a void context, which is merely a fancy way of saying the return value isn’t going anywhere
         pop @array;             =# @array now has (5, 6). (The 7 is discarded.)=
         : NOTE
         If the array is empty, pop leaves it alone (since there is no element to remove) and returns undef

         : The converse operation is push, which adds an element (or a list of elements) to the end of an array
         push(@array, 0);            =# @array now has (5, 6, 0)=
         push @array, 8;             =# @array now has (5, 6, 0, 8)=
         push @array, 1..10;         =# @array now has those 10 new elements=
         @others = qw/ 9 0 2 1 0 /;
         push @array, @others;       =# @array now has those five new elements (19 total)=

         : NOTE
         the first argument to push or the only argument for pop must be an array variable—pushing and popping would not make sense on a literal list
****** shift和unshift操作符 the shift and unshift operators
       - 数组开头添加删除操作
         @array = qw# dino fred barney #;
         $m = shift(@array);      =# $m gets "dino", @array now has ("fred", "barney")=
         $n = shift @array;       =# $n gets "fred", @array now has ("barney")=
         shift @array;            =# @array is now empty=
         $o = shift @array;       =# $o gets undef, @array is still empty=
         unshift(@array, 5);      =# @array now has the one-element list (5)=
         unshift @array, 4;       =# @array now has (4, 5)=
         @others = 1..3;
         unshift @array, @others; =# @array now has (1, 2, 3, 4, 5)=
         : NOTE
         shift returns undef if you give it an empty array variable
****** splice操作符 the splice operator
       - 数组中间添加删除操作
         : splice operator takes up to four arguments, two of which are optional
         : The first argument is always the array
         : the second argument is the position where you want to start
         : If you only use those two arguments, Perl removes all of the elements from your starting position to the end and returns them to you
         @array = qw( pebbles dino fred barney betty );
         @removed = splice @array, 2; =# remove fred and everything after=
                                      =# @removed is qw(fred barney betty)=
                                      =# @array is qw(pebbles dino)=
         : use a third argument to specify a length
         @array = qw( pebbles dino fred barney betty );
         @removed = splice @array, 1, 2; =# remove dino, fred=
                                         =# @removed is qw(dino fred)=
                                         =# @array is qw(pebbles barney betty)=
         : The fourth argument is a replacement list
         @array = qw( pebbles dino fred barney betty );
         @removed = splice @array, 1, 2, qw(wilma); =# remove dino, fred=
                                                    =# @removed is qw(dino fred)=
                                                    =# @array is qw(pebbles wilma=
                                                    #              barney betty)
         : If you specify a length of 0, you remove no elements but still insert the “replacement” list
         @array = qw( pebbles dino fred barney betty );
         @removed = splice @array, 1, 0, qw(wilma); =# remove nothing  NOTE: Perl inserted the replacement list starting at index 1 and moved everything else over=
                                                    =# @removed is qw()=
                                                    =# @array is qw(pebbles wilma dino=
                                                    =#              fred barney betty)=
***** interpolating arrays into strings
      - 双引号字符串 数组内插
        @rocks = qw{ flintstone slate rubble };
        print "quartz @rocks limestone\n";  =# prints five rocks separated by spaces=
        : There are no extra spaces added before or after an interpolated array; if you want those, you’ll have to put them in yourself
        print "There's nothing in the parens (@empty) here.\n";
      - 规避数组内插
        $email = "fred@bedrock.edu";  # WRONG! Tries to interpolate @bedrock
        Possible unintended interpolation of @bedrock
        : To get around this problem, you either escape the @ in a double-quoted string or use a single-quoted string
        $email = "fred\@bedrock.edu"; # Correct
        $email = 'fred@bedrock.edu';  # Another way to do that
      - 内插数组中的某个元素
        @fred = qw(hello dolly);
        $y = 2;
        $x = "This is $fred[1]'s place";    # "This is dolly's place"
        $x = "This is $fred[$y-1]'s place"; # same thing
      - 索引表达式
        : Note that the index expression evaluates as an ordinary expression, as if it were outside a string. It is not variable-interpolated first
        @fred = qw(eating rocks is wrong);
        $fred = "right";               =# we are trying to say "this is right[3]".=
        print "this is $fred[3]\n";    =# prints "wrong" using $fred[3]=
        print "this is ${fred}[3]\n";  =# prints "right" (protected by braces)=
        print "this is $fred"."[3]\n"; =# right again (different string)=
        print "this is $fred\[3]\n";   =# right again (backslash hides it)=
***** the foreach control structure
      - 遍历列表中的值
        foreach $rock (qw/ bedrock slate lava /) {
            print "One rock is $rock.\n";  =# Prints names of three rocks=
        }
      - 循环中修改控制变量
         @rocks = qw/ bedrock slate lava /;
         foreach $rock (@rocks) {
             $rock = "\t$rock";       # put a tab in front of each element of @rocks
             $rock .= "\n";           # put a newline on the end of each
         }
         print "The rocks are:\n", @rocks; # Each one is indented, on its own line
      - 控制变量在循环结束之后还原
        : after the loop is done, the variable has the value it had before the loop, or undef if it hadn’t had a value
        $rock = 'shale';
        @rocks = qw/ bedrock slate lava /;
        foreach $rock (@rocks) {
          ...
        }
        : TODO
        After we introduce subroutines to you in Chapter 4, we’ll show you a better way to handle that
****** perl最喜欢的默认变量:$_  perl's favorite default:$_
       - 缺省控制变量
         : If you omit the control variable from the beginning of the foreach loop, Perl uses its <<favorite default variable>>, $_
         foreach (1..10) {  # Uses $_ by default
           print "I can count to $_!\n";
         }
         : one of those cases is print, which will output $_ if given no other argument
         $_ = "Yabba dabba doo\n";
         print;  # prints $_ by default
****** reverse操作符 the reverse operator
       - 逆序返回列表值
         : The reverse operator takes a list of values (which may come from an array) and returns the list in the opposite order
         - So if you were disappointed that the range operator only counts upward, this is the way to fix it
           @fred   = 6..10;
           @barney = reverse(@fred);  =# gets 10, 9, 8, 7, 6=
           @wilma  = reverse 6..10;   =# gets the same thing, without the other array=
           @fred   = reverse @fred;   =# puts the result back into the original array  NOTE: Perl always calculates the value being assigned (on the right) before it begins the actual assignment=
         : Remember that reverse returns the reversed list; it doesn’t affect its arguments. If the return value isn’t assigned anywhere, it’s useless
         reverse @fred;           =# WRONG - doesn't change @fred=
         @fred = reverse @fred;   =# that's better=
****** sort操作符 the sort operator
       - 按字符编码顺序进行排序
         : The sort operator takes a list of values (which may come from an array) and sorts them in the internal character ordering
         - The sort operator takes an input list, sorts it, and outputs a new list
           @rocks   = qw/ bedrock slate rubble granite /;
           @sorted  = sort(@rocks);        # gets bedrock, granite, rubble, slate
           @back    = reverse sort @rocks; # these go from slate to bedrock
           @rocks   = sort @rocks;         # puts sorted result back into @rocks
           @numbers = sort 97..102;        # gets 100, 101, 102, 97, 98, 99
           : TODO
           you’ll see in Chapter 14 how to sort in whatever order you’d like
         : the arguments themselves aren’t affected. If you want to sort an array, you must store the result back into that array
         sort @rocks;          # WRONG, doesn't modify @rocks
         @rocks = sort @rocks; # Now the rock collection is in order
****** each操作符 the each operator
       - 使用each 返回下一个元素对应的两个值
         : Every time that you call each on an array, it returns two values for the next element in the array—the index of the value and the value itself
         require v5.12;
         @rocks = qw/ bedrock slate rubble granite /;
         while( ( $index, $value ) = each @rocks ) {
             print "$index: $value\n";
         }
         : TODO
         but we don’t show you those until Chapter 6
       - 借助索引值取得元素的值
         : If you wanted to do this without each, you have to iterate through all of the indices of the array and use the index to get the value
         @rocks   = qw/ bedrock slate rubble granite /;
         foreach $index ( 0 .. $#rocks ) {
             print "$index: $rocks[$index]\n";
         }
***** scalar and list context *[important section]*
      - 一个表达式出现在不同的地方会有不同的意义
        : a given expression may mean different things depending upon where it appears and how you use it
        - it’s the operator that decides what you are doing, not the values
          2 * 3      =# numeric multiplication 6=
          2 x 3      =# string replication 222=
        : As Perl is parsing your expressions, it always expects either a scalar value or a list value (or void, which we don’t cover in this book)
        - What Perl expects is called the context of the expression
          42 + something =# The something must be a scalar=
          sort something =# The something must be a list=
        - In a list context, it gives the list of elements. But in a scalar context, it returns the number of elements in the array
          @people = qw( fred barney betty );
          @sorted = sort @people;  # list context: barney, betty, fred
          $number = 42 + @people;  # scalar context: 42 + 3 gives 45
        - Even ordinary assignment (to a scalar or a list) causes different contexts
          @list = @people; =# a list of three people=
          $n = @people;    =# the number 3=
        : TIP
        Each expression can make up its own rules
        follow the overall rule that isn’t very helpful to you
****** 在标量上下文中使用产生列表的表达式 using list-producing expressions in scalar context
       - sort标量上下文
         : sort
         You wouldn’t need to sort a list to count its elements, so until someone implements something else, sort in a scalar context always returns undef
       - reverse标量上下文
         : reverse
         - In a list context, it gives a reversed list. In a scalar context, it returns a reversed string
           @backwards = reverse qw/ yabba dabba doo /;
               # gives doo, dabba, yabba
           $backwards = reverse qw/ yabba dabba doo /;
               # gives oodabbadabbay
       - 判断上下文
         : At first, it’s not always obvious whether an expression is being used in a scalar or a list context. But trust us, it will become second nature for you eventually
         - Here are some common contexts to start you off
           $fred = something;            =# scalar context=
           @pebbles = something;         =# list context=
           ($wilma, $betty) = something; =# list context=
           ($dino) = something;          =# still list context!=
         - some that provide scalar context to something
           $fred = something;
           $fred[3] = something;
           123 + something
           something + 654
           if (something) { ... }
           while (something) { ... }
           $fred[something] = something;
         - some that provide a list context
           @fred = something;
           ($fred, $barney) = something;
           ($fred) = something;
           push @fred, something;
           foreach $fred (something) { ... }
           sort something
           reverse something
           print something
****** 在列表上下中使用产生标量的表达式 using scalar-producting expressions in list context
       - 产生一个仅含此标量值的列表
         : if an expression doesn’t normally have a list value, the scalar value is automatically promoted to make a one-element list
         @fred = 6 * 7;    =# gets the one-element list (42)=
         @barney = "hello" . ' ' . "world";
         : NOTE
         : Well, there’s one possible catch. Since undef is a scalar value, assigning undef to an array doesn’t clear the array. The better way to do that is to assign an empty list
         @wilma = undef; # OOPS! Gets the one-element list (undef)
             # which is not the same as this:
         @betty = ( );    =# A correct way to empty an array=
****** 强制指定标量上下文 forcing scalar context
       - 使用scalar强制引入标量上下文
         : On occasion, you may need to force scalar context where Perl is expecting a list.
         : In that case, you can use the fake function scalar. It’s not a true function because it just tells Perl to provide a scalar context
         @rocks = qw( talc quartz jade obsidian );
         print "How many rocks do you have?\n";
         print "I have ", @rocks, " rocks!\n";        # WRONG, prints names of rocks
         print "I have ", scalar @rocks, " rocks!\n"; # Correct, gives a number
         : NOTE
         Oddly enough, there’s no corresponding function to force list context. It turns out you almost never need it. Trust us on this
***** <STDIN> in list context
      - 读入标准输入
        @lines = <STDIN>; =# read standard input in list context=
        : you’ll normally type a Control-D to indicate to the system that there’s no more input

        - it will remove the newlines from each item in the list. For example
          @lines = <STDIN>;        =# Read all the lines=
          chomp(@lines);           =# discard all the newline characters=
          : the more common way to write that
          chomp(@lines = <STDIN>); =# Read the lines, not the newlines=
        : NOTE
        If the input data is large, you should generally find a way to deal with it without reading it all into memory at once
**** subroutines
***** defining a subroutine
      - 子程序主体
        =// NOTE=
        =// You may put your subroutine definitions anywhere in your program text, you don’t normally need any kind of forward declaration=
        =// If you have two subroutine definitions with the same name, the later one overwrites the earlier one=
        sub marine {
              $n += 1;  # Global variable $n         <<Global variable>>
              print "Hello, sailor number $n!\n";
        }
      - 全局变量
        [[Global variable]]
        In fact, all of the variables you’ve seen so far are global; that is, they are accessible from every part of your program
        : TODO
        You’ll see how to make private variables in the section “Private Variables in Subroutines” on page 66
***** invoking a subroutines
      - 使用子程序名
        : calling the subroutine by using the subroutine name (with the ampersand)
        &marine;  # says Hello, sailor number 1!
        &marine;  # says Hello, sailor number 2!
***** return value
      - 处理子程序的返回值
        : Many times, you call a subroutine and actually do something with the result
        : NOTE: All Perl subroutines have a return value
        sub sum_of_fred_and_barney {
              print "Hey, you called the sum_of_fred_and_barney subroutine!\n";
              $fred + $barney;  # That's the return value    [[return value]]
        }

        $fred   = 3;
        $barney = 4;
        $wilma  = &sum_of_fred_and_barney;      # $wilma gets 7
        print "\$wilma is $wilma.\n";
        =# ouput=
          =Hey, you called the sum_of_fred_and_barney subroutine!=
          =$wilma is 7.=

        $betty  = 3 * &sum_of_fred_and_barney;  # $betty gets 21
        print "\$betty is $betty.\n";
        =# output=
          =Hey, you called the sum_of_fred_and_barney subroutine!=
          =$betty is 21.=
      - 最后执行的语句被当成返回值
        <<return value>>
        : Whatever calculation is last performed in a subroutine is automatically also the return value

        : the last expression now the print statement, whose return value is normally 1, meaning “printing was successful"
        sub sum_of_fred_and_barney {
              print "Hey, you called the sum_of_fred_and_barney subroutine!\n";
              $fred + $barney;  # That's not really the return value!
              print "Hey, I'm returning a value now!\n";      # Oops!
        }

        : “The last evaluated expression” really means the last expression that Perl evaluates, rather than the last statement in the subroutine
        sub larger_of_fred_or_barney {
          if ($fred > $barney) {
            $fred;
          } else {
            $barney;
          }
        }
***** arguments
      - 带参数调用子程序
        : To pass an argument list to the subroutine, simply place the list expression, in parentheses, after the subroutine invocation
        $n = &max(10, 15);  # This sub call has two parameters

        : Perl automatically stores the parameter list in the special array variable named @_, this is valid during program execution
        sub max {
              =# This means that the first subroutine parameter is in $_[0], the second one is stored in $_[1], and so on=
              if ($_[0] > $_[1]) {
                $_[0];
              } else {
                $_[1];
        } }
        : a better way:  [[private variables]]

        : Perl doesn’t care about insufficient parameters either
        $n = &max(10, 15, 27);  =# extra parameters 27 will be omit=
        $n = &max(10);          =# the default second argument will return undef=
***** private variables in subroutines
      - 封闭语句块私有变量
        : you can create private variables called lexical variables at any time with the my operator
        sub max {
              my($m, $n);       # new, private variables for this block
              ($m, $n) = @_;    # give names to the parameters
            =# my($m, $n) = @_;  # make the subroutine in the previous two lines even simpler=
                                =# When you see that line, you’ll know that the subroutine expects two scalar parameters, which you’ll call $m and $n inside the subroutine=
              if ($m > $n) { $m } else { $n }
        }
***** cariable-length patameter lists
      - 检查参数列表
        sub max {
          if (@_ != 2) {  =# uses the “name” of the array in a scalar context to find out the number of array elements, as you saw in Chapter 3=
             print "WARNING! &max should get exactly two arguments!\n";
          }
          # continue as before...
        }
        : But in real-world Perl programming, virtually no one really uses this sort of check; it’s better to make your subroutines adapt to the parameters
****** 改进的&max子程序 a better &max routine
       : Rewrite &max to allow for any number of arguments
       $maximum = &max(3, 5, 10, 4, 6);

       sub max {
         my($max_so_far) = shift @_;  =# the first one is the largest yet seen    NOTE: if the &max is a <<empty list>>, shift @_ will return undef=
         foreach (@_) {               =# look at the remaining arguments          NOTE: if @_ is undef, the loop body execute zero times=
           if ($_ > $max_so_far) {    =# could this one be bigger yet?=
             $max_so_far = $_;
           }
         }
         $max_so_far;
       }
****** 空参数列表 empty parameter lists
       : if the array @numbers might sometimes be an [[empty list]]
       : the return value may be undef
       $maximum = &max(@numbers);
***** notes on lexical(my) variables
      - 将变量圈定在指定代码内
        - Those lexical variables can actually be used in any block, not merely in a subroutine’s block
          =# The variable $square is private to the enclosing block; in this case, that’s the block of the foreach loop=
          foreach (1..10) {
                my($square) = $_ * $_;  # private variable in this loop
                print "$_ squared is $square.\n";
          }
          : TIP
          : the scope of a lexical variable’s name is limited to the smallest enclosing block or file
        - Note also that the my operator *doesn’t change the context* of an assignment
          my($num) = @_;  =# list context, same as ($num) = @_;=
          my $num  = @_;  =# scalar context, same as $num = @_;=
        - Remember that *without the parentheses*, my only declares a single lexical variable
          my $fred, $barney;      # WRONG! Fails to declare $barney
          my($fred, $barney);     # declares both
        - use my to create new, private *arrays*
          my @phone_number;
        - in perl, you may use my to introduce a new perivate variable in your own structure
          foreach my $rock (qw/ bedrock slate lava /) {
              print "One rock is $rock.\n";  # Prints names of three rocks
          }
***** the use strict progma
      - 遵循优良编程风格
        : Perl tends to be a pretty permissive language.
        : the use strict pragma tells Perl’s internal compiler that it should enforce some good programming rules for the rest of this block or source file

        : without use strict progma
        =# imagine that you’re composing your program and you type a line like this one=
        $bamm_bamm = 3;  =# Perl creates that variable automatically=
        =# Now, you keep typing for a while. After that line has scrolled off the top of the screen, you type this line to increment the variable=
        $bammbamm += 1;  =# Oops! perl create a new variable=
        : with use strict progma
        use strict;  =# Enforce some good programming rules=
        my $bamm_bamm = 3;  =# New lexical variable=
        $bammbamm += 1;  =# No such variable: Compile time fatal error=
***** the return operator
      - 程序执行停止 返回值
        my @names = qw/ fred barney betty dino wilma pebbles bamm-bamm /;
        my $result = &which_element_is("dino", @names);
        sub which_element_is {
            my($what, @array) = @_;
            foreach (0..$#array) {  # indices of @array's elements
                if ($what eq $array[$_]) {  =# element not found (return is optional here)=
                    return $_;
                }
            }
            -1;  =# return early once found=
        }
***** omitting the ampersand
      - 省略子程序识别符&
        : if it is a function call, it may should not add &
        my @cards = shuffle(@deck_of_cards); =# No & necessary on &shuffle=
        : or if the subroutine is appeared earlier
        sub division {
              $_[0] / $_[1];                   # Divide first param by second
            }
        my $quotient = division 355, 113;  # Uses &division
        : NOTE
        : if the subroutines has the same name as a perl's build-in, you must use & to call your version
        sub chomp {
              print "Munch, munch!\n";
            }
        &chomp;  =# That ampersand is not optional!=
***** nonscalar return values
      - 子程序返回列表值
        sub list_from_fred_to_barney {
              if ($fred < $barney) {
                # Count upwards from $fred to $barney
                $fred..$barney;
              } else {
                # Count downwards from $fred to $barney
                reverse $barney..$fred;
              }
        }
        $fred = 11;
        $barney = 6;
        @c = &list_from_fred_to_barney; # @c gets (11, 10, 9, 8, 7, 6)
***** persistent, private variables
      - state变量
        - 非state变量无法存续
          =# add strict to you program and realize that your use of the global variable $n is now a compilation error=
          =# You can’t make $n a lexical variable with my because it wouldn’t retain its value between calls=
          use strict
          sub marine {
                $n += 1;    # Global variable $n (not declare error)
                my y += 1;  # Subroutine private variable my y (can not retain)
                print "Hello, sailor number $n!\n";
          }
        - 多次调用子程序期间保留state变量的值
          =# Declaring our variable with state tells Perl to retain the variable’s value between calls to the subroutine and to make the variable private to the subroutine=
          use v5.10;
              sub marine {
                state $n = 0;  # private, persistent variable $n
                $n += 1;
                print "Hello, sailor number $n!\n";
          }

          =# You can make any variable type a state variable, it’s not just for scalars=
          : Here’s a subroutine that remembers its arguments and provides a running sum by using a state array
          use v5.10;
          running_sum( 5, 6 );
          running_sum( 1..3 );
          running_sum( 4 );
          sub running_sum {
            state $sum = 0;
            state @numbers;
            foreach my $number ( @_ ) {
              push @numbers, $number;
              $sum += $number;
            }
            say "The sum of (@numbers) is $sum";
          }
          The sum of (5 6) is 11
          The sum of (5 6 1 2 3) is 17
          The sum of (5 6 1 2 3 4) is 21
          : NOTE
          : You can’t initialize arrays and hashs as state variables in list contexts
          state @array = qw(a b c); # Error!
***** subroutine signatures
      - enables ignatures feature
        use v5.20;
        use feature qw(signatures);
        no warnings qw(experimental::signatures);
      - make subroutine a functin with argument like
        sub max ( $m, $n ) { =# The variables are still private to the subroutine but you type much less to declare and assign to them=
            if ($m > $n) { $m } else { $n }
            =# the same as below without signatures=
            =# my($m, $n);=
            =# ($m, $n) = @_;=
        }
      - handle too many or too few argument
        : more argument
        sub max ( $max_so_far, @ ) {  =# the plain @ is same as @rest=
          foreach (@_) {              =# the argument list shows up in @_, which replace the @rest=
            if ($_ > $max_so_far) {
              $max_so_far = $_;
            }
          }
          $max_so_far;
        }

        : less argument with default set
        sub list_from_fred_to_barney ( $fred = 0, $barney = 7 ) { =# Signatures can also specify defaults=
          if ($fred < $barney) { $fred..$barney }
          else                 { reverse $barney..$fred }
        }
        my @defaults    = list_from_fred_to_barney();
        my @default_end = list_from_fred_to_barney( 17 );
        say "defaults: @defaults";
        say "default_end: @default_end";

        : less argument with default set
        : use the $= placeholder to denote an optional argument
        sub one_or_two_args ( $first, $= ) { ... }
**** input and output
***** input from standard input
      - 读取用户输入的各种方式
        : scalar context
        $line = <STDIN>;         =# read the next line=
        chomp($line);            =# and chomp it=
        chomp($line = <STDIN>);  =# same thing, more idiomatically=

        : loop
        =# Since the line-input operator will return undef when you reach end-of-file, this is handy for dropping out of loops=
        : output complete
        while (defined($line = <STDIN>)) {  =# reading input into $line variable=
              print "I saw $line";
        }
        while (defined($_ = <STDIN>)) {     =# reading input into default variable $_  NOTE: the line-input operator($_) is not [[favorite default variable]]=
              print "I saw $_";
        }
        while (<STDIN>) {                   =# omit the default varuable $_, the same as above=
              print "I saw $_";
        }
        : output one line per list element
        foreach (<STDIN>) {
              print "I saw $_";
        }
***** input from the diamond operator
      - 读入文件内容
        : This is useful for making programs that work like standard Unix utilities, with respect to the invocation arguments
        =# That command means to run the command my_program (which will be found in the current directory), and process file fred followed by barney, followed by betty=
        $ ./my_program fred barney betty

        : The diamond operator is actually a special kind of line-input operator.
        : But instead of getting the input from the keyboard, it comes from the Unix standard input
        while (defined($line = <>)) {
              chomp($line);
              print "It was $line that I saw!\n";
        }
        =# without an argument, chomp works on $_=
        while (<>) {
              chomp;
              print "It was $_ that I saw!\n";
        }
***** the double diamond
      - prevent diamond operator command line having a special characher
        : Suppose that the filename from the command line has a special character in such, such as |.
        : This might cause perl to perform a “pipe open”, which runs an external program and reads that program’s output as if it were a file.
        : The “double diamond” operator, <<>>, prevents this
        use v5.22;
            while (<<>>) {
              chomp;
              print "It was $_ that I saw!\n";
        }
***** the invocation arguments
      - 预填充命令行参数数组
        : @ARGV
        @ARGV array is a special array
          that is preset by the Perl interpreter as the list of the invocation arguments
          when your program starts
            @ARGV is already stuffed full of the list of invocation arguments
        in this case, force these three files to be read
          If it finds an empty list, it uses the standard input stream
        : <>
        The diamond operator looks in @ARGV to determine what filenames it should use
***** output to standard output
      - 使用数组内插打印
        : scalar interpolation
        if print a scalar (or a list of values)
        it doesn't add any extra characters before the items
        : , $name,
        add comma delimiter to $name

        : array interpolation
        the difference between printing an array and interpolating an array
        : if @array holds qw/ fred barney betty /
        : 1
        - print a list of items
          print fredbarneybetty
        : 2
        - *print an interpolated array*
          print fred barney betty
      - 换行符数组打印
        if @array contain newline charater (\n)
        : 1
        generally print them all
        : 2
        - but if you use /print "#array";/
          it will print:
          fred
           barney    # because of the items are separated by spaces
           betty

        if @array without newline character
        : 2
        print the interpolation array with \n
      - 打印<>操作符输入的列表
        : work with <>
        Since print is looking for a list of strings to print
        Since the diamond operator returns a list of lines in a list context
        so they can work well together
        : TIP
        the standard Unix commands cat and sort do have some additional
          functionality that these replacements lack
        but you can implement it by perl
      - 省略括号
        : optianl parentheses
        Remember the rule that parentheses in Perl may always be omitted
          except when doing so would change the meaning of a statement
      - print的函数调用
        : function call
        This is the problem with the optional parentheses
        : without parentheses around
        When there are no parentheses, that’s generally what you’d expect
        : with parentheses around
        But when the first thing after print is a left parenthesis
          print is a function call
          and it will print only what’s found inside the parentheses
        : NOTE
        the return value of print is a true or false value
          indicating the state of print
        : return value
        in this case, the return value is 1, indicating the success of the print
***** formatted output with printf
**** hashes
***** what is hash
      - 键值对
        A hash is a data structure
        the indices, called keys are always unique
        each keys has a tag attached, called values may be all numbers, all strings, undef values, or a mixture, and you may use same value more than once
        the keys and values are both arbitrary scalars, but the keys are always converted to string
        : TIP
        the large size of hash will not slow down the speed
***** hash element access
      - 访问的各种形式
        : key access
****** 访问整个哈希 the hash as a whole
       - 展开哈希
         : unwinding the hash
****** 哈希赋值 hash assignment
       - 整个哈希赋值
         : copy
         : reverse
****** 胖箭头 the big arrow
       - 更加清晰的哈希表达形式
         : format hash
         : hash key shortcut
**** 用正则表达式进行匹配 matching with regular expressions
     how the world of regular expressions fits into the world of perl
***** 用m//进行匹配 matches with m//
      - 模式匹配擦作符 pattern match operator
***** 模式匹配修饰符 match modifiers
      there are several modifier letters (模式匹配符), sometimes called flags
        which you can append as a group right after the ending delimiter
****** 用/i进行大小写无关的匹配 case-insensitive matching with /i
       : /i
       to make case-insensitive pattern match
       so you can match FRED as easily as fred or Fred, use /i modifier
****** 用／s匹配任意字符 matching any character with /s
       : /s
       by default, the dot (.) doesn't match newline,
       if you have newlines in your string, and you want the dot to be able to match them
       the /s modifier will do the job, which change every dot like [\d\D] does
       : TIP 1
       if you want to match any character except a newline in /s modifier
       use the character class [^\n]
       also can use shortcut \N (v5.12)
       : TIP 2
       if you don't like /s modifier
       you can make your own character to match any character like [\D\d] or [\S\s]
****** 用／x加入空白符 adding whitespace with /x
       : /x
       the /x modifier makes whitespace inside the pattern insignificant
       : TIP
       since the /x allows whitespace inside the pattern
       you could use a backslash space or \t to match these
       it's more common to use \s (or \s* or \s+)
       also can escape a literal space \x{20} \040
****** 组合选项修饰符 combining option modifiers
       : combining modifiers
       if you want to use more than one modifier on the smae match
         put them both at the end (their order isn't significant) [combining modifiers]
****** 选择一种字符解释方式 choosing a character interpretation
       : choose interpretation
       perl v5.14 add modifiers let to interpret in a match
         /a    use ASCII
         /u    use Unicode
         /l    use locale
       : case-folding 大小写处理
       which lowercase letter you should get from an uppercase letter
         k     in ASCII K -> k
               in Unicode it can be K (Kelvin sign) -> k
       : locale or Unicode
       you can't know how to lowercase it until you know what the locale value represents
       make sure 0xBC is a locale or Unicode character

       : TIP
       [[http://unicode.org/Public/UNIDATA/CaseFolding.txt][Unicode's case folding rules]]
****** 错位 beginning and end-of-line anchors
       : match string at the end or begin of line
       match fred at the end of any line [end of line]
       match fred at the begin of any line [begin of line]

       : /m
       /m    does the same for ^ anchor
             which then matches either at the absolute beginning of the string
               or anywhere after a newline (匹配绝对开头位置和换行符之后的位置)
       : TIP
       the /m ^ and $ just like \A and \Z
****** 其他选项 other option
       : TIP
       read about [[http://perldoc.perl.org/perlop.html][perlop documentation]] to get other modifiers available
***** 绑定操作符=~ the binding operator=~
      : bind the default pattern
      match the pattern on the right against the string on left (not the default $_)

      use \brub pattern in $some_other string [right pattern left string]
      set $likes_perl to a boolean value
        according to type input pattern's result [set a boolean]
      the binding operator has high precedence
        the parentheses around the pattern aren't required [high precedence]
***** 捕获变量 the match variables
      : parentheses capture
      the capture groups hold the part of the string matched
        by the part of the pattern inside parentheses 反向引用括号组内容
****** 捕获变量的存续期 the persistence of capures
       : persistence captures
       if pattern not match, the $1 will not be overwritten [not match]
       if pattern match, the $1 will be overwritten [match]

       : TIP
       so it is often take pattern into if while statement
       : TODO
       in chapter 9, we will see capture value directly into the variables
         without having to use $1
****** 不捕获模式 noncapturing parentheses
       : noncapture
       use ?: after the parenthesis to not trigger the capture groups
       the /n flag turns all parentheses into noncapturing groups (v5.22) [/n]

       : TODO
       regular expression have have serveral other special parentheses sequences
         like look-ahead, look-behind embed comments
         more detail in [[http://perldoc.perl.org/perlre.html][perlre documentation]]
****** 命令捕获 named captures
       : name capture
       : |- label
       use ?<label>pattern to set label
       : |- capture label
       use $+{label} to capture label
       : |- back reference label
       use \g{label} or \k{label} for back reference
       : |- python capture
       use the python syntax
         use ?P<label> form a capture
         use ?P=label refers to that capture
       : NOTE
       if there have two or more labeled with the same label
       \k<label> and \g{label} always refer to the left-most group
       but \g{N} can be a relative back reference
****** 自动捕获变量 the automatic match variables                               :ATTACH:
       :PROPERTIES:
       :Attachments: automatic_match.pl
       :ID:       15FAA599-88A6-44C4-911F-E98544C98E76
       :END:
       : $&, $`, $'
       use $&, $`, $' to match the pattern automatically
       : |- $&
       matched entire section is in $& (not capture one like $1)
       : |- $`, $'
       before the matched section is in $`
       after the matched section is in $'
       : NOTE
       the automatic match variables will run a little more slowly in regular expression
       so many perl programmer use $1 instead

       : ${^PREMATCH} ${^MATCH} ${^POSTMATCH}
       use ${^PREMATCH}, ${^MATCH}, ${^POSTMATCH} instead of $`, $&, $' (v5.10)
       : NOTE
       the name start with ^ and around the braces is used for special names
         that user might not create (the ^ is illegal character in a user-defined variable)
         Precedence
***** 通用量词
      : {}
      使用{}的形式指定具体的重复次数范围
***** 优先级 precedence
      : regular expression precedence
      regular expression                     example                        precedence
      Parentheses (grouping or capturing)    (…), (?:…), (?<LABEL>…)        highest
      Quantifiers                            a* a+ a? a{n,m}
      Anchors and sequence                   abc ^ $ \A \b \z \Z            v
      Alternation                            a|b|c
      Atoms                                  a [abc] \d \1 \g{2}            lowest

      : examples of precedence
***** 模式测试程序 a patern test program
      : test pattern
      This program is useful to test out a pattern on some strings
        and see just what it matches, and where
**** 用正则表达式处理文本 processing text with regular expressions
     use regular expressions to change text
***** 用s///进行替换 substitutions with s///
      - 查找并替换
        If you think of the m// pattern match as being like your word processor’s “search” feature
        the “search and replace” feature would be Perl’s s/// substitution operator
****** 用/g进行全局替换 global replacements with /g
       : global replacements
       /g modifier tells s/// to make all possible nonoverlapping replacements
****** 不同的定界符号 different delimiters
       : nonpaired delimiters
       : paired delimiters
**** 其他控制结构 more control structures
     alternative ways to write perl code
***** unless控制结构 the unless control structure
      unless = if no
**** perl模块 perl modules
     if there is a problem to solve, somebody has probably already solved it and made their solution available on the comprehensive perl archive network (CPAN)
***** 寻找模块 finding modules
      to find modules that don't come with perl, start at either [[http://search.cpan.org][CPAN Search]] or [[https://metacpan.org][Meta-CPAN]]
      - before you go lokking for a modules, you should check if it is already installed
        one way is to try to read the documentation with *perldoc*
        - the Digest::SHA modules comes with Perl, so you should be able to *read its document*
          $ perldoc Digest::SHA
        - try it with a modules that *does not exist* and you'll get an error message
          $ perldoc Llamas
          No documentation found for "Llamas"
        - The cpan command that comes with Perl can give you details on a module
          $ cpan -D Digest::SHA
***** 安装模块 installing modules
      - use CPAN.pm from the command line
        $ perl -MCPAN -e shell
****** 安装到自己的目录 using your own directories
       - install perl module by default directories
         - loading module environment variables
           $ perl -Mlocal::lib
         - use -I to enable the module environment variables
           $ cpan -I Set::CrossProduct
         - configure each for ExtUtils::Makemaker and Module::Build systems
           $ cpan
           cpan> o conf makepl_arg INSTALL_BASE=/Users/fred/perl5
           cpan> o conf mbuild_arg "--install_base /Users/fred/perl5"
           cpan> o conf commit
         - Once you’ve chosen where you want to put your Perl modules, you have to tell your programs where to find them
           # inside your Perl program
           use local::lib;

           # also inside your Perl program
           use lib qw( /Users/fred/perl5 );
***** 使用简易模块 using simple modules
      - get the file basename [basename]
        suppose that you get a long filename like /usr/local/bin/perl
        you want to find out the basename without the directory portion
        it's easy, since the basename is everything after the last slash (perl in case)
      : TODO
      understand advanced topic like reference and object in order to use some modules
      more detail in /Intermediate Perl/
****** the File::Basename modules
       get the file basename by using File::Basename module [basename_module]
       : TIP
       there are some related functions alse provided by this module
       one is the dirname function, which pulls the directory name form a full filename
****** 仅选用模块中的部分函数 using only some functions from a module           :ATTACH:
       :PROPERTIES:
       :Attachments: import_list.pl
       :ID:       6C9DE7D4-32DC-4DB8-ACE7-7D588187065F
       :END:
       - import part of module's functions [import list]
         most of the time, you'll want to use a module's default import list
         but you can always override that with a list of your own
         if you want leave out (or add in) some of the default items
       - use the full name of the function from the module [not import list]
         suppose the module's function name is the same as your existing program
         the solution is not import any function names from the module
           use your own existing function
       : NOTE
       you can use the short of the function's name (import list)
       you can always use the function's full name (not import list)
****** File::Spec模块 the File::Spec module                                     :ATTACH:
       :PROPERTIES:
       :Attachments: get_full_filename.pl
       :ID:       F3312F55-E1AD-4B5E-9B5D-23D16862E7B3
       :END:
       use File::Basename to get full filename [basename]
       use File::Spec to get full filename [specifications]
         File::Spec is a OO module [OO module]
           if you want to use the catfile method of File::Spec
           you should use
           : File::Spec->catfile
           the full name of a method is the name of the module (called a class)
             a small arrow (->)
             and the short name of the method
****** Path::Class模块 Path::Class                                              :ATTACH:
       :PROPERTIES:
       :Attachments: more_pleasant_interface_get_full_filename.pl
       :ID:       C504BECD-DC94-4978-A743-C32548509001
       :END:
       a more pleasant interface to work with file paths [pleasant interface]
****** 数据库和DBI模块 databases and DBI                                        :ATTACH:
       :PROPERTIES:
       :Attachments: DBI.pl
       :ID:       7434E45C-CC0C-4429-9506-786DC3158B94
       :END:
       the DBI (database interface) allow you to use the smae interface for any database
       once you install DBI, you also have to install a DBD (database driver)
         get the version of your server from CPAN search
       to connect to a database, use the DBI module, call its connect method [connect]
       the $dat_source contains information particular to DBD
         for PostgreSQL the driver is DBD::pg [DBD information]
       a cycle of preparing, executing, and reading queries [query]
       disconnect from the database [disconnect]
       : TIP
       /Programming the Perl DBI/ is mostly a good introduction to the module
****** 处理日期和时间的模块 dates and times                                     :ATTACH:
       :PROPERTIES:
       :Attachments: dates_and_times.pl
       :ID:       9FFC17B1-E09B-4F6C-8E03-EEB897E5041E
       :END:
       covert system time to Time::Moment [system time]
       covert current time to Time::Moment [current time]
       access various parts of the date to get what you need [access part of date]
       do date math with two TIme::Moment [date math]
**** 文件测试 file tests
     perl has a complete set of tests you can use to find out information about files
***** 文件测试操作符 file test operators                                        :ATTACH:
      :PROPERTIES:
      :Attachments: test_operators.pl
      :ID:       E791E8CA-0BD0-4D3C-B3F0-90CCA35E640C
      :END:
      - perl has a set of test operatorss that let you get particular information about files
        they all take the form of -X, where the X represents the particular test
        - to get the argument list of -X, use
          $ perldoc -f -X  =# you'll find documentation in perlfunc=
      - file tests and their meanings [T] (En 232-233)
        -r -w -x -o       tell whether the given attribute is true for the effective user or group ID,
                          which essentially refers to the person who is “in charge of ” running the program
        -R -W -X -O       tests use the real user or group ID,
                          which becomes important if your program may be running set-ID
        -s                test does return true if the file is nonempty
        -f -d -l -S -p -b -c         test seven types of items on a unix filesystem
        -M -A -C          return the number of days since the file was last modified, accessed or had its innode changed
        -T -B             take a try at telling whether a file is text or binary
        -t                test returns true if the given filehandle is a TTY--if it's interactive
**** 目录操作 directory operations
***** the current working directory                                             :ATTACH:
      :PROPERTIES:
      :Attachments: show_my_cwd.pl
      :ID:       DC5069BF-54A4-4D7A-AF0D-365B29E0FDBD
      :END:
      your program runs with a working directory, this is the default directory for everything your program does
      the Cwd module (part of the standard library), you can see what that directory is [C]
***** 在目录树中移动 changing the directory                                     :ATTACH:
      :PROPERTIES:
      :Attachments: chdir.pl
      :ID:       155A613F-4783-4ECC-A0A3-051F998CC84F
      :END:
      the chdir operator changes the working directory [C]
***** 文件名通配 globbing                                                       :ATTACH:
      :PROPERTIES:
      :Attachments: globbing.pl
      :ID:       813833D3-B4C3-4326-9DDF-86603066C0B7
      :END:
      find file name by globbing (filename patterns on each command line into the matching filenames) [C]
***** 文件名通配的另一种语法 an alternate syntax for globbing                   :ATTACH:
      :PROPERTIES:
      :Attachments: globbing2.pl
      :ID:       E8E44264-40DF-460E-8A8B-49117EE26C55
      :END:
      glob file names in angle-bracket [C]
**** 字符串与排序 string and sorting
***** 用index查找子字符串 finding a substring with index                        :ATTACH:
      :PROPERTIES:
      :Attachments: index_rindex.pl
      :ID:       6AB9EFD8-0D17-4B75-84D5-B8CF74E1675C
      :END:
      search [character|word] [first|last] appear [C]
**** 智能匹配与given-when结构
**** 进程管理 process management
     one of the best parts of being a programmer is launching someone else's code so that you don't have to write it yourself
     and like everything else in perl, there's more than one way to do it
***** system函数 the system function                                            :ATTACH:
      :PROPERTIES:
      :Attachments: system.pl
      :ID:       94B60C91-8636-41FE-9ACE-408C6E16A51C
      :END:
      run a child process [C]
**** 高级perl技巧 some advanced perl techniques
     some other techniques while not obligatory, are still valuable tools to have in your toolbox
***** 切片 slices
*** perl编程语言 programming perl
**** 前言 preface
     - 命令行 command line
       日常管理 manage     (T  En 35 | Cn 20)
       常见问题 question   (T  En 36 | Cn 21)
       平台移植 platform   (T  En 36 | Cn 22)
       搜索文档            (C  Cn 22)
**** perl概述 an overview of perl
***** 自然语言和人工语言 natural and artificial languages
****** 变量语法 variable syntax                                                 :code:
       variable types (T  En 50 | Cn 32)
       $    scalar
       @    array

       : make reference
       scalar value can be reference to other data structure (like a pointer in C)
       : auto convert
       perl will automatically convert the data
         into the form required by the current context

       : array and hash
       use an array when you want to look something up by number
       user a hash when yo uwant to look something by name
       : pop and push
       since arrays are ordered
         you can do various useful operations on them
         such as the stack operations pop and push
         perl regards the end of your array as the top of a stack
       you can't push or pop a hash
         because a hash is unordered
       : hash performance
       we pick the name "hash" is implemented internally using a hash-table lookup
         which is why hash are so fast and stay so fast no matter
           how many values you put into them
       : the % sigil
       hashes use the % sigil to mark hash names
         if you look carefully at the % character
         you can see the key and the value with a slash between them
       : syntactic sugar =>
       perl provides syntactic sugar => to see which are keys or values
       : access hash element
       because hashes are a fancy kind of array
         select an individual hash element is to dealing with a scalar value
         use $ on front of hash name
       : complexities
       sometimes you need to build not-so-lovely
                                   not-so-simple
                                   not-so-flat data structures
       : topicalizing
       perl also has serveral ways of topicalizing
         one important topicalizer is the package declaration
       : verbs
       as is typical of your typical impreative computer language
         many of the verbs in perl are commands
         they tell perl interpereter to do something
****** 一个平均值例子 an average example
******* how to run a perl program
        : call perl explicitly from the command line
        % perl –e 'print "Hello, world!\n";'
        : for longer script, put all your commands into a file and then
        % perl the_file_name

        : on Unix systems that support the #! "shebang" notation
        :   you can make the first line of your script be magical
        :   so the operating system will know which program to run
        #!/usr/bin/perl
        : if perl isn't in /usr/bin, you'll have to change the line accordingly
        : then all you have to say is
        % gradation
        : if this didn't work because you forgot to
        :   make sure the script was executable in your PATH
        : you have to provide a complete filename
        :   so that the operating system knows how to find your script
        % /home/sharon/bin/gradation

        : it will provide an useful warming message
        #!/usr/bin/perl -w
****** 文件句柄 filehandles                                                     :code:
       filehandles make it easier for you to get input from
         and send output to many different places
       part of what makes perl a good glue languages is that
         it can talk to many files and processes at once
       : open
       you can use open function
         to create filehandles for various purposes (input, output, piping)
****** 操作符 operators                                                         :code:
******* some binary arithmetic operators
        : mathematical operators
        +    addition
        *    multiplication
        %    modulus
        **   exponentiation
******* string operators
        : string addition
        a sepatate operator .
        : string multiply
        a separate operator x
        : three ways to concatenation string
        : interpolation
        string concatenation is also implied by the interpolation
          that happens in double-quoted string
        : list
        and when you print out a list of values
          you're also effectively concatenating strings
******* assignment operators
        : get set to
        try to remember that = assignment operator means
          "gets set to" rather than "equals"
        the left operand must be
          a valid _lvalue_ (a valid storage location like a variable, or an array)
        : assignment returns variable as an lvalue
        you can assign a vairable to many other vairables
            or assign a assignmen to another assignment
******* unary arithmetic operators
        : autoincrement and autodecrement
        the autoincrement ++ (or autodecrement --) operator
          can be placed on either side of the variable
          if you place one of these "auto" operators before the variable
            it is known as a preincremented (predecremented) variable
            its value will be changed before it is referenced
          if it is placed after the variable
            it is known as a postincremented (postdecremented) variable
            and its value is changed after it is used
******* logical operators
        : short-circuit operators
        logical operators, also known as short-circuit operators
          allow the program to make decisions
            based on multiple criteria
            without using nested if statements
        perl actually has two sets of logical operators
          a traditional set borrowed from C
          a newer set of ultralow-precedence operators borrowed from BASIC
******* some numeric and string comparison operators
        : comparison operators
******* some file test operators
        : file test operators
        the file test operators allow you to test
          whether certain file attriubutes are set
          before you go and blindly muck about with the files
****** control structures
       using the short-circuit operators
         while you can write some very useful linear programs
           (a lot of CGI scripts fall into this category)
       you can write much more powerful programs
         if you have conditional expressions and looping mechanisms
         these are known as control structures
       but to have control
         you have to know the difference between what's true and what's false
******* what is truth                                                           :code:
        : the scalar truth rules (no coercion)
        truth in perl is always evaluated in scalar context
          no type coercion is done
          so here are the rules for the various kinds of values a scalar can hold
        any reference (rule 3) would point to something with an address
          and would evaluate to a number or string containing that address
        : the scalar truth rules (with coercion)

        : NOTE
        both arrays and hashes return scalar values
          hat conveniently happen to be true
          if the array or hash contains any elements
******* the if and unless statements                                            :code:
        : if statement
        a slightly more complex form of the logical operators is the if statement
          the if statement evaluates a truth condition
            and executes a block if the condition is true
        : NOTE
        braces are optional in C if you have a single statement
        but the braces are not optional in perl
        : elsif statement
        at time you may even have more than two possible choices
          in this case, you'll want to add an elsif truth condition
            for other possible choice
        : unless statement
        sometimes, you don't want to do anything if the condition is true
          only if it is false
        using an empty if with an else may be messy
          you would use the unless statement
        : NOTE
        there is no elsunless through
******* the given and when statements                                           :code:
        : given and when statements
        what other languages sometimes call switch and case
          because we like to make perl work like a natural language
          however, we call these given and when
        the given part takes the value of its expression
          and makes it the topic of conversation
          so the when statement know which value to test
        the form of each when argument determines the type of match performed
          so strings match as strings (numbers patterns match as well)
          lists of values match if any of them match
******* conditional loops                                                       :code:
        the while and until statements test an expression for truth
          just as the if and unless statements do
        : while statement
        if the original condtion is never met
          the loop will never entered at all
        : blank lines and exit the loop
        this assigns the next line to the variable $line
        if $lines get blank lines
          the while statement will not exit the loop
          the reason is the line input operator leaves the newline on the end of the string
            so a blank line has the value "\n"
            and that "\n" is not one of canonical false value
        when we finally do reach the end of the file
          the line input operator returns the undefined value
            which always evaluated to false
        : an array in scalar context
        if you mention an array in scalar context
          the length of the array is returned
        the shift operator removes one element from the argument list each time
        the loop automatically exits when its length goes to 0
          and 0 is already false in perl
        : the three-part loop
        it is also known as a C-style for loop
        within the loop's parentheses
          the three-part loop takes three expressions, separate by two semicolons
          the first expression sets the initial state of the loop variable
          the second is a condition to test the loop variable
            this works just like the while condition
          the third expression modifies the state of the loop variable
        when the three-part loop starts
          the initial state is set and the truth condition is checked
          if the condition is true, the block is executed
          the block is return with the next value
            as long as the truth conditon remain true
        NOTE
        only the middle expression is evaluated for its value
          the first and third expressions are evaluated only for their side effects
            and the resulting values are thrown away
        each of the three expressions may be omitted
          if you leave out the middle expression
          it assumes you want to loop forever
        : the foreach loop
        the foreach statement provides list context to the expression in parentheses
          so the expression is evaluated to produce a list (even a single scalar)
          then each element of the list is aliased to the loop variable in turn
            and the block of code is executed once for each list element
        NOTE
        the loop vairable refers to the element itself
          rather than a copy of the element
          hence, modifying the loop variable also modifieds the original array
        TIP
        you'll find many more of these loops in the typical perl program
          than traditional three-part for loops
          because it's very easy in perl to generate the kinds of lists
            that a foreach wants to iterate over
        : breaking out - next and last
** python
*** PROJECT python document
**** python setup and usage
***** command line and environment                                                :[[https://docs.python.org/3/using/cmdline.html]]:
****** comand line
       python [-bBdEhiIOqsSuvVWx?] [-c command | -m module-name | script | - ] [args]
       python myscript.py
******* interface options
        -c <command>            execute the python code in command
        -m <module-name>        search sys.path for named module
                                and execute its contents as main module
        -                       read from standard input (sys.stdin)
        <script>                execute the python code contained in filesystem path
******* generic options
        -? -h --help
        -V --version
******* miscellaneous options
        -b -B
        -d
        ...
******* options you shouldn't useR
        -J    Jpython
****** environment variable
       PYTHONHOME    change the location of the standard python libraries
       PYTHONPATH    augment the default search path for module files
       ...
******* debug-mode variables
***** pyenv
****** version control
       $ pyenv global <version>  # 全局设置python版本为指定版本
       $ pyenv local <version>   # 设置当前路径下python版本为指定版本
       $ pyenv shell <version>   # 设置当前shell窗口使用的python版本为指定版本
*** tutorial
**** conventions
     >>>             input
     ...             output
     _               the last printed expression is assigned to the variable
     \               escape quotes
     print()         format output things
     r               raw string
     """..."""
     '''...'''       string span multiple lines
     String          index slicing immutable
     lists           index slicing concatenation mutable
     end             avoid the newline after output
**** using the python interpreter                                               :code:
     : interactive mode
     when commands are read from a tty
       the interpreter is said to be in interactive mode
     in this mode it prompts for the next command with primary prompt
       usually three greater signs (>>>)
     for continuation lines it prompts with the secondary prompt
       by default three dots (...)
     : source code encoding
     by default, python source files are treated as encoded in UTF-8
     to declare an encoding other than the default one
       a special comment line should be added as the first line of the file
**** an informal introduction to python                                         :code:
     : number
     : act as a simple calculator
     start the interpreter
       the interpreter acts as a simple caculator
       you can type an expression at it and it will write the value
     : the variable _
     in interactive mode, the last printed expression is assigned to the variable _

     : string
     : double quote && single quote && escape
     python string can be enclosed ('...') or double quotes ("...")
       \ can be used to escape quotes
     : raw strings
     if you don't want characters prefaced by / to be interpreted as special characters
       you can use raw strings by adding an r before the first quote
     : multiple lines strings
     string literals can span multiple lines
     : string can be concatenated and repeated
     : string can be indexed
     : slice is also supported
     : string cannot be changed

     : lists
     : group data type
     list is used to group together a number of compound data types
     : indexed and sliced
     like string lists can be indexed an d sliced
     : muttable
     unlike string, which are immutable, lists are a mutable type
     : nest list

     : first programming
     : Fibonacci series
     the sum of two elements defines the next
**** control flow                                                               :code:
     : if *

     : for
     : for loop string *
     : modify the sequence *
     modify the sequence you are iterating over while inside the loop

     : range *
     iterate over a sequence of numbers
     : different step *
     it is possible to let the range start at another number
       or to specify a different increment erent step
     : iterate over the length of a sequence *
     in such case, it is convenient to use the enumerate() function

     : break *
     terminate loop not by condition
     : continue *
     jump to the next iteration of the loop
     : pass *
     the pass statement does nothing
       it can be used when a statement is required syntactically
         but the program requires no action

     : function *
     : rename function *
     : the return value of function *
     : default argument values *
     The most useful form is to specify a default value for one or more arguments
     : keyword arguments *
     function can also be called using the form of key=value
     : formal parameter *
     when function's argument in a format as
       *name which can receives many 'value' like formal parameters
       **name which can receives many 'key=value' like formal parameter
     : arbitrary argument lists *
     to specify that a function can be called with an arbitrary number of arguments
     : unpacking argument lists *
     you can unpack a list (or a tuple) arguments by using the formal parameter
     : lambda expression *
     Lambda functions can be used wherever function objects are required
       Like nested function definitions
     : documentation strings *
     Here are some conventions
       about the content and formatting of documentation strings
       1. The first line should always be a concise summary of the object’s purpose
       2. The following lines should be one or more paragraphs
          describing the object’s calling conventions, its side effects, etc
    : function annotations *
    Parameter annotations are defined by a colon after the parameter name
      followed by an expression evaluating to the value of the annotation
    Return annotations are defined by a literal ->
      followed by an expression
      between the parameter list and the colon denoting the end of the def statement

    : intermezzo: coding style *
    For Python, *PEP 8* has emerged as the style guide that most projects adhere to
      it promotes a very readable and eye-pleasing coding style
      every python devleloper should read it at some point
**** data structures                                                            :code:
     : list data type *
     here are all of the methods of list objects
     : using lists as stacks *
     the list methods make it very easy to use a list as a stack
       where the last element added is the first element retrieved (last-in last-out)
     : using lists as queues *
     it is also possible to use a list as a queue
       where the first element added is the first element retrueved (first-in first-out)
     : list comprehensions *
     use some operations applied to each member of list
     : nested list comprehensions *
     the initial expression in a list comprehension can be any arbitrary expression
       including another list comprehension

     : the del statement
     there is a way to remove an item from a list given its index instead of its value
       the del statement
     : remove slices from a list *
     differ from the pop()
       the del statement can also be used to remove slices from a list
     : delete entire variables *
     del can also be used to delete entire variables

     : tuples and sequences
     : tuples *
     a tuple consists of a number of values separated by commas
     : a tuples containing 0 or 1 items *
     : tuple packing *

     : sets
     : besic use of sets *

     : dictionaries
     : key-value pair *
     : build dictionaries *

     : looping techniques
     : looping through dictionaries *
     : looping through a sequence *

     : condition
     : comparisons can be chained *
     : assign the result of comparision to a variable *
     : comparing sequences *
**** modules                                                                    :fragment:
     : modules.py

     : fibo.py
     : python interpreter *
     : symbol table *
     : script *
     : the module search path *
     : compiled python file *

     : standard modules *

     : the dir() function *

     : packages *
     : the structure of python package *
     : import individual modules *
     : remove unwanted sub-module by importing * from a package *
     : relative package reference *
     : search modules and subpackages *
**** input and output
     : convert any value to a string *

     : output formatting *
     : justify a string *
     : use .format() method to format output string *
     : fill the zeros to the left of string *

     : convert the value before it is formatted *

     : an optional control for formatting string *

     : open a file *
     : close a file *
     : read a file *
     : write to the file *
     : change the file object's position *

     : serializing and deserializing *
     : data exchange *
** js
*** CANCELLED javascript高级程序设计 javascript for web developers
    CLOSED: [2017-09-17 日 10:54]
    :LOGBOOK:  
    - State "CANCELLED"  from "WAITING"    [2017-09-17 日 10:54] \\
      the freeCodeCamp instead of it
    :END:      
**** javascript简介 20 what is javascript 44
***** javasctipt简史 a short history
***** javascript实现 javascript implementations
****** 内核 ECMAScript
******* the core
        syntax
        type
        statements
        keywords
        reserved words
        operators
        objects
******* 版本 edition
******* 兼容性 comformance
****** 文档对象模型 DOM(the document object)
******* XML extened to HTML api
******* DHTML(Dynamic HTML)
******* W3C(World Wide Web Consortium)
        DOM1
          DOM Core    map XML-based document structure
          DOM HTML    add HTML-specific objectsand method
        DOM2
          DOM Views     keep track of various views (before and after CSS)
          DOM Events    interface for events and event handling
          DOM Style     deal with CSS-based styling of element
          DOM Traversal and Range
        DOM3
          DOM Load and Save
        XML DOM
          SVG
          MathML
          SMIL
****** 浏览器对象模型 BOM (the browser object)
******* interact with the browser outside of the context of its display page
        pop up new browser windows
        move resize close browser windows
        navigator (information)
        location (page loaded)
        screen (resolution)
        cookies
        XMLHttpRequest ActiveXObject
**** 在HTML中使用javascript javascript in HTML
***** <script>元素 the <script> element
****** 加载<script> load <script>
       : script attributes
       - there are six attrubutes for the <script> element
         async
         src        indicates an external file that contains code to be executed
         type       default set is 'text/javascript'
       : NOTE: the <script> elements are interpreted in the order in which they appear in the page so long as the defer and async attributes are not present

       : two ways to use the <script> element
       - to include inline javascript code
         <script type=”text/javascript”>
             function sayHi(){
                 alert(“Hi!”);
             }
         </script>
       - to include javascript from an external file
         <script type=”text/javascript” src=”example.js”></script>     =HTML=
         <script type=”text/javascript” src=”example.js” />            =XHTML=
       : the <script> element is its ability ti include javascript files from outside domains
       - make sure you are the domain owner or the domain is owned by a trusted source
         <script type=”text/javascript” src=”http://www.somewhere.com/afile.js”></script>
       : NOTE: a <script> element using the src attribute should not include additional javascrit code between the <script> tags
       :       if both are provided, the inline code is ignored
****** 标签的位置 tag placement
       : traditionally, all <script> elements were placed within the <head> element on a page
       : but for pages that require a lot of javascript code, this can cause a noticeable delay in page rendering, during which time the browser will be completely blank
       : for this reason, modern web applications typically include all javascript references in the <body> element
       <!DOCTYPE html>
       <html>
         <head>
           <title>Example HTML Page</title>
           =<script type=”text/javascript”= =src=”example1.js”></script>=
           =<script type=”text/javascript”= =src=”example2.js”></script>=
         </head>
         <body>
           <!-- content here -->
           *<script type=”text/javascript” src=”example1.js”></script>*
           *<script type=”text/javascript” src=”example2.js”></script>*
         </body>
       </html>
****** 延迟脚本 deferred scripts
       : You can defer a script’s execution until after the document has rendered by using the *defer* attribute
       - setting /defer/ element in <script> signals to the browser that download should begin immediately but execution should be deferred
         ...
           <script type=”text/javascript” defer src=”example1.js”></script>            =HTML=
           <script type=”text/javascript” defer="defer" src=”example1.js”></script>    =XHTML=
         ...
       : NOTE: the defer attribute is supported only for external script files, this was a clarificaton made in HTML5
       :       not all browser support defer attribute (except IE firefox safari chrome)
       :       it's best to put deferred script at the bottom of the page
****** 异步脚本 asynchronous scripts
       : HTML5 introduces the async attribute for <script> elements
       : You can indicate that a script need not wait for other scripts and also not block the document rendering by using the *async* attribute.
       - for example
         ...
           <script type=”text/javascript” async src=”example1.js”></script>          =HTML=
           <script type=”text/javascript” async="async" src=”example1.js”></script>  =XHTML=
         ...
       : NOTE: it's important that there are no dependencies between two async script files
       :       it's recommended that asynchronous scripts not modify the DOM as they are loading
       :       only firefox safari and chrome support asyc script
***** 嵌入代码与外部文件 inline code versus external files
      : Although it’s possible to embed JavaScript in HTML files directly,
      : it’s generally considered a best practice to include as much JavaScript as possible using external files.
      - the arguments for using external files are as follows:
        maintainability
          for all javascript files to have a directory, so developers can edit javascript code independent without HTML markup
        caching
          if two pages are using the same file, the file is downloaded onlu once
***** 文档模式 document modes
      : the concept of document modes through the use of doctype switching
      - standards mode
        <!-- HTML 4.01 Strict -->
        <!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01//EN” “http://www.w3.org/TR/html4/strict.dtd”>

        <!-- XHTML 1.0 Strict -->
        <!DOCTYPE html PUBLIC
        “-//W3C//DTD XHTML 1.0 Strict//EN” “http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd”>

        <!-- HTML5 --> <!DOCTYPE html>
***** <noscript>元素 the <noscript> element
      : the <noscript> element was created to provide alternate content for browsers without JavaScript.
      - a simple example
        <!DOCTYPE html>
        <html>
          <head>
            <title>Example HTML Page</title>
            <script type=”text/javascript” defer=”defer” src=”example1.js”></script> <script type=”text/javascript” defer=”defer” src=”example2.js”></script>
          </head>
          <body>
            *<noscript>*
              *<p>This page requires a JavaScript-enabled browser.</p>*
            *</noscript>*
          </body>
        </html>
      : NOTE: the content inside the <noscript> element will be rendered only if either of these conditions is met
      :       > the browser doesn't support scripting
      :       > the browser's scripting support is turned off.
**** 基本概念 language basic
***** 语法 syntax
****** 区分大小写 case-sensitivity
       typeof 是函数名
       typeOf 可以是一个有效的函数名
****** 标识符 identifiers
       - 标识符
         An identifier is the name of a variable, function, property, or function argument
         The first character must be a letter, an underscore (_), or a dollar sign *($)*
         : NOTE
         Keywords, reserved words, true, false, and null cannot be used as identifiers
****** 注释 comments
       - 单行注释
         //single line comment
       - 多行注释
         : Note that even though the second and third lines contain an asterisk, these are not necessary and are added purely for readability
         /*
          * This is a multi-line * Comment
          */
****** 严格模式 strict mode
       - 概念
         Strict mode is a different parsing and execution model for JavaScript
         where some of the erratic behavior of ECMAScript 3 is addressed and errors are thrown for unsafe activities
         - To enable strict mode for an entire script, give this to the top of script
           “use strict”;
         - specify just a function to execute in strict mode by including the pragma at the top of the function body
           function doSomething(){
             “use strict”;
             //function body
           }
****** 语句 statement
       - 推荐语句结构
         var sum = a + b //valid even without a semicolon - not recommended
         var diff = a - b; //valid - preferred

         if (test)
           alert(test);    //valid, but error-prone and should be avoided

         if (test){        //preferred
           alert(test);
         }
****** 关键字和保留字 keywords and presrved words
       [En 70]
*** PROJECT You Don't Know JS
**** Up & Going
***** forward
      Up & Going is the start of our path to understanding programming. Enjoy the lightbulb moments!
***** preface
      JavaScript is awesome. It's easy to learn partially, and much harder to learn completely (or even sufficiently)
      This You Don't Know JavaScript book series offers a contrary challenge: learn and deeply understand all of JavaScript, even and especially "The Tough Parts"
***** into programming
      : introduced the basic building blocks of programming
      looking to these books to help get you started along a path to understanding programming through the lens of JavaScript
****** code
       A program, often referred to as source code or just code, is a set of special instructions to tell the computer what tasks to perform
******* statements
        - a = b * 2;
         : expressions
         2 =is a literal value expression=
         b =is a variable expression, which means to retrieve its current value=
         b * 2 =is an arithmetic expression, which means to do the multiplication=
         a = b * 2 =is an assignment expression, which means to assign the result of the b * 2 expression to the variable a (more on assignments later)=
         alert( a ); =expression statement, as the entire statement is the function call expression itself=
****** console
       - output
        console.log( b );
        alert( b );
       - input
        age = prompt( "Please tell me your age:" );
        console.log( age );
       - operator
         : You need operators to perform actions on values
         - Compound Assignment
          +=, -=, *=, and /=
         - Increment/Decrement
          ++ , --
         - Equality
          == (loose-equals), === (strict-equals), != (loose not-equals), !== (strict not-equals)
         - Logical
          && (and), || (or)
****** values & types
       : You need values and types to perform different kinds of actions like math on numbers or output with strings
       - When you need to print a value on the screen, you need a string (one or more characters, words, sentences)
         "I am a string";
         'I am also a string';
       - When you need to do math, you want a number
         42;
       - When you need to make a decision in your program, you need a boolean (true or false).
         true;
         false;
****** Converting Between Types
       var a = "42";
       var b = Number( a );
       console.log( a );       // "42"
       console.log( b );       // 42
       : NOTE
       "99.99" == 99.99
****** Code Comments
       - Comments should explain why, not what. They can optionally explain how if that's particularly confusing
         // This is a single-line comment

         /* But this is
            a multiline
            comment. */

         : var a = /* multiline commen can be anywhere */ 42;
****** variable
       : You need variables to store data (aka state) during your program's execution
       const TAX_RATE = 0.08;  =// as of ES6: If you tried to assign any different value to TAX_RATE after that first declaration, your program would reject the change=
       var amount = 99.99;
****** Conditionals
       : You need conditionals like if statements to make decisions
       // can we afford the extra purchase?
       if ( amount < bank_balance ) {
               console.log( "I'll take the accessory!" );
               amount = amount + ACCESSORY_PRICE;
       }
       // otherwise:
       else {
               console.log( "No, thanks." );
       }

       for (var i = 0; i <= 9; i = i + 1) {
               console.log( i );
       }
       // 0 1 2 3 4 5 6 7 8 9
****** loops
       : You need loops to repeat tasks until a condition stops being true
       while (numOfCustomers > 0) {
               console.log( "How may I help you?" );
               // help the customer...
               numOfCustomers = numOfCustomers - 1;
       }
       // versus:
       do {
               console.log( "How may I help you?" );
               // help the customer...
               numOfCustomers = numOfCustomers - 1;
       } while (numOfCustomers > 0);
****** function
       : You need functions to organize your code into logical and reusable chunks
       function printAmount() {
          console.log( amount.toFixed( 2 ) );
       }
       var amount = 99.99;
       printAmount(); // "99.99"

       function printAmount(amt) {
               console.log( amt.toFixed( 2 ) );
       }
       var amount = 99.99;
       printAmount( amount * 2 );              // "199.98"
***** into javascript
      : want to focus specifically on things you need to know about JavaScript to get up and going as a JS developer
      - Your journey to deeply learn JavaScript starts here
        : NOTE
        If you happen to be using an older, pre-ES6 browser, the code may not work
****** Values & Types
       : JavaScript provides a typeof operator that can examine a value and tell you what type it is
       - string
         a = "hello world";
         typeof a;                               // "string"
       - number
         a = 42;
         typeof a;                               // "number"
       - boolean
         a = true;
         typeof a;                               // "boolean"
       - null and undefined
         a = null;
         typeof a;                               // "object" -- weird, bug   NOTE: This is a long-standing bug in JS, but one that is likely never going to be fixed

         var a;
         typeof a;                               // "undefined"

         a = undefined;
         typeof a;                               // "undefined"  explicitly setting a to the undefined value
       - object
         a = { b: "c" };
         typeof a;                               // "object"
       - symbol (new to ES6)
****** Objects
       : a compound value where you can set properties (named locations) that each hold their own values of any type
       var obj = {
               a: "hello world",
               b: 42,
               c: true
       };
       : Properties can either be accessed with dot notation or bracket notation
       - dot notation
         obj.a;          // "hello world"
         obj.b;          // 42
         obj.c;          // true
       - Bracket notation
         : Bracket notation is useful if you have a property name that has special characters in it, like obj["hello world!"]
         obj["a"];       // "hello world"
         obj["b"];       // 42
         obj["c"];       // true
         : it is also useful if you want to access a property/key but the name is stored in another variable
         var b = "a";
         obj[b];                 // "hello world"
         obj["b"];               // 42
****** arrays
       : An array is an object that holds values (of any type) not particularly in named properties/keys, but rather in numerically indexed positions
       var arr = [
               "hello world",
               42,
               true
       ];
       : use 0 as the index of the first element in the array
       arr[0];                 // "hello world"
       arr[1];                 // 42
       arr[2];                 // true
       arr.length;             // 3
       : Because arrays are special objects, they can also have properties, including the automatically updated length property
       typeof arr;             // "object"
       : NOTE
       The best and most natural approach is to use arrays for numerically positioned values and use objects for named properties
****** functions
       : functions are a subtype of objects
       function foo() {
          return 42;
       }
       : only use function object properties (like foo.bar) in limited cases
       foo.bar = "hello world";
       typeof foo.bar;         // "string"
       : typeof returns "function", which implies that a function is a main type
       typeof foo;             // "function"
       typeof foo();           // "number"
       : TODO
       see the first two chapters of the Types & Grammar title for more imformation
****** build-in type method
       : JS automatically "boxes" the value to its object wrapper counterpart (hidden under the covers)
       : A string value can be wrapped by a String object
       var a = "hello world";
       a.toUpperCase();                // "HELLO WORLD"
       a.length;                               // 11
       : a number can be wrapped by a Number object
       var b = 3.14159;
       b.toFixed(4);                   // "3.1416"
       : a boolean can be wrapped by a Boolean object
       : TODO
       For more information on JS natives and "boxing," see Chapter 3 of the Types & Grammar title of this series
****** Comparing Values
       : There are two main types of value comparison that you will need to make in your JS programsy: equality and inequalit
       The result of any comparison is a strictly boolean value (true or false), regardless of what value types are compared
****** Coercion
       : Coercion comes in two forms in JavaScript: explicit and implicit
       - Explicit coercion
         : Explicit coercion is simply that you can see obviously from the code that a conversion from one type to another will occur
         var a = "42";
         var b = Number( a );
         a;                              // "42"
         b;                              // 42 -- the number!
       - Implicit coercion
         : implicit coercion is when the type conversion can happen as more of a non-obvious side effect of some other operation.
         var a = "42";
         var b = a * 1;  // "42" implicitly coerced to 42 here
         a;                              // "42"
         b;                              // 42 -- the number!
         : TODO
         Chapter 4 of the Types & Grammar title of this series covers all sides
****** Truthy & Falsy
       : when a non-boolean value is coerced to a boolean, it become truthy or falsy
       - list of falsy
         "" (empty string)
         0, -0, NaN (invalid number)
         null, undefined
         false
       - Any value that's not on this falsy list is truthy
         "hello"
         42
         true
         [ ], [ 1, "2", 3 ] (arrays)
         { }, { a: 42 } (objects)
         function foo() { .. } (functions)
****** Equality
       var a = "42";
       var b = 42;
       : == checks for value equality with coercion allowed
       : "42" becomes 42, to make the comparison 42 == 42
       a == b;                 // true
       :  === (often called "strict eauality") checks for value equality without allowing coercion
       a === b;                // false
       : You should take special note of the == and === comparison rules if you're comparing two non-primitive values, like objects
       : Because those values are actually held by reference, For example, arrays are by default coerced to strings
       var a = [1,2,3];
       var b = [1,2,3];
       var c = "1,2,3";
       a == c;         // true
       b == c;         // true
       a == b;         // false

       : TIP
       - the rule to use == and ===
         If you can be certain about it is a comparison of variable values, and == is safe
         If you can't be certain about it, use ===
       : TODO
       Chapter 4 of the Types & Grammar title
****** inequality
       - The <, >, <=, and >= operators are used for inequality, referred to in the specification as "relational comparison."
         var a = 41;
         var b = "42";
         var c = "43";
         a < b;          // true
         b < c;          // true

         var a = 42;
         var b = "foo";
         a < b;          // false
         a > b;          // false
         a == b;         // false
       : TODO
       consult Chapter 4 of the Types & Grammar title
****** variables
       An identifier must start with a-z, A-Z, $, or _. It can then contain any of those characters plus the numerals 0-9
       certain words cannot be used as variables, These words are called "reserved words," and include the JS keywords (for, in, if, etc.) as well as null, true, and false
       : TODO
       Appendix A of the Types & Grammar title
****** Function Scopes
       : You use the var keyword to declare a variable that will belong to the current function scope, or the global scope if at the top level outside of any function
       - this behavior is called hoisting, when a var declaration is conceptually "moved" to the top of its enclosing scope
         var a = 2;
         foo();
         function foo() {
         a = 3;
         console.log( a );       // 3
           var a;
         }
         console.log( a );       // 2
         : WARM
         Avoiding it, it can be quite confusing
****** Nested Scopes
       - When you declare a variable, it is available anywhere in that scope, as well as any lower/inner scopes
         : NOTE
         : Notice that c is not available inside of bar(), because it's declared only inside the inner baz() scope, and that b is not available to foo() for the same reason
         function foo() {
                 var a = 1;

                 function bar() {
                         var b = 2;

                         function baz() {
                                 var c = 3;

                                 console.log( a, b, c ); // 1 2 3
                         }

                         baz();
                         console.log( a, b );            // 1 2
                 }

                 bar();
                 console.log( a );                               // 1
         }
       - it will auto change to global variable, if you not formally declare variable
         : This is a very bad practice. Don't do it! Always formally declare your variables
         function foo() {
           a = 1;  // `a` not formally declared
         }

         foo();
         a;                      // 1 -- oops, auto global variable :(
       - ES6 lets you declare variables to belong to individual block
         : Because of using let instead of var, b will belong only to the if statement and thus not to the whole foo() function's scope. Similarly, c belongs only to the while loop
         function foo() {
                 var a = 1;

                 if (a >= 1) {
                         let b = 2;

                         while (b < 5) {
                                 let c = b * 2;
                                 b++;

                                 console.log( a + c );
                         }
                 }
         }

         foo();
         // 5 7 9
       : TODO
       ES6 & Beyond title of this series
****** Conditionals
       - JavaScript provides a few other conditionals mechanisms that we should take a look at
         : a series of if..else..if statements
         if (a == 2) {
                 // do something
         }
         else if (a == 10) {
                 // do another thing
         }
         else if (a == 42) {
                 // do yet another thing
         }
         else {
                 // fallback to here
         }
         : the switch statement, a better statement because you don't need to specify the a test for each case
         switch (a) {
                 case 2:
                         // do something
                         break;
                 case 10:
                         // do another thing
                         break;
                 case 42:
                         // do yet another thing
                         break;
                 default:
                         // fallback to here
         }
         : Here, if a is either 2 or 10, it will execute the "some cool stuff" code statements
         switch (a) {
                 case 2:
                 case 10:
                         // some cool stuff
                         break;
                 case 42:
                         // other stuff
                         break;
                 default:
                         // fallback
         }
         : conditional operator
         var a = 42;

         var b = (a > 41) ? "hello" : "world";

         // similar to:

         // if (a > 41) {
         //    b = "hello";
         // }
         // else {
         //    b = "world";
         // }
       : TODO
       Types & Grammar title
****** Strict Mode
       : strict mode will keeping the code safer and more optimaizable by the engine
       - You can opt in to strict mode for an individual function, or an entire file
         : for an individual function
         function foo() {
                 "use strict";

                 // this code is strict mode

                 function bar() {
                         // this code is strict mode
                 }
         }

         // this code is not strict mode

         : for an entire file
         Compare that to:

         "use strict";

         function foo() {
                 // this code is strict mode

                 function bar() {
                         // this code is strict mode
                 }
         }

         // this code is strict mode
       - strict mode is disallowing the implicit auto-global variable declaration from omitting the var
         function foo() {
                 "use strict";   // turn on strict mode
                 a = 1;                  // `var` missing, ReferenceError
         }

         foo();
       : TODO
       the Chapter 5 of the Types & Grammar title
****** Functions As Values
       : Not only can you pass a value (argument) to a function, but a function itself can be a value that's assigned to variables, or passed to or returned from other functions
       - As such, a function value should be thought of as an expression, much like any other value or expression
         : The first function expression assigned to the foo variable is called anonymous because it has no name
         var foo = function() {
                 // ..
         };
         : The second function expression is named (bar), even as a reference to it is also assigned to the x variable
         var x = function bar(){
                 // ..
         };
         : TODO
         Scope & Closures title
****** Immediately Invoked Function Expressions (IIFEs)
       - a way to execute a funtion expression immediately, which is typically referred to as an immediately invoked function expression (<<IIFE>>)
         : listing the (function IIFE(){ .. }) before its executing ()
         // `IIFE` function expression,
         // then `()` executes it
         (function IIFE(){ .. })();
         : including foo before its executing ()
         function foo() { .. }
         // `foo` function reference expression,
         // then `()` executes it
         foo();
         : As you can see, in both cases, the function reference is executed with () immediately after it

         : variable scope
         var a = 42;
         (function IIFE(){
                 var a = 10;
                 console.log( a );       // 10
         })();
         console.log( a );               // 42

         : return values
         var x = (function IIFE(){
          return 42;
         })();
         x;      // 42
****** Closure
       : It will be one of the most important techniques in your JS skillset
       - You can think of closure as a way to "remember" and continue to access a function's scope (its variables) even the function has finished running
         function makeAdder(x) {
                 // parameter `x` is an inner variable

                 // inner function `add()` uses `x`, so
                 // it has a "closure" over it
                 function add(y) {
                         return y + x;
                 };

                 return add;
         }
         : The reference to the inner add(..) function that gets returned with each call to the outer makeAdder(..) is able to remember whatever x value was passed in to makeAdder(..)
         // When we call makeAdder(1), we get back a reference to its inner add(..) that remembers x as 1. We call this function reference plusOne(..)
         var plusOne = makeAdder( 1 );

         // When we call makeAdder(10), we get back another reference to its inner add(..) that remembers x as 10. We call this function reference plusTen(..)
         var plusTen = makeAdder( 10 );

         // When we call plusOne(3), it adds 3 (its inner y) to the 1 (remembered by x), and we get 4 as the result
         plusOne( 3 );           // 4  <-- 1 + 3
         plusOne( 41 );          // 42 <-- 1 + 41

         // When we call plusTen(13), it adds 13 (its inner y) to the 10 (remembered by x), and we get 23 as the result
         plusTen( 13 );          // 23 <-- 10 + 13
****** modules
       : Modules let you define private implementation details (variables, functions) that are hidden from the outside world, as well as a public API that is accessible from the outside
       - The User() function holds the variables username and password, as well as the inner doLogin() function; these are all private that cannot be accessed from the outside world
         function User(){
                 var username, password;
                 =// doLogin()=
                 =// 1. The inner doLogin() function has a closure over username and password, meaning it will retain them even after the User() function finishes running=
                 function doLogin(user,pw) {
                         username = user;
                         password = pw;

                         // do the rest of the login work
                 }
                 =// publicAPI=
                 =// 1. publicAPI is an object with one property/method on it=
                 =// 2. When we return publicAPI from User(), it becomes the instance we call fred=
                 var publicAPI = {
                         =// login=
                         =// login which is a reference to the inner doLogin() function    <<why>>=
                         login: doLogin
                 };

                 return publicAPI;
         }

         // create a `User` module instance
         =// User()=
         =// 1. NOTE: We are not calling new User() here, User() is just a function, not a class to be instantiated=
         =// 2. Executing User() creates an instance of the User module--a whole new scope instance is created we assign to fred=
         =//    If we run User() again, we'd get a new instance entirely separate from fred=
         var fred = User();

         =// fred.login=
         =// That's [[why]] we can call fred.login(..) -- the same as calling the inner doLogin(..)=
         fred.login( "fred", "12Battery34!" );
         =// At this point, you'd think the inner variables like username and password have gone away=
         =// But here they have not, because there's a closure in the login() function keeping them alive=
       : TODO
       the Scope & Closures title of this serie
****** this identiier
       - If a function has a *this* reference inside it, that this reference usually points to an object
         function foo() {
                 console.log( this.bar );
         }
         var bar = "global";

         var obj1 = {
                 bar: "obj1",  =// <<obj1.bar>>=
                 foo: foo
         };

         var obj2 = {
                 bar: "obj2"   =// <<obj2.bar>>=
         };

         // --------
         =// to understand what this points to=

         =// 1. *this* will get the global object in non-strict mode=
         =//    in strict mode, this would be undefined and you'd get an error=
         =// 2. set *this* to reference obj1 object's bar([[obj1.bar]])=
         =// 3. set *this* to reference obj2 object's bar([[obj2.bar]])=
         =// 4. set *this* to a brand new empty object=
         foo();                          // 1. "global"
         obj1.foo();                     // 2. "obj1"
         foo.call( obj2 );               // 3. "obj2"
         new foo();                      // 4. undefined
       : TODO
       in the this & Object Prototypes title
****** Prototypes
       : The most common way this feature is used to try to emulate/fake a "class" mechanism with "inheritance"
       : But a more natural way of applying prototypes is a pattern called "behavior delegation", where you intentionally design your linked objects delegate from one to the other
       - When you reference a property on an object, if that property doesn't exist, JavaScript will automatically use that object's internal prototype reference to find another object to look for the property on
         var foo = {
                 a: 42
         };

         // create `bar` and link it to `foo` =use build-in utility called Object.create(..)=
         var bar = Object.create( foo );

         bar.b = "hello world";

         =// The a property doesn't actually exist on the bar object, but because bar is prototype-linked to foo, JavaScript automatically falls back to looking for a on the foo object, where it's found=
         bar.b;          // "hello world"
         bar.a;          // 42 <-- delegated to `foo`
       : TODO
       see Chapters 4-6 of the this & Object Prototypes title
****** Old & New
       In fact, some of the newest features in the specification aren't even implemented in any stable browsers yet
       : There are two main techniques you can use to "bring" the newer JavaScript stuff to the older browsers: polyfilling and transpiling
****** Polyfilling
       The word "polyfill" is an invented term used to refer to taking the new feature and producing a piece of code that's equivalent to the behavior is able to run in older JS environments
****** Transpiling
       the better option is to use a tool that converts your newer code into older code equivalents
       This process is commonly called "transpiling," a term for transforming + compiling
       - There are quite a few great transpilers for you to choose from
         * Babel (https://babeljs.io) (formerly 6to5): Transpiles ES6+ into ES5
         * Traceur (https://github.com/google/traceur-compiler): Transpiles ES6, ES7, and beyond into ES5
****** Non-JavaScript
       : The reality is that most JS is written to run in and interact with environments like browsers
       A good chunk of the stuff that you write in your code is, strictly speaking, not directly controlled by JavaScript
       - The most common non-JavaScript JavaScript you'll encounter is the DOM API
         =// Moreover, the getElementById(..) method on document looks like a normal JS function,
            but it's just a thinly exposed interface to a built-in method provided by the DOM from your browser=
         var el = document.getElementById( "foo" );
       - Another example is with input/output (I/O)
         alert(..) is provided to your JS program by the browser, not by the JS engine itself
         The call you make sends the message to the browser internals and it handles drawing and displaying the message box
***** into YDKJS
      : I'm going to use this final chapter to briefly summarize what to expect from the rest of the books in the series
      : and how to most effectively go about building a foundation of JS learning on top of YDKJS
****** Scope & Closures
       : The JS engine compiles your code right before (and sometimes during!) execution. So we use some deeper understanding of the compiler's approach to our code
       :   to understand how it finds and deals with variable and function declarations

       : This critical understanding of "lexical scope" is what we then base our exploration of closure on for the last chapter of the book

       : The module pattern is perhaps the most prevalent code organization pattern in all of JavaScript
       : deep understanding of it should be one of your highest priorities
****** this & Object Prototypes
       : The this keyword is dynamically bound based on how the function in question is executed

       : it's more appropriate to learn prototype system, which is more appropriately named "behavior delegation"
       : Delegation is an entirely different, and more powerful, design pattern, one that replaces the need to design with classes and inheritance
****** Types & Grammar
       : this series primarily focuses on tackling yet another highly controversial topic: type coercion

       : By far, the conventional wisdom is that implicit coercion is a "bad part" of the language and should be avoided at all costs
       : I say no. After having built up an understanding of how types and values really work,
       :   I'm asserting that coercion is an incredibly useful and totally underestimated tool that you should be using in your code
****** Async & Performance
       : the title branches out slightly to cover patterns on top of the language mechanics for managing asynchronous programming

       : we move into examining callbacks as the primary method of enabling asynchrony
       : But we quickly see that the callback alone is insufficient for the modern demands of asynchronous programming with two reason:
       :    3. Inversion of Control (IoC) trust loss and 4. lack of linear reason-ability
       : To address these, ES6 introduces two new mechanisms: 1. promises and 2. generators
       : 1. Promises are a time-independent wrapper around a "future value,"
       :    which lets you reason about and compose them regardless of if the value is ready or not yet. Moreover,
       :    they effectively solve the 3. IoC trust issues by routing callbacks through a trustable and composable promise mechanism
       : 2. Generators introduce a new mode of execution for JS functions, whereby the generator can be paused at yield points and be resumed asynchronously later.
       :    The pause-and-resume capability enables synchronous, sequential looking code in the generator to be processed asynchronously behind the scenes.
       :    By doing so, we address the 4. non-linear, non-local-jump confusions of callbacks and thereby make our asynchronous code sync-looking so as to be more reason-able.

       : the combination of 1. promises and 2. generators that "yields" our most effective asynchronous coding pattern to date in JavaScript
       : much of the future sophistication of asynchrony coming in ES7 and later will certainly be built on this foundation.

       : Chapter 5 delves into topics like program parallelism with Web Workers and data parallelism with SIMD, as well as low-level optimization techniques like ASM.js

       : Chapter 6 takes a look at performance optimization from the perspective of proper benchmarking techniques,
       :    including what kinds of performance to worry about and what to ignore.
****** ES6 & Beyond
       : This title is dedicated to both the short- and mid-term visions of where the language is headed, not just the known stuff like ES6 but the likely stuff beyond.

       : we'll never fully know every part of JS, because as soon as you master it all, there's going to be new stuff coming down the line that you'll need to learn
**** Types & Grammar
***** foreword
      Types and Grammar, the third installment of the series, is an excellent look at the core JavaScript fundamentals
       Coercion and its pitfalls, natives as constructors, and the whole gamut of JavaScript basics
***** Types
      : what the ES5.1 specificatio the type
      Types are further sub classified into ECMAScript language types
        and specification types
      The ECMAScript language types are
        Undefined, Null, Boolean, String, Number, and Object
      : what the author specification the type
      a type is an intrinsic, built-in set of characteristics
        that uniquely identifies the behavior of a particular value
          and distinguishes it from other values
          both to the engine and to the developer
****** A Type By Any Other Name
       there are many different ways that such coercion can happen
       Some of these ways are explicit, easy to reason about, and reliable
       But if you're not careful, coercion can happen in very strange and surprising ways
****** Built-in Types                                                           :code:
       JavaScript defines seven built-in types
       : object
       : null
       : function
       : array
       : undefined
       : boolean
       : number
       : string
       : symbol -- added in ES6!
****** Values as Types                                                          :code:
       : JS doesn't have "type enforcement"
       Variables don't have types, but the values in them do
       These types define intrinsic behavior of the values

       : the value of variable can be changed
       engine doesn't insist that a variable
         always holds values of the same initial type
       A variable can, in one assignment statement, hold a string
         and in the next hold a number, and so on
       this process called coercion
****** undefined vs "undeclared"                                                :code:
       Many developers will assume "undefined" and "undeclared"
         are roughly the same thing
       but in JavaScript, they're quite different
       : undefined is a value that a declared variable can hold
       An "undefined" variable is one
         that has been declared in the accessible scope
         but at the moment has no other value in it
       : undeclared means a variable has never been declared
       an "undeclared" variable is one that has not been formally declared in the accessible scope
****** typeof Undeclared                                                        :code:
       : the safety guard
       the safety guard (preventing an error) on typeof
         when used against an undeclared variable can be helpful in certain cases

       : use in debug
       it is useful if you're not dealing with user-defined variables (like debug)
         imagine having a "debug mode" in your program
           that is controlled by a global variable (flag) called DEBUG
         the declaration of global var DEBUG would only be included in a "debug.js" file
           which you only load into the browser when you're in development/testing
           but not in production

       : doing a feature check
       Imagine a utility function that
         you want others to copy-and-paste into their programs or modules
         in which you want to check to see
           if the including program has defined a certain variable
           so that you can use it or not
       : function variable
       doSomethingCool() tests for a variable called FeatureXYZ
         and if found, uses it, but if not, uses its own
       if someone includes this utility in their module/program
         it safely checks if they've defined FeatureXYZ or not
       : IIFE (Immediately Invoked Function Expressions)
       Here, FeatureXYZ is not at all a global variable
         but we're still using the safety guard of typeof to make it safe to check for
       And importantly, here we can't use the object to make the check
         so typeof is quite helpful
       : dependency injection
       doSomethingCool() inspecting implicitly for FeatureXYZ
         is to be defined outside/around it
       it would need to have the dependency explicitly passed in

       : Another way of using global variable instead the safety guard
       observe that all global variables are also properties of the global object
         which in the browser is basically the window object
       : NOTE
       manually referencing the global variable with a window reference
         is something some developers prefer to avoid
         especially if your code needs to run
           in multiple JS environments (not just browsers, but server-side node.js)
           where the global variable may not always be called window
***** values
      Let's look at several of the built-in value types in JS
        and explore how we can more fully understand
        and correctly leverage their behaviors
****** Arrays                                                                   :code:
       : As compared to other type-enforced languages
       JavaScript arrays are just containers for any type of value
         from string to number to object to even another array (multidimensional arrays)
       : presize your arrays
       You don't need to presize your arrays
       you can just declare them and add values as you see fit
       : remove the slot
       Using delete on an array value will remove that slot from the array,
         but even if you remove the final element
           it does not update the length property, so be careful
       Be careful about creating "sparse" arrays (leaving or creating empty/missing slots)
       : add string keys/properties to array
       : the coerced value of key
       if a string value intended as a key can be coerced to a standard base-10 number, then it is assumed that you wanted to use it as a number index rather than as a string key
       : NOTE
       Generally, it's not a great idea to add string keys/properties to arrays
       Use objects for holding values in keys/properties
         and save arrays for strictly numerically indexed values
****** Array-Like                                                               :code:
       : convert an array-like value into a true array
       There will be occasions where you need to
         convert an array-like value (a numerically indexed collection of values)
         into a true array
       usually so you can call array utilities
         like indexOf(..), concat(..), forEach(..), etc.
         against the collection of values
       : slice
       If slice() is called without any other parameters
         the default values is duplicating the array (or, in this case, array-like)
       : Array.from
       As of ES6, there's also a built-in utility called Array.from(..)
         that can do the same task
****** Strings                                                                  :code:
       : array-like
       strings are somewhat "array-like"
       : length property
       both they having a length property, an indexOf() method and a concat() method
       : immutable
       JavaScript strings are immutable, while arrays are quite mutable
       A further consequence of immutable strings is that
         none of the string methods that alter its contents
           can modify in-place
         but rather must create and return new strings
       : some array method are not available for string
       many of the array methods that could be helpful
         when dealing with strings are not actually available for them
       : the array reverse method when string not have
       arrays have a reverse() in-place mutator method, but strings do not
       : another workaround is to convert the string into an array
       perform the desired operation, then convert it back to a string
       Warning: This approach doesn't work for strings with complex (unicode) characters
                  in them (astral symbols multibyte characters, etc.)

       : TIP
       if you are more commonly doing tasks on your "strings" that treat them as basically arrays of characters,
         perhaps it's better to just actually store them as arrays rather than as strings
       You can always call join("") on the array of characters whenever you actually need the string representation
****** Numbers
       JavaScript has just one numeric type: number.
         This type includes both "integer" values and fractional decimal numbers
       : NOTE
       in JS, an "integer" is just a value that has no fractional decimal value. That is, 42.0 is as much an "integer" as 42
****** Numeric Syntax                                                           :code:
       : decimal literal
       Number literals are expressed in JavaScript generally as base-10 decimal literals
       : optinal of leading 0
       The leading decimal value of 0 is optional
       : omit the extra 0
       most numbers will be output as base-10 decimals
       : exponent form
       output in exponent form
       : Number.prototype
       use build-in Number.prototype - toFixed() and toPrecision()
       notice the 42.toFixed() is invalid syntax
         because the 42. is a number and is not to access toFixed()
       : hexdecimal  octal  binary
       : the representations in binary floating-point
       the representations for 0.1 and 0.2 in binary floating-point are not exact
         so when they are added, the result is not exactly 0.3
       : Number.EPSILON
       As of ES6, Number.EPSILON is predefined with this tolerance value
****** Safe Integer Ranges
       : Number.MAX_VALUE
       2^53 - 1
       9007199254740991
       : in ES6
       : Number.MAX_SAFE_INTEGER
       : Number.MIN_SAFE_INTEGER
       -9007199254740991
****** Testing for Integers                                                     :code:
       : Number.isInteger(..)
       : Number.isSafeInteger(..)
****** 32-bit (Signed) Integers
       While integers can range up to roughly 9 quadrillion safely (53 bits)
         that are only defined for 32-bit numbers
           so the "safe range" for numbers used in that way must be much smaller
       The range then is Math.pow(-2,31) (-2147483648, about -2.1 billion)
         up to Math.pow(2,31)-1 (2147483647, about +2.1 billion)
****** Special Values
****** The Non-value Values
       For the undefined type
         there is one and only one value: undefined (undefined hasn't had a value yet)
       For the null type
         there is one and only one value: null (null had a value and doesn't anymore)
****** undefined                                                                :code:
       : undefined identifier
       In non-strict mode, it's actually possible (though incredibly ill-advised!)
         to assign a value to the globally provided undefined identifier
****** void Operator                                                            :code:
       : hold the undefined value
       void operator is another way to hold the undefined value
       : to ensure an expression has no result value
       void operator can be useful if you need to ensure that an expression has no result value
****** Special Numbers                                                          :code:
       : NaN
       Not a Number
       : Number.isNaN
****** Infinities                                                               :code:
       : value Infinity
       this operation is well-defined and results in the value Infinity
       it is possible to overflow even with an operation like addition or subtraction, in which case you'd get Infinity or -Infinity
       Infinity / Infinity is results in NaN
****** Zeros                                                                    :code:
       : negative zero
       negative zero also results from certain mathematic operations
       if a negative zero value is stringify, sometimes it will be as "0"
       : comparison operators
       the comparison operators are also strange
       : distinguish 0 and -0
       a clever way to distinguish 0 and -0
       : TIP
       why do we need a negative zero
       There are certain applications
         where developers use the magnitude of a value
           to represent one piece of information
             (like speed of movement per animation frame)
         and the sign of that number
           to represent another piece of information
             (like the direction of that movement)
****** Special Equality                                                         :code:
       : test for special types
       : Object.is
       the function's core
****** Value vs. Reference                                                      :code:
       : value-copy
       because 2 is a scalar primitive
         a holds one initial copy of that value
         and b is assigned another copy of the value
         when changing b
           you are in no way changing the value in a
       : reference-copy
       both c and d are separate references to the same shared value [1, 2, 3]
         which is a compound value
         both are just equal peer references to the value
         so when using reference to modify (.push(4)) the actual shared array value
           it's affecting just the one shared value
           and both references will reference the newly modified value [1, 2, 3, 4]
       when we make the assignment b = [4, 5, 6]
         we are doing absolutely nothing to affect
           where a is still referencing [1, 2, 3]
         to do that
           b would have to be a pointer to a
             rather than a reference to the array
           but no such capability exists in JS
       : separate references
       when we pass in the argument a
         it assigns a copy of the a reference to x
       : shared reference
       to accomplish changing a to have the [4,5,6,7] value contents
         you can't create a new array and assign
           you must modify the existing array value
       : wrapper reference
       here, obj acts as a wrapper for the scalar primitive property a
         when passed to foo()
           a copy of the obj reference is passed in and set to the wrapper parameter
       now we can use the wrapper reference to access the shared object
         and update its property
       : mutable scalar primitive
       when x is used in the expression x + 1
         x = x + 1 changes x from being a shared reference to the Number object
         therefore b on the outside still reference the original object holding value 2
***** Natives
****** object wrapper                                                           :code:
       : object wrapper
       The result of the constructor form of value creation (new String("abc"))
         is an object wrapper around the primitive ("abc") value
****** Internal [class]                                                         :code:
       : native constructor
       build-in native constructor
****** Boxing Wrappers                                                          :code:
       : box the primitive value
       automatically box the primitive value with object wrapper
       Primitive values don't have properties or methods
         so to access .length or .toString()
           you need an object wrapper around the value
       NOTE
       in general, there's basically no reason to use the object form directly
         it's better to just let the boxing happen implicitly where necessary
       never do things like
         new String("abc")
         new Number(42)
       always prefer using the literal primitive "abc" and 42
****** Object Wrapper Gotchas                                                   :code:
       : manually box a primitive value
       manually box a primitive value may cause some problems
       create an object wrapper around the false value
         but objects themselves are truthy
       using the boxed object wrapper directly (like b and c above)
         is usually discouraged
         but there may be some rare occasions
           you'll run into where they may be useful
****** Unboxing                                                                 :code:
       : object wrapper change automatically
       : valueOf()
       use the valueOf() method get the underlying primitive value
****** Natives as Constructors
       constructor forms should generally be avoided
         unless you really know you need them
         mostly because they introduce exceptions and gotchas
****** Array                                                                    :code:
       : the notice of array
       [1,2,3] is the same outcome as new Array(1,2,3)
       : pass length argument to array
       if only one number argument pass to the array constructor
         it will as a length to presize the array
****** Object(..), Function(..), and RegExp(..)                                 :code:
       : The Object(..)/Function(..)/RegExp(..) constructors
****** Date(..) and Error(..)                                                   :code:
       : Data() and Error() native constructors
       The Date(..) and Error(..) native constructors
         are much more useful than the other natives
         because there is no literal form for either
       : call Data() without new
       call Date() without new
         you'll get back a string representation of the date/time at that moment
       : native specific-error-type
       there are several other specific-error-type natives:
         EvalError(..), RangeError(..), ReferenceError(..)
         SyntaxError (..), TypeError(..), and URIError(..)
         But it's very rare to manually use these specific error natives
         they are automatically used if your program actually
           suffers from a real exception (such as referencing an undeclared variable
               and getting a ReferenceError error)
****** Symbol                                                                   :code:
       : custom property names on object
       There are several predefined symbols in ES6
         like Symbol.create, Symbol.iterator, etc
       : TIP
       symbols are not actually private on object
       using them for private or special properties is likely their primary use-case
       most developers take the place of property names with _ underscore prefixes
         show this is a private/special/internal property
****** Native Prototypes                                                        :code:
       : .prototype object
       String.prototype.XYZ is shortened to String#XYZ
       : any string value can access these methods
       : Function.prototype being an empty function
       : RegExp.prototype is a regular expression
       : Array.prototype is an array
****** Prototypes As Defaults                                                   :code:
       : make .prototypes as a "default" variable type
       Function.prototype being an empty function
       RegExp.prototype being an empty regex
       Array.prototype being an empty array
       make them all nice default values to assign to variables
         if those variables wouldn't already have had a value of the proper type
       : NOTE
       be very careful not to use Array.prototype as a default value
         that will subsequently be modified
       in this example, vals is used read-only
         but if you were to instead make in-place changes to vals
         you would actually be modifying Array.prototype itself
           which would lead to the gotchas mentioned earier
***** Coercion
****** Converting Values                                                        :code:
       : implicit coercion and explicit coerction
****** Abstract Value Operations
       learn how values become either a string, number, or boolean
****** ToString                                                                 :code:
       : the coercion of toString()
       toString() can either be called explicitly
         or it will automatically be called if a non-string is used in a string context
****** JSON Stringification                                                     :code:
       : JSON.stringify()
       JSON.stringify() utility is the same as toString()
         to serialize a value to a JSON-compatible string value
       : JSON.stringify() an object with circular reference
       if you try to JSON.stringify() an object with circular reference in it
         an error will be thrown
       : define a custom JSON value serialization
       if you intend to JSON stringify an object that may contain illegal JSON value
         or if you just have values in the object
           that aren't appropriate for the serialization
         you should define a toJSON() method for it
           that returns a JSON-safe version of the object
       : not a JSON string
       toJSON() should be interpreted as
         "to a JSON-safe value suitable for stringification"
         not "to a JSON string"
         and JSON.stringify() itself will handle the stringification
       the second call
         we stringified the returned string
         rather than the array itself
         which was probably not what we wanted to do
       : replacer
       An optional second argument can be passed to JSON.stringify(..)
         that is called replacer
       if /replacer/ is an array
         the string of array should be included in serialization of the object
         and omit otherwise
       if /replacer/ is a funtion
         it will call once for property in the object
       : space
       A third optional argument can also be passed to JSON.stringify(..), called space
****** ToNumber
       : ToNumber
       for a string works for most part
         like the rules for numeric literal ("42" -> 42)
         if it fails, the result is NaN
       for a object
         the result value to a number according to the ToNumber rules just mentioned
       to convert to primitive value equivalent
         the ToPrimitive abstract operation will consult the value
         if valueOf() is available and it return a primitive value
           that value is used for the coercion
         if not but toString() is available
           it will provide the value for coercion
**** This & Object Prototypes
***** this or that?
***** Why this?
      : the this mechanism provides a more elegant way of implicitly "passing along" an object reference, leading to cleaner API design and easier re-use
      =// This allows the identify() and speak() functions to be re-used by passing multiple context (me and you) objects implicitly=
      function identify() {
              return this.name.toUpperCase();
      }
      function speak() {
              var greeting = "Hello, I'm " + identify.call( this );
              console.log( greeting );
      }
      =// the ugly version by passing multiple context objects=
      =// function identify(context) {=
              =// return context.name.toUpperCase();=
      =// }=
      =// function speak(context) {=
              =// var greeting = "Hello, I'm " + identify( context );=
              =// console.log( greeting );=
      =// }=
      var me = {
              name: "Kyle"
      };
      var you = {
              name: "Reader"
      };
      identify.call( me ); // KYLE
      identify.call( you ); // READER
      speak.call( me ); // Hello, I'm KYLE
      speak.call( you ); // Hello, I'm READER
***** Confusions
**** Scope & Closures
***** What is Scope?
      we call the set of rules for storing variables in some location, and for finding those variables at a later time, which is: Scope
***** Compiler Theory
      In traditional compiled-language process, a chunk of source code, your program, will undergo typically three steps before it is executed, roughly called "compilation"
      1. Tokens
         the program: var a = 2;
         broken up into the following tokens: var, a, =, 2, and ;. Whitespace may or may not be persisted as a token
      2. Parsing
         var a = 2;
           might start with a top-level node called VariableDeclaration, with a child node called Identifier (whose value is a),
           and another child called AssignmentExpression which itself has a child called NumericLiteral (whose value is 2).
      3. Code-Generation
         the process of taking an AST((Abstract Syntax Tree) and turning it into executable code. (depending on platform)
***** Understanding Scope
***** The Cast
      for fully understand how javascript works, let's make a conversations
      1. Engine    responsible for start-to-finish compilation and execution of our JavaScript program.
      2. Compiler  one of Engine's friends; handles all the dirty work of parsing and code-generation
      3. Scope     another friend of Engine; collects and maintains a look-up list of all the declared identifiers (variables), and enforces a strict set of rules as to how these are
                   accessible to currently executing code.
***** Back & Forth
**** Async & Performance
***** Asynchrony: Now & Later
      we're going to have to understand much more deeply what asynchrony is and how it operates in JS
****** A Program in Chunks
       your program is almost certainly comprised of several chunks, only one of which is going to execute now, and the rest of which will execute later

       later doesn't happen strictly and immediately after now

       Any time you wrap a portion of code into a function and specify that it should be executed in response to some event (timer, mouse click, Ajax response, etc.)
       you are creating a later chunk of your code, and thus introducing asynchrony to your program

       : NOTE
       it's possible to make synchronous Ajax requests, but it locks the browser UI and prevents any user interaction.
       so you should never, ever do it
****** Async Console
       sometimes the js console environment work in a strange asynchronous scenario
****** Event Loop
       - serialize
         breaks its work into tasks and executes them in serial
         disallowing parallel access and changes to shared memory
       - JS engine itself has no asynchrony recently
         up until recently (ES6) <1>, JavaScript itself has actually never had any direct notion of asynchrony built into it
         The JS engine doesn't run in isolation. It runs inside a hosting environment, which is for most developers the typical web browser
         Over the last several years, JS has expanded beyond the browser into other environments, such as servers, via things like Node.js.
         In fact, JavaScript gets embedded into all kinds of devices these days, from robots to lightbulbs
       : NOTE
       We mentioned "up until recently" <1> in relation to ES6 changing the nature of where the event loop queue is managed.
       but ES6 now specifies how the event loop works, which means technically it's within the purview of the JS engine, rather than just the hosting environment

       the JS engine has a mechanism that *handles executing multiple chunks* of your program over time, at each moment invoking the JS engine, called the "event loop."
       the "event" has had no innate sense of time, but has instead been an *on-demand execution environment* for any arbitrary snippet of JS.
****** Parallel Threading
       - parallel and async
         async is about the gap between now and later
         parallel is about things being able to occur simultaneously
       - tools for parallel
         - processes and threads
           they execute independently and may execute simultaneously: on separate processors,
                                                                      or even separate computers, but multiple threads can share the memory of a single process
       - parallel threading and event loop
         parallel threading      allowing parallel access and change to shared memory
         event loop              by contrast, is execute tasks in serial
         Parallelism and "serialism" can coexist in the form of cooperating event loops in separate threads
****** Run-to-Completion
       - JavaScript's single-threading is atomic
         which means that once foo() starts running, the entirety of its code will finish before any of the code in bar() can run
         this is called "run-to-completion"
       an example for two single-threading foo() and bar() interleaved [C]
       : TODO
       a function in JS that did not have run-to-completion behavior, see chapter 4 "Generators"
****** Concurrency
       - two concurrency processes of onscroll events [C]
         Process 1:  onscroll, request N   scrolled the page down        (ajax requests for new content)
         Process 2:  response N            render context onto the page  (receive ajax responses back)
****** noninteracting
       two concurrent "processes" act independently as such don't need to interact [C]
       the code will always work correctly, regardless of the ordering
****** Interaction
       two concurrent ajax responses with "race condition" nondeterminism [interaction1]     --broken code
       two concurrent ajax responses without "race condition" nondeterminism [interaction2]

       coordinate the interaction without a simple gate [interaction3]     --broken code
       coordinate the interaction with a simple gate [interaction4]

       coordinate the interaction without a simple latch [interaction5]     --broken code
       coordinate the interaction with a simple latch [interaction6]

       : Note
       In all these scenarios, we've been using global variables for simplistic illustration purposes, but there's nothing about our reasoning here that requires it
       in fact global variables as in these examples, is one obvious downside to these forms of concurrency coordination
       : TODO
       As we go through the next few chapters, we'll see other ways of coordination that are much cleaner in that respect
****** Cooperation
       process data in a chunk [chunk]
       process data in a async schedule [schedule]
****** Jobs
       run later, but as soon as possible [C]
****** Statement Ordering
       JS engine, after compiling the code might find opportunities to run your code
          faster by rearranging (safely) the order of these statements [C]
***** Callbacks
      sophisticated async patterns -- callback
      two categories of deficiencies with using callbacks
        lack of sequentiality and lack of trustability
****** Continuations
       introduce a single continuation (or dozen), in the form of a callback function [C]
       : NOTE
       the disconnect is at the very heart of understanding
           the shortcomings of callbacks as async expression and management
****** Sequential Brain
       we fake multitasking (such as type something at the same time
                                             we're talking to a friend)
       what we're actually most likely doing is acting as fast context switchers

       we switch back and forth between two or more tasks in rapid succession
         simultaneously progressing on each task in tiny, fast little chunks
****** Doing Versus Planning
       when a developer plan synchronous code out, it works like errands to-do list [syn]
       it turns out that how we express asynchrony (with callback) in our code
         doesn't map very well at all to that synchronous brain planning behavior [asyn]
****** nested/chained callbacks
       a chain of three functions nested together [callback hell]
         click event
         timer to fire
         ajax response to come back

       there's several problems with nested code execute in a order [trace nested flow]
****** Trust Issues
       somethimes ajax(..) is not a function that you directly control
         give over control of its execution to anothor third party [inverstion of control]
****** Tale of Five Callbacks
       [use third party callback]
       imagine you building out an ecommerce checkout system for a site that sell TV
         all pages are build just fine except the last "confirm" page
         you need to call a third-party function so that the sale can be tracked

       [invent a lot of ad hoc logic to a utility you can not trust]
       but the third-party develop working on some experimental code in your callbacks
         it make your callback some mistake
         you have to think of all the possible things
           that could go wrong with them calling your callbacks
         and come up with of ways the analytics utility could misbehave
****** not just other's code
       : overly trusting of input
       interact with truly third-party utilities without yourself-control
       : defensive against untrusted input
       : Or perhaps still safe but friendlier
       build our own internal functions with some defensive checks on the input parameter
         to reduce/preventunexpected issues

       : TIP
       "Trust But Verify"
       the most troublesome problem with callbacks is /inversion of ontrol/
         leading to a complete breakdown along all those trust lines
       But callbacks don't really offer anything to assist us
         We have to construct all that machinery ourselves
         and it often ends up being a lot of boilerplate/overhead
         that we repeat for every single async callback
****** Trying to Save Callbacks
       : split-callback design
       some API designs provide for split callbacks (ES6)
         one for the success notification
         one for error notification (optional)
       : Node style
       it's the convention used across nearly all Node.js API
         first argument of a single callback is reserved for an error object
       : cancel the callback event
       if the trust issues callback is never called
       you need to set up a timeout that cancels the events

       : TIP
       another trust issues callback is "too early"
       this may actually involve begin called before some critical task is complete
       you can either invoke the callback you provide now (sync) or later (async)
       the nondeterminism around sync-or-async lead to difficult to track down bugs
       always invoke callbacks async so that all callbacks are predictably async
       more detail in [[https://github.com/oren/oren.github.io/blob/master/posts/zalgo.md]]
                      [[http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony]]
       : sync or async
       print 0 (sync) or 1 (async), depend on conditions
       : proof-of-concept always execute async
       a invent code that proof the concept of
         whether the API will always execute async
         whether the Ajax request is in the cache
           and resolves to try to call the callback right away
         or must be fetched over the wire and thus complete later async
***** promises
****** What Is a Promise?
       guide you better as you explore
         integrating promising promise theory
         into your own async flow
       with that in mind
         let's look at _two different analogies_ for what a promis is
******* Future Value
        imagine this
          I walk up to the counter at a fast-food restaurant
          and place an order for a cheeseburger
          I hand the cashier $1.47
          the cashier hands me a receipt with an order number on it

          so I hold onto my receipt and order number
          I know it represents my future cheeseburger
          my brain make the receipt and order number as a future cheeseburger
          it's a _future value_
          so while I wait, I can do other things

          there are two outcomes
            time finish and I get my cheeseburger
            the cheeseburger is sell out
******* Values Now and Later
        : statement finish now and later
        the + operator waiting around until both x and y are resolved
        : handle now and later operations become async
        treat x and y as future values
        do not care whether x or y or both are available right away or not
        we rely on a predictable out come of the add() operation
****** Promise Value
       : two layers of promises
       1. fetchX() and fetchY() return a value =(promise)= into add()
          if the return value of fetchX() and fetchY() is resolves
       2. add() create Promise.all()
          then calling then() immediately =(the sum future value is ready)=
       : two outcomes of promise
       the then() can actually take two function
         the first for fulfillment =(as above)=
         and the second for rejection =(something went wrong getting X or Y)=

       : TIP 1
       : essily encapsulating and composing
       because promise encapsulate the time-dependent state --
         waiting fulfillment or rejection -- from outside
       thus promise can be composed in predictable ways regardless of time or outcome
       : TIP 2
       : safe to pass one party to another
       because a promise is externally immutable once resolved
       it is not possible for one party to affect another party's resolution
       so it is safe to pass that value around
       but shouldn't be casually passed over
****** Completion Event
       : the comcept of notification listener
       With callbacks, the "notification" would be our callback
         invoked by the task (foo (..))
       But with Promises, we turn the relationship around
         and expect that we can listen for an event from foo(..)
         and when notified, proceed accordingly
       : achieve in js
       foo(..) expressly creates an event subscription capability to return back
         and the calling code receives and registers the two event handlers against it
       : the benefit of it
       Uninversion of control =(notification listener)= enable a nicer separation of concerns
         where bar(..) and baz (..) don't need to be involved in how foo(..) is called
         Similarly, foo(..) doesn't need to know or care that bar(..) and baz(..)
           exist or are waiting to be notified when foo(..) completes
**** ES6 & Beyond
***** ES? Now & Future
*** freeCodeCamp
**** CatPhotoApp
     : <h1>
     used for main headings
     : <h2>
     h2 elements are generally used for subheadings
       there are also h3, h4, h5 and h6 elements
     : <p> or <P>
     p elements are the preferred element for normal-sized paragraph text on websites
       P is short for "paragraph"
     : <!-- -->
     delete html elements

     : style color
     add inline style color to h2 element
     : CSS *
     use CSS selectors to style elements
     : CSS clas *
     red-text    apply a css class to html element
     class="red-text"    classes as a tag to change the style of multiple html elements
     : font size
     font-size     change the text font size
     font-family   set a font family to a elemeent
     googleleapis  import a google font
     : font degrade
     Lobster, Monospace    if Lobster font family isn't available
                           the browser will "degrade" to Monospace

     : images *
     add images to your website
     .smaller-image    size your images
     : CSS border *
     put a 10-pixel-wide green border with a style of solid around an HTML element
     : add rounded corners with a border radius *
     use border-radius
     : make circular images with a border radius *
     specify a border-radius using a percentage

     : anchor element *
     use <a> HTML element to link to external pages
     : nest an anchor element within a paragraph *
     use <p> HTML element
** ruby
*** CANCELLED ruby编程语言 ruby programming language
    CLOSED: [2017-09-17 日 10:55]
    :LOGBOOK:  
    - State "CANCELLED"  from "WAITING"    [2017-09-17 日 10:55] \\
      I think this is good, but not the best of my first choice
      I'd like to try _programming ruby_
    :END:      
**** 导言 introduction
***** 漫游ruby a tour of ruby
****** ruby是完全的面向对象的 ruby is completely object-oriented
****** 代码块和迭代器 18 blocks and iterators 17
       : method known as an iterator, and they behave like loops
       : the code within curly braces known as a block

       : the integer's iterator method
       - times & upto
         3.times { print "Ruby! " }  # Prints "Ruby! Ruby! Ruby! "
         1.upto(9) {|x| print x }    # Prints "123456789"
       : the array's iterator method
       - each map inject select
         a = [3, 2, 1]    =# This is an array literal=
         a[3] = a[2] - 1  =# Use square brackets to query and set array elements=
         a.each do |elt|  =# each is an iterator. The block has a parameter elt=
           print elt+1    =# Prints 4321=
         end              =# This block was delimited with do/end instead of {}=
         a = [1,2,3,4]               =# Start with an array=
         b = a.map {|x| x*x }        =# Square elements: b is [1,4,9,16]=
         c = a.select {|x| x%2==0 }  =# Select even elements: c is [2,4]=
         a.inject do |sum,x|         =# Compute the sum of the elements => 10=
           sum + x
         end
       : the hash 's iterator method
       - each
         h ={                         # A hash that maps number names to digits
           :one => 1,                 # The "arrows" show mappings  key=>value
           :two => 2                  # The colons indicate Symbol literals
         }
         h[:one]                      # => 1. Access a value by key
         h[:three] = 3                # Add a new key/value pair to the hash
         h.each do |key,value|        # Iterate through the key/value pairs
           print "#{value}:#{key}; "  # Note variables substituted into string
         end                          # Prints "1:one; 2:two; 3:three; "
       : associate a block of code with amethod invocation
       - File.open & readline  Thread.new & File.read
         File.open("data.txt") do |f|   # Open named file and pass stream to block
           line = f.readline            # Use the stream to read from the file
         end                            # Stream automatically closed at block end

         t = Thread.new do           # Run this block in a new thread
           File.read("data.txt")     # Read a file in the background
         end                         # File contents available as thread value
****** 表达式和操作符 expressions and operators
       : ruby's expressions
       : control structures such as if that would be called expressions in ruby
       minimum = if x < y then x else y end
       : ruby's operator
       - some unusual ruby oerators
         1 + 2                     # => 3: addition
         1 * 2                     # => 2: multiplication
         1 + 2 == 3                # ==> true: == tests equality
         2 ** 1024                 # 2 to the power 1024: Ruby has arbitrary size ints
         "Ruby" + " rocks!"        # => "Ruby rocks!": string concatenation
         "Ruby! " * 3              # => "Ruby! Ruby! Ruby! ": string repetition
         "%d %s" % [3, "rubies"]   # => "3 Rubies": Python-style, printf formatting
         max = x > y ? x : y       # The conditional operator
       : array's [] operator
       - slice
****** 方法 methods
       : the key feature of ruby
       : classes and modules are "open" and can be modified and extended by method at runtime

       : methods
       - use def keyword to define methods
         def square(x)  # Define a method named square with one parameter x
           x*x          # Return x squared
         end            # End of the method
       : global function
       - define on individual objects by prefixing the name  of the method, which are known as singleton
         def Math.square(x)     # Define a class method of the Math module
           x*x`
         end
****** 赋值 assignment
       : = operator in ruby assigns a value to avariable
       x = 1
       : assignment can be combined with other operators
       - combine with + or -
         x += 1       # Increment x
         y -= 1       # Decrement y
         # NOTE: ruby have no ++ and -- operator
       : parallel assignment
       - allowing more than one value and more than one variable in assignment expressions
         x, y = 1, 2       # Same as x = 1; y = 2
         a, b = b, a       # Swap the value of two variables
         x,y,z = [1,2,3]   # Array elements automatically assigned to variables
       - use parallel assignment with method return more than one value
         # Define a method to convert Cartesian (x,y) coordinates to Polar
         def polar(x,y)
           theta = Math.atan2(y,x)  # Compute the angle
           r = Math.hypot(x,y)      # Compute the distance
           [r, theta]               # The last expression is the return value
         end
         # Here's how we use this method with parallel assignment
         distance, angle = polar(2,2)
       : method end with an equals sign(=)
       - ruby allows them to be invoked using asignment syntax, below two line are the same
         o.x=(1)    # Normal method invocation syntax
         o.x = 1    # Method invocation through assignment
****** 作为前缀和后缀的标点符号 punctuation suffixes and prefixes
       : punctuation characters at the end of method names
       - method end with a question mark
         A question mark is used to mark predicates—methods that *return a Boolean value*
         For example, the Array and Hash classes both define methods named *empty?* that test whether the data structure has any elements.
       - An exclamation mark at the end of a method name
         the method without the exclamation mark returns a modified copy of the object it is invoked on
         and the one with the exclamation mark is a mutator method that alters the object in place
         The Array class, for example, defines methods sort and sort!
       : punctuation characters at the start of variable names
       - global variables are prefixed with $
       - instance variables are prefixed with @
       - class variables are prefixed with @@
****** regexp and rangee
       : regexp
       - regular expression
         : /[Rr]uby/   # Matches "Ruby" or "ruby"
         : /\d{5}/     # Matches 5 consecutive digits
       : range
       - represents the values (usually integers) between two endpoints
         1..3          # All x where 1<=x<=3
         1...3         # All x where 1<=x<3
       : case statement
       - matches its expression against each of the possible cases (like the switch statement of C or Java)
         a example of case statement [En 22]
****** 类和模块 classes and modules
       : ruby核心类都是开放的 任何程序都可以为它们添加方法
       - defines an example class named Sequence and demonstrates how to write iterator methods and define operators [En 22]
****** ruby意外之处 ruby surprises
       : NOTE
       - 字符串可变的
         The []= operator allows you to alter the characters of a string or to insert, delete, and replace substrings.
         The << operator allows you to append to a string
         Because strings are mu- table, string literals in a program are not unique objects. If you include a string literal within a loop,
           it evaluates to a new object on each iteration of the loop.
           call the freeze method on a string (or on any object) to prevent any future modifications to that object.
       - nil值被当成false处理 任何其他的值都和true一样处理
***** 体验ruby try ruby
      : irb ri gem
****** ruby解释器 the ruby interpreter
       : 执行ruby
       - 命令行
         $ ruby -e 'puts "hello world!"'
       - 调用文件
         $ ruby hello.rb
****** 显示输出 displaying output
       - put print 方法
         - count.rb
           9.downto(1) {|n| print n} # No new line between numbers
           puts " blastoff!"       # End with a newline
         $ ruby count.rb
         - output
           987654321 blastoff!
****** 使用irb与ruby进行交互 interative ruby with irb
       : ruby shell
       - Type any Ruby expression at its prompt and it will evaluate it and display its value for you
         an example irb session [En 28]
****** 使用ri查看ruby文档 viewing ruby documentation with ri
       : 内置文档查看
       - display class module method documentation
         (use # refer to the isntance method, use :: to refer to the class method)
         ri Array
         ri Array.sort
         ri Hash#each
         ri Math::sqrt
****** 使用gem进行ruby包管理 ruby package management with gem
       : 模块管理
       - like (elisp elpa : java maven : osx brew : ubuntu apt)
**** ruby程序的结构和运行 the structure and execution of ruby programs
***** 词法结构 lexical structure
****** 注释 comments
       - Comments in Ruby begin with a # character and continue to the end of the line
         # This entire line is a comment
         x = "#This is a string"              # And this is a comment
         y = /#This is a regular expression/    # Here's another comment
       - multiline comments
         #
         # This class represents a Complex number
         # Despite its name, it is not complex at all.
         #
       : NOTE
       - newline
         The Ruby interpreter ignores the # character and any text that follows it
         but does not ignore the newline character, which is meaningful whitespace and may serve as a statement terminator
       - regular expression
         If a # character appears within a string or regular expression literal (see Chapter 3)
****** 嵌入式文档 embedded documents
       : another style of multiline comment
       - These start on a line that begins *=begin* and continue until (and include) a line that begins *=end*
         =begin Someone needs to fix the broken code below!
           Any code here is commented out
         =end
       : As their name implies, embedded documents can be used to include long blocks of documentation within a program,
       : or to embed source code of another language (such as HTML or SQL) within a Ruby program
       : NOTE
       - embedded documents only work if the = signs are the first characters of each line:
         # =begin This used to begin a comment. Now it is itself commented out!
           The code that goes here is no longer commented out
         # =end
       : 文档化的注释 documentation comments
       - Ruby programs can include embedded *API documentation* as specially formatted comments that precede method, class, and module definitions.
         The following example comment demonstrates the most important formatting ele- ments of the markup grammar used in Ruby’s documentation comments [En 41]
       - they can also be written as embedded documents that start =begin rdoc. (The rdoc tool will not process these comments if you leave out the “rdoc”.)
****** 字面量 literals
       : Literals are values that appear directly in Ruby source code
       - They include numbers, strings of text, and regular expressions
         1        # An integer literal
         1.0      # A floating-point literal
         'one'    # A string literal
         "two"    # Another string literal /three/ # A regular expression literal
****** 标点符号 punctuation
****** 标识符 identifiers
       : identifiers to name variables, methods, classes, and so forth
       - consist of letters, numbers, and underscore characters
       : NOTE
       - may not begin with a number
       - Class and module names must begin with initial capital letters
       - 大小写敏感 case sensitiity
       - unicode characters in identifiers
       : 标识符里的标点符号 punctuation in identifiers
       - Punctuation characters may appear at the start and end of Ruby identifiers. They have the following meanings:
         $ Global variables are prefixed with a dollar sign.
         @ Instance variables are prefixed with a single at sign, and class variables are prefixed with two at signs.
         ? As a helpful convention, methods that return Boolean values often have names that end with a question mark.
         ! Method names may end with an exclamation point to indicate that they should be used cautiously.
         = Methods whose names end with an equals sign can be invoked by placing the method name, without the equals sign, on the left side of an assignment operator.
       - Here are some example identifiers that contain leading or trailing punctuation characters:
         $files        # A global variable
         @data         # An instance variable
         @@counter     # A class variable
         empty?        # A Boolean-valued method or predicate
         sort!         # An in-place alternative to the regular sort method
         timeout=      # A method invoked by assignment
****** 关键字 keyword
       - The keywords have special meaning in Ruby [En 44]
       - there are three keywords are treated specially by the Ruby parser when they appear at the beginning of a line
         =begin =end __END__
           =begin and =end at the beginning of a line delimit multiline comments
           __END__ marks the end of the program (and the beginning of a data section) if it appears on a line by itself with no leading or trailing whitespace
       - some identifiers appear in Kernel, Module, Class and Object are treated as keyword(reserved word) [En 45]
****** 空白符 whitespace
       - 用于分割不同的标记 以免这些标记合并成一个标记
******* 作为语句终结符的换行符 newlines as statement terminators
        - 不是每个语句都要以分号结尾
          this is only required semicolons to terminate statements if you put *more than one statement* on the same line.
          In addition, the semicolons should be *omitted*
        - 下列情形 你可以放心插入一个换行符而不必担心你的语句提前结束
          - after an operator
            puts x +
                 y
          - after a *period* (fuent APIs)
            animals = Array.new
              .push("dog")  # Does not work in Ruby 1.8
              .push("cow")
              .push("cat")
              .sort
          - comma in a method invocation, array literal, or hash literal
            [1,2,3]        [1,
                            2,
                            3]
            {x=>1,y=>1}    {x<=1,
                            y<=1}
          - escape a line break *with a backslash*
            var total = first_long_variable_name + second_long_variable_name \
              + third_long_variable_name # Note no statement terminator above
******* 空格符与方法调用 spaces and method invocations
        - 避免空白符在函数方法中的二义性
          - Never put a space between a method name and the opening parenthesis
            f(3+2)+1
            f (3+2)+1
          - If the first argument to a method begins with an open parenthesis, always use parentheses in the method invocation
            f((3+2)+1)
          - Always run the Ruby interpreter with the *-w option* so it will warn you if you forget either of the rules above

***** 句法结构 syntactic structure
      - 初级表达式 primary expressions
        primary expressions represent values directly, or other keyword(like true false nil self)
      - 复合表达式 compound expressions
        [1,2,3]                # An Array literal
        {1=>"one",2=>"two"}    # A Hash literal
        1..3                   # A Range literal
****** ruby当中的块结构 block structure in ruby
       : 两种块结构
       - 与迭代器相关联的代码
         These blocks are the chunks of code associated with or passed to iterator methods
         - Formal blocks of this kind may be delimited with *curly braces*, or they may be delimited with the keywords *do* and *end*
           3.times { print "Ruby! " }

           1.upto(10) do |x| print x
           end
       - 语句列表  a list of statements
         while
         when
         if
         else
***** 文件结构 file structure
      - ruby程序结构规则
        : shebang comment and coding comment must at top line of file
        : if they are both exist, shebang comment should be above of coding comment
        #!/usr/bin/ruby -w        shebang comment
        # -*- coding: utf-8 -*-   coding comment
        require 'socket'          load networking library

          ...                     program code goes here

        __END__                   mark end of code
          ...                     program data goes here
***** 程序的编码 program encoding
****** 指定程序所使用的编码 specifying program encoding
       - 通过编码方式
         : NOTE
         : encoding names are not case-sensitive
         # coding: utf-8
****** 源编码和默认外部编码 source encoding and default external encoding
       - 源编码
         it tells the Ruby interpreter how to read characters in a script
       - 默认外部编码
         this is the encoding that Ruby uses by default when reading from files and streams
         : TIP
         - set the default external encoding of the process and then uses that encoding as the default source encoding
           ruby -E utf-8 # Encoding name follows -E
           ruby -Eutf-8 # The space is optional
           ruby --encoding utf-8 # Encoding following --encoding with a space
           ruby --encoding=utf-8 # Or use an equals sign with --encoding
***** ruby程序的运行 program execution
      - 脚本语言
        Ruby programs are simply lists, or scripts, of statements to be executed
        By default, these statements are executed sequentially, in the order they appear
        : NOTE
        There is no special *main method* in Ruby
        : the difference from ruby to compiler language
        In compiled languages, these are syntactic structures that are processed by the compiler
        When the Ruby interpreter encounters a class definition, it executes it, causing a new class to come into existence
**** 数据类型和对象 datatyoes and objects
***** 数字 numbers
      - 数值类继承关系
        - integer
          fixnum       If an integer value fits within 31 bits, it is an instance of Fixnum
          bignum       Otherwise, it is a Bignum. Bignum objects represent integers of arbitrary size
        numeric class hierarchy [P En 56]
****** 蒸熟字面量 integer literals
       - 千分符 thousands separator
         1_000_000_000      # One billion (or 1,000 million in the UK)
       - 进制数
         0377           # Octal representation of 255
         0b1111_1111    # Binary representation of 255
         0xFF           # Hexadecimal representation of 255
****** 浮点数字面量 floating-point literals
       - example
         : NOTE
         : only express floating-point values in base 10
         0.0
         -3.14
         : the e can be replace by E
         6.02e23         # This means 6.02 × 1023
         1_000_000.01    # One million and a little bit more
****** ruby中的算术操作 arithmetic in ruby
       - 截断型整数除法 truncatig-integer division
         x= 5/2     # result is 2
         y= 5.0/2   # result is 2.5
         z= 5/2.0   # result is 2.5
       - 取模 (%)
         x= 5%2     # result is 1
         : NOTE
         : The % operator can also be used with Float operands
         x= 1.5%0.4     # result is 0.3
       - 指数操作 (**)
         x**4           # This is the same thing as x*x*x*x
         x**-1          # The same thing as 1/x
         x**(1/3.0)     # The cube root of x
         x**(1/4)       # Oops! Integer division means this is x**0, which is always 1
         x**(1.0/4.0)   # This is the fourth-root of x
         : NOTE
         : When multiple exponentiations are combined into a single expression, they are eval- uated from right to left
         : Thus, 4**3**2 is the same as 4**9, not 64**2
****** 浮点数的二进制表示和圆整错误 binary floating-point and rounding errors
       - 二进制与十进制之间的误差
         Forhardware efficiency, most floating-point representations are *binary representations*
           which can exactly represent fractions like 1/2, 1/4, and 1/1024
         Unfortunately, the fractions we use most commonly (especially when performing financial calculations) are 1/10, 1/100, 1/1000, and so on
           Binary floating-point representations cannot exactly represent numbers as simple as 0.1
***** 文本 text
****** 字符串字面量 string literals
******* 由单引号引用的字符串字面量 single-quoted string literals
        - 转义字符
          'This string literal ends with a single backslash: \\'
          'This is a backslash-quote: \\\''
          'Two backslashes: \\\\'
          : a backslash is not special if the character that follows it is anything other than a quote or a backslash
          'a\b' == 'a\\b'
          - multiple line
            - break it into multiple adjacent string literals
              : you must escape the newlines between the literals so that Ruby does not interpret the newline as a statement terminator
              message =
              'These three literals are '\
              'concatenated into one by the interpreter. '\
              'The resulting string contains no newlines.'
            - [NOTE] It is not possible to escape the newlines with a backslash
              'This is a long string literal \
              that includes a backslash and a newline'
******* 由双引号引用的字符串字面量 double-quoted string literals
        - 转义序列
          "\t\"This quote begins with a tab and ends with a newline\"\n"
          "\\" # A single backslash

          the \u escape embeds arbitrary *Unicode characters*
        - 包含任意的ruby表达式
          : expressions within double-quoted strings begin with the # character and are enclosed within curly braces
          "360 degrees=#{2*Math::PI} radians" # "360 degrees=6.28318530717959 radians"
          - the curly braces may be *omitted* in these situation
            $salutation = 'hello'   # Define a global variable (or class)
            "#$salutation world"    # Use it in a double-quoted string
          - Use a backslash to escape the # character
            "My phone #: 555-1234"  # No escape needed if the character after # is {, $, or @
            "Use\#{tointerpolateexpressions" #Escape#{withbackslash
        - 字符串内插 [C sprintf]
          sprintf("pi is about %.4f", Math::PI) # Returns "pi is about 3.1416"
          "pi is about %.4f" % Math::PI         # Same as example above
          "%s:%f"%["pi",Math::PI]               # Array on right hand side for multiple args
        - 跨越多行
          - Double-quoted string literals may span multiple lines, and line terminators become part of the string literal, *unless escaped with a backslash*
            "This string literal
            has two lines \
            but is written on three"
          - adjacent string literals are automatically concatenated, but if they are written on separate lines, the *newline between them must be escaped*
            "This string has three lines.\r\n" \
            "It is written as three adjacent literals\r\n" \
            "separated by escaped newlines\r\n"
        - 双引号内的转义序列索引 [T En 63]
******* Unicode转义序列 Unicode escape
        - \u之后加上4个十六进制数字
          - which represent a Unicode codepoint between 0000 and FFFF
            "\u00D7" # => "×": leading zeros cannot be dropped
            "\u20ac" # => "¤": lowercase letters are okay
        - \u之后加上一个{符号 然后接1到6个十六进制数字
          The digits between the braces can represent any Unicode codepoint between 0 and 10FFFF, and leading zeros can be dropped in this form
          "\u{A5}" # => "¥": same as "\u00A5"
          "\u{3C0}" # Greek lowercase pi: same as "\u03C0"
          "\u{10ffff}" #ThelargestUnicodecodepoint
        - \u{}同时嵌入多组序列
          - separated by a single space or tab character
            money="\u{20AC A3 A5}"        # => "¤£¥"
            money="\u{20AC 20 A3 20 A5}"  # => "¤ £ ¥"
        - [NOTE] 只适用于UTF-8或ASCII中
******* 字符串字面量的分界符 arbitrary delimiters for string literals
        - 使用%q表示单引号字符串  %Q(或%)表示双引号表示双引号字符串
          - If the opening delimiter is (, [, {, or <, then the matching delimiter is ), ], }, or >
            %q(Don't worry about escaping ' characters!)
            %Q|"How are you?", he said|
            %-Thisstringliteralendswithanewline\n- #Qomittedinthisone
          - you can use a backslash (even in the stricter %q form) or just choose a different delimiter
            %q_This string literal contains \_underscores\__
            %Q!Just use a _different_ delimiter\!!
          - If you use paired delimiters, you don’t need to escape those delimiters in your literals
            %<<book><title>Ruby in a Nut shell</title></book>>   # This works
******* here document
        - 输出多行字符串
          def hello
            puts <<~HEREDOC
              I know I know
              You will like it.
            HEREDOC
          end
          hello

          output:
          >> I know I know
          >> You will like it.
******* 反引号所引用的命令的执行 backtick command execution
        - 执行shell命令 或作为双引号字面量处理
          - like a double- quoted literal, which means that arbitrary Ruby expressions can be interpolated into the string
            if
              windows listcmd = 'dir'
            else
              listcmd = 'ls'
            end
            listing = `#{listcmd}`    equal    listing = Kernel.`(listcmd)
          - this method executes the text as an operating system shell command and returns the command’s output as a string
            `ls`  equal   %x[ls]
******* 字符串字面量和可变性 string literals and mutability
        - 无法用一个对象表达两个相同的字符串
          - If you include a literal within the body of a loop, Ruby will create a new object for each iteration
            10.times { puts "test".object_id }
******* string.new 方法
        - 创建新字符串
          With no arguments, this method returns a newly created string with no characters
          With a single string argument, it creates and returns a new String object
****** 字符字面量 character literals
       - 字符前加问好 构成字面量
         - Single characters can be included literally in a Ruby program by preceding the character with a question mark
           ?A    =# equal the ASCII value of "A", character literal is 65=
       - 进行转义
         - 结合转义序列
           ?\u20AC == ?Ω    =# true: Ruby 1.9 only=
           ?Ω == "\u20AC"   =# true=
         - 结合转义字符
           ?\t     =# Character literal for the TAB character=
           ?\C-x   =# Character literal for Ctrl-X=
           ?\111   =# Literal for character whose encoding is 0111 (octal)=
****** 字符串操作符 string operators
       - 连接字符串
         - + operator
           : concatenates two strings and returns the result as a new String object
           planet = "Earth"
           "Hello" + " " + planet  =# Produces "Hello Earth".=
           : NOTE
           : the + operator does not convert its righthand operand to a string
           "Hello planet #" + planet_number.to_s  =# to_s converts to a string=
           : TIP
           : a simple way to auto convert to string
           "Hello planet ##{planet_number}"
         - << operator
           : it alters the lefthand operand rather than creating and returning a new object
           greeting = "Hello"
           greeting << " " << "World"
           puts greeting  =# Outputs "HelloWorld".=
           : NOTE
           : If the righthand operand is an integer, it is taken to be a character code
           alphabet = "A"
           alphabet << ?B  =# Alphabet is now "AB".=
           alphabet << 67  =# Andnowit is "ABC".=
         - * operator
           : It returns a String that repeats the text specified on the lefthand side, the number of times specified by the righthand side
           ellipsis = '.'*3 # Evaluates to '...'
           : NOTE
           : any interpolation is performed just once before the repetition is done
           a=0;
           "#{a=a+1}"*3 #Returns"111",not"123"
****** 访问字符和子字符串 accessing characters and substrings
       - 提取或改变字符串某些部分
         - single character
           : NOTE
           : if you try to access a character beyond the end of the string; it simply returns nil instead
           s='hello';
           s[0]            =# first character h=
           s[s.length-1]   =# last character o=
           s[-1]           =# another way of last character=
           s[-2]           =# second-to-last character=
           s[-s.length]    =# another way of first character=
           s[s.length]     =# nil: no character=

           : use character literals
           s[0] = ?H
           s[-1] = ?O

           : The righthand side of an assignment statement may be any string, including a multicharacter string or the empty string
           s = "hello"
           s[-1] = ""      =# hell=
           s[-1] = "p!"    =# help!=
         - substring
           : specified number of characters
           s = "hello"
           s[0,2]          =# he=
           s[-1,1]         =# "o": returns a string, not the character code ?o=
           s[0,0]          =# "": a zero-length substring is always empty=
           s[0,10]         =# "hello": returns all the characters that are available=
           s[s.length,1]   =# "": there is an empty string immediately beyond the end=
           s[s.length+1,1] =# nil: it is an error to read past that=
           s[0,-1]         =# nil: negative lengths don't make any sense=

           : delete insert
           s = "hello"
           s[0,1] = "H"    =# Replace first letter with a capital letter=
           s[s.length,0]="world" =# Append by assigning beyond the end of the string=
           s[5,0] = ","    =# Insert a comma, without deleting anything=
           s[5,6] = ""     =# Delete with no insertion s ="Hellod".=

           : range
           s = "hello"
           s[2..3]         =# ll=
           s[-3..-1]       =# llo=
           s[0..0]         =# h=
           s[0...0]        =# "": empty=
           s[2..1]         =# "": empty=
           s[7..10]        =# nil: range is outside=
           s[-2..-1] = "p!"     =# help!=
           s[0...0] = "Please " =# Please help!=
           s[6..10] = ""        =# please!=
****** 对字符串进行迭代 literating strings
       - 字符串迭代器
         - each_byte
           iterates sequentially through the individual bytes that comprise a string
         - each_char
           iterates the characters
           - it may be *more efficient* to use each_char than to use the [] operator and character indexes
             s = "¥1000"
             s.each_char {|x| print "#{x} " }        =# Prints "¥ 1 0 0 0". Ruby 1.9 0.=
             upto(s.size-1) {|i| print "#{s[i]}"}    =# Inefficient with multibyte chars=
         - each_line
           iterates the line
****** 字符串编码和多字节字符 string encodings and mutibyte characters
******* ruby1.9里的多字节字符 multibyte characters in ruby 1.9
        - 编码名称
          : ASCII-8BIT and BINARY encoding
          - You can specify this ASCII encoding as “ASCII-8BIT” or by its alias “BINARY”, one byte always equals one character
          : US-ASCII
          - 7-bit ASCII. it differs from ASCII-8BIT in that it does not allow any bytes with their 8th bit set
          : NOTE
          : if a string literal contains only 7-bit ASCII characters, then its encoding method will return ASCII, even if the source encoding is UTF-8
          : if a string literal contains \u escapes, then its encoding will be UTF-8
        - 编码方法
          : size length bytesize
          : the length and size methods return the number of characters in a string
          : the new bytesize method returns the number of bytes
          - example
            # -*- coding: utf-8 -*-       # Specify Unicode UTF-8 characters
            # This is a string literal containing a multibyte multiplication character
            s = "2×2=4"
            # The string contains 6 bytes which encode 5 characters
            s.length         =# -> 5: Characters:  '2'  '×'   '2' '=' '4' .=
            s.bytesize       =# -> 6: Bytes (hex): 32  c3 97  32  3d  34  .=
          : encoding
          : Ruby 1.9 String class defines an encoding method that returns the encoding of a string (the return value is an Encoding object
          - example
            # -*- coding: utf-8 -*-
            s = "2×2=4"   =# Note multibyte multiplication character=
            s.encoding    =# -> <Encoding: UTF-8>=
            t = "2+2=4"   =# All characters are in the ASCII subset of UTF-8=
            t.encoding    =# -> <Encoding: ASCII-8BIT>=
          : force_encoding
          : You can explicitly set the encoding of a string with force_encoding
          : the *underlying bytes of the string are not changed*, only Ruby’s interpretation of them is changed
          - example
            text = stream.readline.force_encoding("utf-8")
            bytes=text.dup.force_encoding(nil)    =# nil encoding means binary=
          : valid_encoding
          - Use valid_encoding? to perform validation
            s = "\xa4".force_encoding("utf-8")   =# This is not a valid UTF-8 string=
            s.valid_encoding?                    =# -> false=
          : encode
          : It returns a string that represents the same sequence of characters as its receiver, but using a different encoding
          : the encode method must *alter the underlying bytes that make up the string*
          - example
            # -*- coding: utf-8 -*-
            euro1 = "\u20AC"          =# unicode=
            puts euro1
            euro1.encoding            =# <Encoding:UTF-8>=
            euro1.bytesize            =# 3=

            euro2 = euro1.encode("iso-8859-15")    =# transcode=
            puts euro2.inspect                     =# print "\xA4" .=
            euro2.encoding
            euro2.bytesize                         =# 1=

            # Interpret a byte as an iso-8859-15 codepoint, and transcode to UTF-8
            byte = "\xA4"
            char = byte.encode("utf-8", "iso-8859-15")

            # the following two lines of code have the same effect
            text = bytes.encode(to, from)
            text = bytes.dup.force_encoding(from).encode(to)
          : NOTE
          : Character encodings differ not only in their mapping from bytes to characters, but in the set of characters that they can represent
          : Unicode (also known as Universal Character Set) tries to allow all characters, but character encodings not based on Unicode can only represent a subset of characters
          : therefore, Unicode characters that are neither Latin nor Japanese cannot be translated
******* encoding类 the encoding class
        - 方法
          : name
          returns the name of an encoding
          : to_s
          the same as name
          : inspect
          converts an Encoding object to a string
          : find
          - If you have an encoding name as a string and want to obtain the corresponding Encoding object, use the *Encoding.find* factory method
            encoding = Encoding.find("utf-8")
          : list
          If you want a list of available encodings, call *Encoding.list*, which returns an array of Encoding objects
          : default_external
          Use *Encoding.default_external* to obtain the Encoding object that represents the default external encoding
          : locale_charmap
          To obtain the encoding for the current locale, call *Encoding.locale_charmap* and pass the resulting string to Encoding.find.
          : TIP
          : Most methods that expect an Encoding object will also accept nil as a synonym for Encoding::BINARY (i.e., unencoded bytes)
          : You may pass Encoding objects to the encode method, but when working with encodings that are not supported by the Encoding class, you will have to specify the encoding name as a string
        - 常量
          : built-in encodings
          Encoding::ASCII_8BIT    =# Also ::BINARY=
          Encoding::UTF_8
          : dynamically loaded as needed
          US-ASCII
          ISO-8859-1 to ISO-8859-15    =# the European encodings=
          UTF-16                       =# big-endian UTF-8=
          UTF-32                       =# little-endian UFT-8=
*** PROJECT ruby on rails
**** getting started with rails
***** creating a new rails project
****** creating the blog application
       : create blog template
       use terminal generator to create a rail application called blog
         and install the gem dependencies that Gemfile bundle
       : the blog directory
       the blog directory has a number of auto-generated files and folders
         that make up the structure of a rails application
****** starting up the web server
       : connect blog application to network
       when you have a functional rails application
       you need to start a web server on your development machine
****** say "hello", rails
       : say "hello" to rails
       to say "hello" in rails, you need to create at minimum a _controller_ and a _view_
       : |- create a controller
       : |- add "hello" to a view
****** setting the application home page
       : set "hello" application to a home page
       tell rails where the "hello" to show up
       : |- edit config/routes.rb
       :    |- get controller's index page
       map http://localhost:3000/welcom/index to welcome controller's index action view
       this is automatic exist when you run a controller generator
       :    |- root controller's index page
       map the default page http://localhost:3000 to welcome controller's index action view
****** add a restful resource
       : add the article restfull resource
       : |- add the article resource to the config/routes.rb
       : |- check all the article RESTful actions
****** create controller and method for the resource
       : create controller and method for the resource

       : |- error: Routing Error
       the route needs to have a controller
         defined in order to serve the restful resource request
       : |- create a controller called _ArticlesController_

       : |- error: Unknown action
       when controllers are generated in Rails they are empty by default
         unless you tell it your desired actions
       : |- create a _new_ action of controller
       To manually define an action inside a controller

       : |- error: ActionController::UnknownFormat in ArticlesController#new
       rails expect action have a view associated to display information
       : |- add a view for _new_ action
       write a content to the file of view
****** the first form
       : create form
       : |- use form builder
       The primary form builder for Rails is provided by a helper method called form_for
       add code into app/views/articles/new.html.erb
       : |- error Unknown action
       :    |- define a _create_ action
       : |- add response by using params method
       :    |- params method
****** creating the model
       : creating the Article model
*** PROJECT ruby style guide
*** PROJECT programming ruby
**** running ruby
***** interactive ruby
      % ruby
      puts "Hello, world!"
      ^D  =# an end of file character=
      Hello, world!

      irb
***** ruby programs
      % ruby myprog.rb

      #!/usr/local/bin/ruby -w  =# Unix shebang notation=
      puts "Hello, World!"
      % ./myprog.rb
      Hello, World!
***** ruby.new                                                                  :code:
      genuine object-oriented method
      function syntax
      precedence rule
      backslash escape
      expression interpolation
      identifier
      array and hash
      control structures
      regular expressions
      block and iterators
      Reading and 'Riting
***** Classes, Objects, and Variables                                           :code:
      implementing part of the Internet Enabled Jazz and Blue Grass jukebox ruby product
        creat a basic class Song with initialize method [initialize class]
        instance a new object [instance]
        provide a method to print out the contents of a Song object for test [toString]

        define a new class KaraokeSong inheritance Song class [inheritance]
        rewrite toString method [rewrite]

        maintaining object's instance variables [objects and attributes]
        write your attributes [writable attrubutes]
        custom your attributes [virtual attributes]

        shared your variables among all object of a class [class variables]
        provide methods that work without any particular object [class methods]

        handle only one logging object per jukebox [singletons]
        make a class instance multiple object [Other Constructors]

        how much access control to your class interface [access control]
        specify access levels to accounting system [specifying access control]

        use variables to keep track of objects [variables]
***** Containers, Blocks, and Iterators                                         :code:
      : containers
      how to store the list of songs include a SongList object [Arrays]
      how to store the list of songs include a SongList object [Hashes]
      implement a SongList Container [SongList Container]

      : block and iterator
      implement [] method with a block of iterator search code    [blocks and iterators]
      invoke a block of code by using many kinds of iterators      [implement iterators]
      ruby's iterator is simple a block of code
        associated with any kind of method              [Ruby compare with C++ and Java]
      method called with a block                               [blocks for transactions]
      function as a variable, block as a object                 [blocks can be closures]
***** standard types                                                            :code:
      : number
      : Fixnum
      integers within a certain range are held interally in binary form
        and are objects of class Fixnum
      integers outside this range are stored in objects of class Bignum
      : write integers using an optional leading sign
      an optional base indicator (0 for octal, 0x for hex, or 0b for binary)
      : get the corresponding ASCII character
      you can also get the integer value corresponding to an ASCII character
        or escape sequence by preceding it with a question mark
      : strings contain numbers are not automatically converted into numbers
      this tends to bite most often when reading numbers from a file

      : strings
      : single-quoted string delimiters
      within single-quoted strings delimiters
        two consecutive backslashes are replaced by a single backslash
        and a backslash followed by a single quote becomes a single quote
      : double-quoted string delimiters
      double-quoted strings support a more escape sequences
        the most common is "\n"
        you can substitute the value of any ruby expression into a string
          using the sequence #{expr}
        if the expression is just a global varaible (class variable or instance vairbale)
          you can omit the braces
      : %q and %Q
      %q and %Q start delimited single double quoted strings
      : a here document
      a here document consists of strings
        the terminating string that you specify after the << characters
        this terminator must start in the first column
        however, if you put a minus sign after the << characters
          you can indent the terminator
      : the list of songs
      the list of song is stored as rows in a flat file
        each row holds the name of the file containing
          the song. the song's duration, the artist and the title
      : String#split & String#chomp
      our first task is to split each line into fields
        and Stirng#split will do the job nicely
      because the line read from the file has a trailing newline
        we'll use String#chomp to strip it off just before we apply the split
      in this case, we'll pass a regular expression
        which splits the line into token wherever finds a vertical bar
      : String#squeeze
      remove extra spaces before we go much further
        the simplest is String#sequeeze
          which trims runs of repeated characters
      : String#scan
      the String#scan method extracts elements from a string
        that match a regular expression
      the pattern "\w[-\w']+" matches any character that can appear in a word
        followed by one or more of the things specified in the brackets
        (a hyphen, another word character, or a single quote)
      : search capability
      given a word from a song title or an artist's name
        it will list all matching tracks
        this creating an indexing class
          feed it an object and some strings
          and it will index that object under every word
      we'll extend our SongList class to index songs
        and add a method to look up a song given a word
      finally, we'll test it all

      : ranges
      ruby use ranges to implement three separate
        sequences, conditions, and intervals
      : ranges as sequences
      : create a range-based object
      : ranges as conditions
      : ranges as intervals

      : regular expressions
      ruby provides build-in suppoert
        that makes pattern matching and substitution and concise
      : patterns
      every regular expression contains a pattern
        which is used to match the regular expression against a string
      : anchors
      by default, a regular expression will try to find the word first match the pattern
        but you can force a pattern to match only at start or end of a string
      : character classses
      a character class is a set of characters between brackets
        [characters] matches any single character between the brackets
      : repetition
      match "an arbitrary amount" as you want
      these repetition constructs have a high precedence
        they bind only to the immediately preceding
        “ab+” matches an a followed by one or more ”b's“
      : alternation
      an unescaped vertical bar "|" matches
        either the regular expression that precedes it
        or the regular expression that follows it
      : grouping
      you can use parentheses to group terms within a regular expression
        everything within the group is treated as a single regular expression
      parentheses are also used to collect the results of pattern matching
      : substitution
      let's go back to our song list file
        whoever create it entered all the artist's names in lowercase
        when we display them on our jukebox's screen
        we can change the first character of each word to uppercase
      : backslash sequences in the substitution
      the sequence \1 \2 and so on are available in the pattern
        standing for the nth group matched so far
      the same sequences are available in the second argument of sub and gsub
      there are additional backslash sequences that work in substitution strings
        \&  (last match)
        \+  (last matched group)
        \`  (string prior to match)
        \'  (string after match)
        \\  (a literal backslash)
      : object-oriented regular expressions
      when Matz designed ruby
        he produced a fully object-oriented rregular expression handling system
***** more about methods                                                        :code:
      other languages have functions, procedures, methods, or routines
        but in ruby, there is on the method - a chunk of expressions that return a value
      : defining a method
** php
*** PROJECT php document
**** getting started
***** what is php
      超文本预处理 Hypertext Preprocessor
      <?php
          ...
      ?>
***** what php can do                                                             :[[http://php.net/manual/en/intro:whatcando.php][PHP: What can PHP do? : Manual]]:
      procedural programming
      object oriented programming (OOP)
      or a mixture of them both
      HTML image PDF Flash(libwf Ming)
      XHTML XML

      mysql PDD ODBC cURL socket

      LDAP IMAP SNMP NNTP POP3 HTTP COM
      Java

      Perl regular expression
      XML documents
      libxml2 SimpleXML XMLReader XMLWriter

      XDebug
***** install
****** homebrew
******* version control
        $ brew install php56
        $ brew options php56
        $ export PATH="$(brew --prefix homebrew/php/php56)/bin:$PATH"
***** useful example
      show all reserver variables
      - <?php phpinfo(); ?>

      show the value in one of reserver variables
      - <?php
        echo $_SERVER['HTTP_USER_AGENT'];
        ?>
        // $_SERVER                       contain all web server information
        // $_SERVER['HTTP_USER_AGENT']    the sort of visitor's browser

      control structures
      - <?php
        if (strpos($_SERVER['HTTP_USER_AGENT'], 'MSIE') !== FALSE) {
            echo 'You are using Internet Explorer.<br />';
        }
        ?>

      strpos()    search a string for another string
      - <?php
        if (strpos($_SERVER['HTTP_USER_AGENT'], 'MSIE') !== FALSE) {
        ?>
        <h3>strpos() 肯定没有返回假 (FALSE)</h3>
        <p>正在使用 Internet Explorer</p>
        <?php
        } else {
        ?>
        <h3>strpos() 肯定返回假 (FALSE)</h3>
        <center><b>没有使用 Internet Explorer</b></center>
        <?php
        }
        ?>
***** 处理表单 dealing with forms                                               :form:
      : htmlspecialchars()
      make sure any characters that are special in html are properly encoded
        so people can't inject HTML tags or Javascript into your page
      : $_POST
      which contains all POST data
      notice how the method of our form is POST
        if we used the method GET method, our form information would live in $_GET
        you can also use the $_REQUEST
          if you do not care about the source of your retuest data
**** language reference
***** basic syntax                                                              :code:
****** php tags
       : opening and closing tags
       when PHP parses a file, it looks for opening and closing tags
****** escaping from html
       : php parser
       outside of a pair of opening and closing tags is ignored by the php parser
       : using condition
       using structures with conditions
****** instruction separation
       : semicolon
       PHP requires instructions to be terminated with a semicolon
         at the end of each statement
****** comments
       : comment style
       PHP supports C C++ and Unix-style (perl) comments
***** types                                                                     :code:
****** introduce
       : primitive types
       primitive types supported by PHP
****** booleans
       : boolean type
       this is the simplest type
         use the constant TRUE or FALSE
         both are case-insensitive
       : converting to boolean
       to explicitly convert a value to boolean
         use the (bool) or (boolean) casts
       however, in most cases the cast is unnecessary
         a value will be automatically converted
****** integers
       : integer type
       an integer is a number of the set Z = {..., -2, -1, 0, 1, 2, ...}
       : integer overflow
       if PHP encounters a number beyond the bounds of the integer type
         it will be interpreted as a float instead
       : integer overflow
       integer overflow on 32-bit or 64-bit system
       : converting to integer
       to explicitly convert a value to integer
         use either the (int) or (integer) casts
       however, a value will be automatically converted
         if an operator, function or control structure requires an integer argument
****** floating point numbers
       : float type
       floating point numbers (also known as floats, doubles or real numbers)
         can be specified using any of the following syntaxes
       : floating point precision
       never trust floating number results to the last digits
         and do not compare floating point numbers directly for equality
         if higher precision is necessary
           the _arbitrary precsion math functions_ and _gmp_ functions are available
       : converting to float
       see string conversion to numbers
       see converting to integer
       : comparing floats
       as note in the warning above
         testing floating point values for equality is problemmatic
           due to the way that they are represented internally
         however, there are ways to make comparision of floating point values
           that work around these limitations
       : NaN
       this result represents an undedined or unrepresentable value
         in floating-point calculations
       because NaN represents any number of different values
         NaN should not be compared to other values, include itself
           and instead should be checked for using is_nan()
** swift
*** PROJECT swift document
**** about Swift
     Swift is a new programming language for iOS, macOS, watchOS, and tvOS apps that builds on the best of C and Objective-C, without the constraints of C compatibility
     Swift’s clean slate, backed by the mature and much-loved Cocoa and Cocoa Touch frameworks
     It is the first industrial-quality systems programming language that is as expressive and enjoyable as a scripting language
     It supports playgrounds(代码预览)
        an innovative feature that allows programmers to experiment with Swift code and see the results immediately
        without the overhead of building and running an app
*** the swift programming language
**** a swift tour
     : common programming errors
     swift define large classes of common programming errors

     : version compatibility
     Xcode contains the version support of swift

     : simple values
     : hello world
     the simplest way to print "hello, world"
     : variable and constant
     use let to make a constant and var to make a variable
     : initial value
     you don't always have to write the type explicitly
     you can also provide the type information after the variable, separate by a colon
     : a simple way to include variables in strings
     "\(variable name is here)"
     : the strings that take up multiple lines
     use three double quotes (""")
     : create arrays and dictionaries
     : to create an empty array or dictionary

     : control flow
     : if and for-in
     use if and for-in to make conditional statement
     : optinal value
     use if and let together to work with values that might be missing
     : default value
     if the optional value is missing, the default value is used instead
     : switch structure
     switch support any kind of data and a wide variety of comparison operations
     : for-in iterate over items in a dictionary
     : while structure

     : functin and closures
     : declare a funtion
     : no argument label
     function use their parameter names as labels for their arguments
     : return a tuple
     use a tuple to make a compound value
       the elements of a tuple can be referred to either by name or by number
     : functions can be nested
     nested functions have accessed to variables
       that were declared in the outer function
     : a function can return another function as its value
     : take function as arguments
     a function can take another function as one of its arguments
     : functions are actually a special case of closures
     you can write a closure without a name
       by surrounding code with braces ({})
     use "in" to separate the arguments and return type from the body
     : omit the type of patameters and its return type
     when a closure's type is already known (such as the callback)
       you can omit its parameters, its return type, or both
     : you can refer to parameters by number instead of by name

     : objects and classes
     : create a class *
     : use class *
     create a instance of a class, access the properties and methods of the instance
     : set up an initializer for class *
     : override superclass's method *
     : set and get *
     : optional value *

     : Enumerations and structures
     : create a enumeration with raw value *
     : create a enumeration without raw value *
     : associated values of enumeration *
     : use combine struct and enumerations

     : protocols and extensions

     : error handling

     : generics
**** the basics
     : declaring constants and variables *
     : type annotations *
     : naming constants and variables *
     : printing constants and variables *

     : comments *
     : semicolons *

     : type safety and type inference *
     : numeric literals *
     : numeric conversion *

     : integers *
     : UInt *
     : Int8 *
     : Int16 *

     : floating-point numbers *
     : the value of truncate *

     : tyoe aliases *

     : booleans *
     : condtional statement *

     : tuples *
** rust
*** PROJECT Rust程序设计语言 the rust programming language
**** 第一版 first version
**** 第二版 second version
***** 介绍 introduction
      - 系统编程语言
        Rust is a systems programming language focused on three goals: safety, speed, and concurrency
      - 嵌入其他语言
        : NOTE
        It maintains these goals *without having a garbage collector*
        making it a useful language for a number of use cases other languages aren’t good at
          embedding in other languages, programs with specific space and time requirements
          and writing low-level code, like device drivers and operating systems
****** 安装 installation
       - 安装 install
         $ curl https://sh.rustup.rs -sSf | sh
       - 卸载 uninstalling
         $ rustup self uninstall
       - 版本号 version
         $ rustc --version
      
****** hello, world!
       - 创建项目文件夹 creating a projct directory
         $ mkdir ~/projects
         $ cd ~/projects
         $ mkdir hello_world
         $ cd hello_world
       - 编码并运行rust程序 writing and running a rust program
         Filename: main.rs

         fn main() {
             println!("Hello, world!");
         }

         $ rustc main.rs
         $ ./main
         Hello, world!
       - 分析rust程序 anatomy of a rust program
         fn main() { =// 1. The main function=
             println!("Hello, world!"); =// 2. indent  3. rust macro  4. semicolon=
         }
         : 1. The main function is special: it's the first thing that is run for every executable Rust program (entry point)
         : 2. indent with four spaces, not a tab
         : 3. when you see a ! that means that you’re calling a macro instead of a normal function (println! not println)
         : 4. The line ends with a semicolon (;)
         $ rustc main.rs
         $ ls
         main  main.rs     =# 1. source file and executable file=
         $ ./main          =# 2. rust is a ahead-of-time compiled languag=
         : 1. the source code, with the .rs extension, and the executable (the executable file)
         : 2. means that you can compile a program, give it to someone else, and they can run it even without having Rust installed
       - cargo
         $ cargo --version    =# get version of cargo installed=
         - 使用cargo创建项目 creating a project with cargo
           $ cd ~/projects
           $ cargo new hello_cargo --bin    =# 1. --bin argument=
           $ cd hello_cargo
           $ ls
           Cargo.toml  src    =# 2. toml  3. src=
           : 1. pass this to cargo because our goal is to make an executable application
           : 2. TOML is similar to INI but has some extra goodies and is used as Cargo’s configuration format
           - Cargo.toml
             [package]        =# 1. heading=
               name = "hello_cargo"
               version = "0.1.0"
               authors = ["Your Name <you@example.com>"]
             [dependencies]   =# 2. crates=
             : 1. a section heading that indicates that the following statements are configuring a package
             : 2. which is what we call packages of Rust code, so your project will depend on so that Cargo knows to download and compile
           : 3. your source files to live inside the src directory
           :    the top-level project directory is just for READMEs, license information, configuration files, and anything else not related to your code
           - src/main.rs
             fn main() {
                 println!("Hello, world!");
             }
         - 构建并运行cargo项目 building and running a cargo project
           $ cargo build  =# 1. Cargo.lock=
              Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
           $ ./target/debug/hello_cargo    =# or .\target\debug\hello_cargo.exe on Windows=
           Hello, world!
           $ cargo run
              Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
                Running `target/debug/hello_cargo`  =# 2. the directory of the result of a project of building=
           Hello, world!
           : 1. causes Cargo to create a new file at the top level called Cargo.lock
           :    Cargo uses the Cargo.lock to keep track of dependencies in your application
           - Cargo.lock
             [root]
             name = "hello_cargo"
             version = "0.1.0"
           : 2. Instead of the result of the build being put in the same directory as our code, Cargo will put it in the target/debug directory.
         - 发布构建 building for release
           $ cargo build --releas    =# 1. compile your project with optimizations=
           : 1. This will create an executable in target/release instead of target/debug
           :    These optimizations make your Rust code run faster, but turning them on makes your program take longer to compile
           : NOTE
           : this is for building the final program you’ll give to a user that won't be rebuilt
           : If you're benchmarking the running time of your code, be sure to run cargo build --release and benchmark with the executable in target/release
         - 把cargo当作习惯 cargo as convention
***** 猜猜看 Guessing Game
****** 准备一个新项目 Setting Up a New Project
       - 创建项目目录
         $ cargo new guessing_game --bin  =# The --bin flag tells Cargo to make a binary project=
         $ cd guessing_game
       - Cargo.toml
         [package]
         name = "guessing_game"
         version = "0.1.0"
         authors = ["Your Name <you@example.com>"]

         [dependencies]
       - src/main.rs
         Filename: src/main.rs

         fn main() {
             println!("Hello, world!");
         }
       - cargo run
         $ cargo run
            Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
              Running `target/debug/guessing_game`
         Hello, world!
****** 处理一次猜测 Processing a Guess                                          :ATTACH:
       :PROPERTIES:
       :ID:       0B9C2FE0-3EC5-4B67-B648-0E21C4B42C57
       :END:
       - first part, we’ll allow the player to input a guess and print it out _[src/main.rs]_
         - bring the io (input/output) library into scope [library]
         - the main function isthe entry point into the program [main]
           The fn syntax declares a new function
           the () indicate there are no parameters
           and { starts the body of the function
         - println! is a macro that prints a string to the screen [println!]
         - storing values with variables [variables]
           : create a place to store the user input
           let mut guess = String::new();
           : let statement, which is used to create variables
           let foo = bar;
           : In Rust, variables are immutable by default. The following example shows how to use mut before the variable name to make a variable mutable
           let foo = 5; =// immutable=
           let mut bar = 5; =// mutable=
           : created a mutable variable that is currently bound to a new, empty instance of a String
           =// String  a string type provided by the standard library that is a growable, UTF-8 encoded bit of text=
           =// The :: syntax in the ::new line indicates that new is an associated function of the String type. Some languages call this a static method=
           =// This new function creates a new, empty String=
           String::new
           : call an associated function, stdin, on io
           io::stdin().read_line(&mut guess)
               .expect("Failed to read line");
           =// NOTE: If we didn’t have the use std::io line at the beginning of the program, we could have written this function call as std::io::stdin=
                    =The stdin function returns an instance of std::io::Stdin, which is a type that represents a handle to the standard input for your terminal=
           io::stdin()
           =// calls the read_line method on the standard input handle to get input from the user. We’re also passing one argument to read_line: &mut guess=
           .read_line(&mut guess)
           =// The & indicates that this argument is a reference=
                =which gives you a way to let multiple parts of your code access one piece of data without needing to copy that data into memory multiple times=
           =// references are immutable by default. Hence, we need to write &mut guess rather than &guess to make it mutable=
           &mut guess
         - handling potemtial failure with the result type [result type]
           : read_line return an io::Result value with expect function
           read_line(&mut guess).expect("Failed to read line")
           : io::Result
           rust has a number of types named Result in its standard library, in specific I/O version called io::Result
           the purpose of these Result types is to encode error handling information
           - the Result type are enumerations, often referred to as enums, the variants values are Ok and Err:
             Ok   indicates the operation was successful, and inside it is the successfully generated value
             Err  means the operation failed, and it contains information about how the operation faile
           : expect
           if io::Result is an Err value, the expect function will cause the program carsh and display the message that you passed as an argmuent to expect
           if this instance of io::Result is an Ok value, expect will take the return value that Ok is holding and return just that value to you so you could use it
           - if you don't call expect, the program will compile, but we'll get a warning
             $ cargo build
                Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
             src/main.rs:10:5: 10:39 warning: unused result which must be used,
             #[warn(unused_must_use)] on by default
             src/main.rs:10     io::stdin().read_line(&mut guess);
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         - printing values with println! plcaeholders [placeholders]
           : The set of {} is a placeholder that holds a value in place
           let x = 5;
           let y = 10;
           println!("x = {} and y = {}", x, y)
           : print out x = 5 and y = 10
         - testing the first part
         $ cargo run
            Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
              Running `target/debug/guessing_game`
         Guess the number!
         Please input your guess.
         6
         You guessed:
       - second part, generating a secret number
         - using a create package to get more functionality _[Cargo.toml]_ [create package]
         - now, build the project, update register and fetches the latest package
           $ cargo build
               Updating registry `https://github.com/rust-lang/crates.io-index`
            Downloading rand v0.3.14
            Downloading libc v0.2.14
              Compiling libc v0.2.14
              Compiling rand v0.3.14
              Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
         - the Cargo.lock file ensures reproducible builds _[Cargo.lock]_
           Cargo will use only the versions of the dependencies you specified
             until you indicate otherwise
         - updating create package to get a new version
           $ cargo update
               Updating registry `https://github.com/rust-lang/crates.io-index`
               Updating rand v0.3.14 -> v0.3.15
           : NOTE
           if create has released two new versions, 0.3.15 and 0.4.0
           you'd like the 0.4.0 version
           you should update Cargo.toml file _[Cargo.toml]_ [update package]
         - generating a random number _[src/main.rs]_
           - adding a extern crate rand [external dependency]
             line to the top that lets Rust know we’ll be using that external dependency
             now we can call anything in the rand crate by prefixing it with *rand::*
           - use rand::Rng [trait]
             Rng is a trait that defines methods that random number generators implement
               it must be in scope for us to use those methods
             : TIP
             you can use
             $ cargo doc --open
             to build documentation provided by all of your dependencies locally
           - use gen_range and thread_rng to generator random number [number generator]
             the rand::thread_rng function will give us the particular generator to use
             the gen_range method is defined by rand:Rng trait
               take two numbers as arguments and generates a random number between them
             : NOTE
             It’s inclusive on the lower bound but exclusive on the upper bound
             gen_range(1, 101) is between 1 and 100
           - try running
             $ cargo run
                Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
                  Running `target/debug/guessing_game`
             Guess the number!
             The secret number is: 7
             Please input your guess.
             4
             You guessed: 4
             $ cargo run
                  Running `target/debug/guessing_game`
             Guess the number!
             The secret number is: 83
             Please input your guess.
             5
             You guessed: 5
       - third part, comparing the guess to the secret number
         - bring a type called Ordering into scope from standard library [type]
         - compare the guess to the secret_number [compare]
           : guess.cmp
           *cmp* method compare two values and can be called on anything that can be compare
           : Ordering::Less  Ordering::Greater  Ordering::Equal
           cmp returns a variant of the *Ordering enum* we brought into scope with statement
           : match
           a mathch expression is made up of arms
           a arm consist of a pattern and the code that should be run
           the *match expression* to decide what to do next
             based on which variant of Ordering was returned
         - convert guess variable from string to number [mismatch error]
           : guess is a string value
           let mut guess = String::new();
           : rust will not compare a string and a number type
           match guess.cmp(&secret_number) {  =// secret_number is a number=
           : it will cause a mismatch error

           : so to avoid it, we must convert guess to a number
           : let guess: u32 = guess.trim().parse()
           : guess.
           the shadow feature is used convert a value from one type to another type
           : trim()
           the trim method eliminates any writespace at the beginning and end of string
             if user types 5 and presses return, guess looks like this: 5\n
             the trim method eliminates \n, result in just 5
           : parse()
           the parse method parses a string into some kind of number
           : let guess: u32
           The colon (:) after guess tells Rust we’ll annotate the variable’s type (u32)
         - test third part
           $ cargo run
              Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
                Running `target/guessing_game`
           Guess the number!
           The secret number is: 58
           Please input your guess.
             76
           You guessed: 76
           Too big!
** english
*** PROJECT english grammer in use
**** contents 3
**** tenses
***** 1) present continuous(I am doing) 10
***** 2) simple present(I do) 12
***** 3) present continuous(I an doing) or simple present(I do) 14
***** 4) present tenses(I am doing / I do) with a future meaning 16
***** 5) going to (I am going to do) 18
***** 6) will(1) 20
***** 7) will(2) 22
***** 8) will or going to 24
***** 9) when and if sentences(when I do... / if I do ...) 26
***** 10) will be doing and will have done 28
***** 11) simple past(I did) 30
***** 12) past continuous(I was doing) 32
***** 13) present perfect(I have done)(1) 34
***** 14) present perfect(I have done)(2) 36
***** 15) present perfect(I have done)(3) 38
***** 16) present perfectcontinuous(I have been doing) 40
***** 17) present perfect continuous(I have been doing) or present perfect simple(I have done)? 42
***** 18) present perfect(I have done / I have been doing) with how long, for, since 44
***** 19) present perfect with how long; simple past with when; since and for 46
***** 20) present perfect(I have done) or simple past(I did)? 48
***** 21) past perfect(I had done) 50
***** 22) past perfect continuous(I had benn doing) have and have got 52
***** 23) have and have got 54
***** 24) used to(I used to do) 56
**** modal verbs
***** 25) can, could, and be able to 58
***** 26) could(do) and could have(done) 60
***** 27) must(have) and can't(have) 62
***** 28) may(have) and might(have) 64
***** 29) may and might(future) 66
***** 30) can, could, may, and would: requests, permission, offers, and invitations 68
***** 31) have to and must 70
***** 32) should 72
***** 33) subjunctive (I suggest you do) 74
**** conditionals
***** 34) if sentences (present / future) 76
***** 35) if and wish sentences (present) 78
***** 36) if and wish sentences (past) 80
***** 37) would 82
***** 38) in case 84
***** 39) unless, as long as, and provided / providing(that) 86
**** passive
***** 40) passive(1)(be done / have been done) 88
***** 41) passive(1)(present and past tenses) 90
***** 42) passive(3) 92
***** 43) it is said that ... / he is said to ..., etc., and supposed to 94
***** 44) have something done 96
**** reported speech
***** 45) reported speech(1) 98
***** 46) reported speech(2) 100
**** questions
***** 47) questions(1) 102
***** 48) qurestion(2) (do you know where...? / he asked me where...) 104
***** 49) auxiliary verbs in short answers/questions, etc.: so/neither am I, etc. 106
***** 50) tag questions(are you? doesn't he? ,etc.) 108
**** -ing and the infinitive
***** 51) verb + ing 110
***** 52) verb + infinitive 112
***** 53) verb + object + infinitive 114
***** 54) infinitive or -ing?(1) -like, would like, etc. 116
***** 55) infinitive or -ing?(2) -begin, start, continue, remember, try 118
***** 56) preposition + -ing 120
***** 57) verb + preposition + -ing 122
***** 58) expressions + -ing 124
***** 59) be / get used to something(I'm used to...) 126
***** 60) infinitive of purpose-"I went out to mail a letter." so that... 128
***** 61) prefer and would rather 130
***** 62) had better do something  it's time someone did something 132
***** 63) see someone do and see someone doing 134
***** 64) -ing clauses-"feeling tired, I went to bed early." 136
**** articles
***** 65) uncountable nouns(gold, music, advice, etc.) 138
***** 66) countable nouns with a/an and some 140
***** 67) a/an and the 142
***** 68) the(1) 144
***** 69) the(2) 146
***** 70) plural and uncountable nouns with and without the(flowers/the flowers) 148
***** 71) school/the school, prison/the prison, etc. 150
***** 72) geographical names with and without the 152
***** 73) names of strees, buildings, etc. with and without the 154
***** 74) singular or plural 156
***** 75) ...'s(apostrophe s) and ...of... 158
***** 76) reflexive pronouns(myself / yourself, etc.), by myself 160
***** 77) "a friend of mine," "my own house" 162
***** 78) all/all of, no/none of, most/most of, etc. 164
***** 79) both/both of, neither/neither of, either/ either of 166
***** 80) some and any  some/any + -one/-body/-thing/-where 168
***** 81) no/none/any  no/any + one/-bodu/-thing/-where 170
***** 82) much, many, little, few, a lot, plenty 172
***** 83) all, every, and whole 174
**** relative clauses
***** 84) relative clauses(1)-clauses with who/that/which 176
***** 85) relative clauses(2)-clauses with or without who/that 178
***** 86) relative clauses(3)-whose, whom, why and where 180
***** 87) relative clauses(4)-"extra information" clauses(1) 182
***** 88) relative clauses(5)-"extra information" clauses(2) 184
***** 89) -ing and -ed clauses("the woman talking to Tom," "the man injured in the accident") 186
**** adjectives and adverbs
***** 90) adjectives ending in -ing and -ed (boring/bored, etc.) 188
***** 91) adjectives: word order("a nice new house") after verbs("do you feel tired?") 190
***** 92) adjectives and adverbs(1) (quick/quickly) 192
***** 93) adjectives and adverbs(2) (good/well, fast/hard/late, hardly) 194
***** 94) so and such 196
***** 95) enough and too 198
***** 96) the infinitive after adjectives 200
***** 97) comparison(1)-cheaper, more expensive, etc. 202
***** 98) comparison(2) 204
***** 99) comparison(3)-as...as/than 206
***** 100) superlatives-the longest, the most enjoyble, etc. 208
**** word order
***** 101) word order(1)-verb + objet;  place and time 210
***** 102) word order(2)-adverbs with the verb 212
***** 103) still and yet anymore/any longer/no longer 214
***** 104) although/though/even though/in spite of/despite 216
***** 105) even 218
***** 106) as(time)-"I watched her as she worked." as(reason)-"as I was feeling tired, I went to bed." 220
***** 107) like and as 222
***** 108) as if 224
**** prepositions
***** 109) at/on/in(time) 226
***** 110) for, during, and while 228
***** 111) by and until  by the time ... 230
***** 112) in/at/on(position)(1) 232
***** 113) in/at/on(position)(2) 236
***** 114) to, been to, into    by car/in my car 238
***** 115) noun + preposition("reason for," "cause of," etc.) 240
***** 116) preposition + noun("by mistake," "on television," etc.) 242
***** 117) adjective + preposition(1) 244
***** 118) adjective + preposition(2) 246
***** 119) verb + preposition(1) 248
***** 120) verb + preposition(2) 250
***** 121) verb + preposition(3) 252
***** 122) verb + object + preposition(1) 254
***** 123) verb + object + preposition(2) 256
***** 124) phrasal verbs(get up, break down, fill in, etc.) 258
**** appendix
***** 1) list of present and past tenses 261
***** 2) regular and irregular verbs 262
***** 3) spelling 264
***** 4) short forms(I'm/didn't, etc.) 266
**** Index) the number in index refer to units, not page 267
*** PROJECT word power made essy
**** *[basic]* how to use this book for maximum benefit 16
***** this is not a reading book
      Instead, work with it. Write in it, talk aloud to it, talk back to it
***** pronunciation system
****** syllables
******* several syllables in which vowel sound is said very quickly
        - The symbol "ə" called a schwa, represents the quick, short vowel sound
          -a[ə]
          -er[ər]
          a-[ə]
          -ent[ənt]
****** accent
****** S (or s) is always hissed in phonetic respellings
       -ce[s] -s[s]
****** The symbol i or l is pronounced eye
       -y[i] -i[i]
****** All consonants have their normal sounds
       - except for G(or g)
         -g-[G]
****** The vowel sounds
       -a- -e- -i- -o- -u-
***** why etymology
***** but what are nouns, verbs, and adjectives
***** how to work for best results
**** *[test]* getting off to a good start
***** test your present vocabulary 33
***** a test of verbal speed 37
***** a test of verbal responsiveness 44
**** *[experience]* how to start building your vocabulary 48
     : powerful urge to learn
     : words are the verbal symbols of ideas
     : the more ideas you are familiar with, the more words you know
     : do one or two sessions at a time
     : Find a schedule that is comfortable for you, and then stick to it
     : Avoid interrupting your work until you have completed a full session
**** *[sessions 1-3]* how to talk about personality types 59 64 71
**** *[sessions 4-6]* how to talk about doctors 86 92 98
**** *[sessions 7-10]* how to talk about various practitioners 114
** compiler
*** computer system
    : information is bits + context *
    : programs are translated by other programs into different forms *
    : processors read and interpret instructions stored in memory *
    : caches matter *
    : storage devices form a hierarchy *
    : the operating system manages the hardware *
    : systems communicate with other systems using networks *
    : concurrency and parallellism *
    : some abstractions provided by a computer system *
*** representing and manipulating information
**** information storage
     : byte arrays *
     : hexadecimal notation *
     : data sizes *
     : addressing and byte ordering *
     : representing strings *
     : representing code *
     : introduction to boolean algebra *
     : bit-level operations in C *
     : logical operations in C *
     : conversions between signed and unsigned *
     : signed versus unsigned in C *
     : expanding the bit representation of a number *
     : truncating numbers *
     : advice on signed versus unsigned *
**** integer representations
     : integral data types *
     : unsigned encodings *
     : two's-complement encodings *
**** integer arithmetic
     : unsigned addition *
     : two's-complement addition *
     : two's-complement negation *
     : two's-complement multiplication *
     : multiplying by constants *
     : dividing by powers of 2 *
**** floating point
     : fractional binary numbers *
     : IEEE floating-point representation *
     : rounding *
     : floating-point operations *
*** machine-level representation of programs
**** program encodings
     : machine-level code *
     : code examples *
**** data formats
     : sizes of C data types in x86-64 *
**** accessing information
     : general-purpose registers *
     : operand specifiers *
     : data movement instructions *
     : data movement example *
     : pushing and popping stack data *
**** arithmetic and logical operations
     : integer arithmetic operations *
     : load effective address *
     : unary and binary operations *
     : shift operations *
     : discussion *
     : special arithmetic operations *
**** control
     : condition codes *
     : accessing the condition codes *
     : jump instruction encodings *
*** front-end design
**** language processors
     : a compiler *
     : instruction set *
     : target program *
     : an interpreter *
     : a hybrid compiler *
     : a language-processing system *
**** the structure of a compiler
     : the design of compilation *
     : phases of a compiler *
     : the example of compiling a assignment statement *
     : the science of a compiler *
     : applications of compiler technology *
*** scanners
    : scanner *
    : recognizing words *
    : regular expressions *
    : from regular expression to scanner *
    : implementing scanners *
* misc
** DONE 如何高效使用搜索引擎
*** google 资料查找
**** site  某个特定网站下的所有信息
     例: site:http://www.nanzao.com/sc 棱X计划
**** filetype  用于搜索特定格式的文件
     例: filetype:ppt 商务模板
**** 关键字匹配
     "" 双引号   完全匹配
     -  减号     搜索结果不包含减号后面词的页面
     *  星号     通配符
     
*** TinEye 以图搜索
*** P2Psearch 电影下载                                                           :http://www.p2psearch.net:
*** PEXLES 高清图片                                                              :https://www.pexels.com:
*** GIPHY gif动态图                                                              :http://giphy.com:
*** 天眼查 查公司相关信息                                                          :http://www.tianyancha.com:
*** Innojoy 专利查询                                                             :http://www.innojoy.com/search/index.html:
* experience
** vi
   nG    move to line n
   H     move cursor to the top of screen
   M     move cursor to the middle of screen
   L     move cursor to the end of screen
** git
   when try to edit the git files
     checkout the dev branch
** zsh
*** mv
    mkdir nonexist_file  =# if move to nonexist directory, first use mkdir to create it=

    mv dir1 dir2      =# if dir2 is not exist, you should mkdir dir2=
    mv dir1/* dir2    =# move all file in dir1 to dir2=
*** python
**** pip
     $ brew reinstall python3
     $ pip3 install --upgrade pip setuptools wheel
**** elpy
     : install relate python package
     pip install jedi flake8 importmagic autopep8
     : ide features
     https://elpy.readthedocs.io/en/latest/ide.html
**** interpreter
     $ python    # python 2
     $ python3   # python 3
*** upgrade
    upgrade_oh_my_zsh
** idea
*** keybinding
                      navigation bar

    shift + shift     search everywhere
    shift + F6        rename

    cmd + N           find file or class by name
    cmd + E           recent files popup
    cmd + J           insert a live template
    cmd + .           code folding
    cmd + ,           preference

    ctrl + F          find / replace text string in current file
    ctrl + R

    ctrl + tab        switch windows tool (like ctrl + tab in windows)
    ctrl + enter      generate code
    ctrl + click      navigate | source code

    alt + enter       show intention actions and quick-fixes
    alt + F1          switch between views (project, structure, etc.)

    cmd + shift + A       find action by name
    cmd + shift + enter   smart code completion

    cmd + alt + L     reformat code

    cmd + alt + shift + T    refactor

** mac
   S-M-4  screenshots
** emacs
*** lang
**** scheme
     mit-scheme
     .scm
     scheme-send-region (C-c C-r)
     scheme buffer
*** ivy
    C-a  C-e  (line)
    C-f  C-b  (char)
    C-k       (kill)
    C-n  C-p  (select)
    C-j       (immediately RET)
    C-m       (RET)
    M-f  M-b  (string)
    M-n  M-p  (history)
*** ibuffer
    t  mark all
*** ansi-term
    C-c C-j    line mode
    C-c C-k    get back
    M-f        move forward
    M-b        move backword
    C-d        delete word
**** delete
     C-u    delete to the begin of the line
     C-k    delete to the end of the line
     C-w    delete to the begin of the word
     M-b    delete to the end of the word
*** evil
**** positiion
     C-o  evil-jump-backward
     TAB  evil-jump-forward
**** ex
     :w    save
     :q    quit
     :x    save and quit
     :!{cmd}
     :.,.+3s/{old}/{new}/g

     :%s/\v(base)?name/&1/g
     :%s/^/#/g          添加 # 注释
     :%s/^ *//g         删除行首空格
     :%s/ *$//g         删除行末空格
     :%s/^\n//g         删除空行
     :'<,'>s/foo/bar/g  line mode substitude

     :g/^[ |\t]*$/d     删除带tab或空白字符的空行

     :v/E/d             保留带E字符的行 删除所有其他行
**** operator
     r {word}    replace

     insert mode
       C-f C-b
       M-f M-b

     delete characters from right to left
       dvfs

     cw     replace current character to the end of word

     <C-v>  block operator
            use `j` to move
            use `I` to insert, and <ESC> to finish

     =      automatically indent
**** moving
     w  e  <->  b  ge
     W  E
     }    moving next void line
**** regexp
     one two  ->  (one) (two)
     three        (three)

     :%s/\w+/\(&\)/g
**** macro
     : append command to the end of macro
     use capital letter
       qAxq     append x to the macro stored in a
     inherit old macro
       qb@axp   keep a stored and use b instead
*** org
    C-c c    capture
    C-c C-w  refile
    C-c s    schedule
    C-c d    deadline
    C-c a    agenda
      C-c [    org-agenda-file-to-front
      C-c ]    org-remove-file
      inbox    a moment of ideas
    C-c C-t  todo
      !      timestamp
      @      timestamp with note
      /!     leave current todo state, a timestamp should be recorded
    S-up     the level of todo state
    S-down
    C-c C-c  tag
      C-k      kill line
    C-c C-x C-i    clock in
    C-c C-x C-o    clock out
    C-c C-x C-c    column view
*** pdf-tools
    pdf-view-kill-ring-save    copy/paste
    pdf-annot-add-*
      C-c C-c
      C-c C-q
*** projectile
    C-c pf    find file in current project
*** bookmark
    bookmark-load    bookmark.el
    bookmark-list    d    mark delete label
                     x    execute the mark label
*** position register
    point-to-register
    jump-to-register
*** dired
    + 创建目录
    D 立刻删除某个文件
    R 文件重命名 / 移动文件
    C 拷贝文件
    Z 文件压缩 / 解压缩
*** magit
**** version rollback
     Logging (l)  ->  Reflog current (r)  ->  Resetting (X)  ->  hard code (h)
**** merge from another package
     : combine remote repository
     -> Remoting (add -> not to set the default remote)
     NOTE
     remote name
     you can use author's name to represent the remote url name (like purcell)
     -> Pulling ( remote )
     NOTE
     git pull = bring a local branch up-to-date with its remote version
     git fetch = update your remote-tracking
     -> Pushing ( origin )

     : some kind of combine operator
     -> Merging (check out -> feature -> merge -> master)
     create a 'merge commit' after master
     and all commits in feature branch are combined in 'merge commit'
     NOTE
     this commit may confused the people of your team
             feature
          * -> * -> (*)
          ^          ^  Merge
     * -> * -> * ->  *
            master
     -> Rebse (-i) (check out -> feature -> rebase -> master)
     remove all commits in feature branch to the end of master
     NOTE
     rebase may create each commit of your feature branch
     WARM
     do not rebase master to your feature branch
     it may cut other people master to the end of your feature branch
                      feature
                   (*) -> * -> *
                    ^  Rebase
     * -> * -> * -> *
             master
     -> Reverting
     with a new commit to roll back the previous commit
     NOTE
     this is a safe to move your feature branch to the end of master
         +-*-+       (*)
          ^         ^
     * -> * -> * -> *
**** useful function
     magit-find-file
     magit-list-repositories
     magit-file-popup -> { magit-blame magit-log-buffer-file }
*** w3m
    R  reload
    G  new tab
    s  history
    =  show information
    \  show html
*** gnus
**** active gmail
     https://myaccount.google.com/lesssecureapps
**** server
     press ^ from the group buffer to see it
     in the server buffer, you can press RET on a defined server
     to see all the groups it serves
**** group
     : new group *
     : subscription *
     : scan *
     : level *
     : zombie *
     : topic *
**** mail
     : expiring *
**** link
     Move the cursor over the link, and press "u". This calls `shr-copy-url`
     and copies the url into the kill-ring. You can paste it then in any browser
**** summary
     : article *
*** melpa
    M-x package-list-packages U x
*** yasnippet
    # expand-env: ((yas-indent-line 'fixed) (yas-wrap-around-region 'nil))
*** info
    l    history back
*** help
    C-h b    keybinding
    C-h r    emacs bible
    C-h m    describe mode
    C-h ?    what you are looking for
*** company
    use the default set dabbrev
    because any other set of company backend is slower
*** web
    C-j    emmet-expand-line
           browse-url-of-file
**** flycheck
     use html-mode to enable flycheck
*** google-translate
    the `listen` button require to install the `mplayer` in homebrew
*** recover
    recover-this-file
*** tex
    M-x set-input-method TeX
    type something like \alpha
    switch the input method off by typing 'C-\'
    find support Tex command with 'M-x describe-input-method'
    default input method rfc1345

    \->{x}    denote a -> on top of x
    \(w-1){\sum}{i=0}    denote a w-1 on top of \sum and the \sum on top of i = 0

    markdown syntax
    $...$      display inside inside a line
    $$...$$    display alone
*** indent
    aggressive-indent
*** debug
    elisp-bug-hunter
    M-x bug-hunter-*
*** markdown
    S-TAB
*** erc
*** html
    : emmet
    enable emmet mode
    place point in a emmet snippet and press `C-j` to expand it
    : html mode
    https://www.gnu.org/software/emacs/manual/html_node/emacs/HTML-Mode.html
    C-c /        insert a close tag
    C-c <TAB>    toggle the visibility of existing tags in the buffer
*** folding
    origami mode
    init-folding
*** bug
    Debugger entered--Lisp error: (invalid-read-syntax "#")
      delete the historian file (~/.emacs.d/.historian)
