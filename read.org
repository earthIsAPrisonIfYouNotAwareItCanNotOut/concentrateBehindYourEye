#+TODO: READING | READED ABANDON WAITING
* READED github入门与实践
  :PROPERTIES:
  :COLUMNS:   %25ITEM %55CLOCK %30INTRODUCE %50TOPIC
  :END:
** 社会化编程
   :PROPERTIES:
   :CLOCK:
   :TOPIC:     初步了解github理念
   :COMMAND:   watch follow pull request issue markdown
   :END:
   :以人为中心
   :免费无限git仓库
   :公司organization账户
   :问题分配issue bug管理系统tidd issueID
   :pull request仓库合并
   :markdown  @organization/user #issue
   :watch  news feed仓库提交信息
   :follow用户 在github上做了什么
** git
   :LOGBOOK:  
   CLOCK: [2016-08-28 日 17:21]--[2016-08-28 日 17:37] =>  0:16
#+BEGIN: clocktable :maxlevel 2 :scope subtree
#+CAPTION: Clock summary at [2016-08-11 四 17:35]
| Headline     | Time   |      |
|--------------+--------+------|
| *Total time* | *0:23* |      |
|--------------+--------+------|
| \emsp git    |        | 0:23 |
#+END:

#+BEGIN: clocktable :maxlevel 2 :scope subtree
#+CAPTION: Clock summary at [2016-08-11 四 17:34]
| Headline     | Time   |      |
|--------------+--------+------|
| *Total time* | *0:23* |      |
|--------------+--------+------|
| \emsp git    |        | 0:23 |
#+END:

   CLOCK: [2016-08-08 一 22:38]--[2016-08-08 一 23:01] =>  0:23
   :END:      
   :PROPERTIES:
   :CLOCK:
   :TOPIC:     git相关操作
   :COMMAND:   clone init status commit log push pull branch merge
   :END:
   :终端 git bash
   :初始化姓名和邮箱 git config --globe user.name/user.email ""
   :设置ssh key
     1. 创建ssh-key  gen -t rsa -C "your_email@example.com"
     2. github添加公开密钥
   :克隆仓库 git clone
   :提高可读性  README.md
   :掌握markdown语法
   :未添加至git仓库 显示为untracked files
   :初始化仓库  git init
   :查看仓库状态  git status
   :向暂存区中添加文件  git add
   :保存仓库的历史记录  git commit
   :查看提交日志  git log
   :本地仓库与github同步  git push
   :查看更改前后的差别  git diff
   :显示分支一览表  git branch
   :创建、切换分支  git checkout -b / git branch  git checkout
   :合并分支 git merge
   :回溯历史版本  git reset
   :多人协作 不断从github库中push pull
** github 
   :LOGBOOK:  
   CLOCK: [2016-08-28 日 20:07]--[2016-08-28 日 23:27] =>  3:20
    CLOCK: [2016-08-28 日 17:39]--[2016-08-28 日 18:05] =>  0:26
    :END:      
   :PROPERTIES:
   :CLOCK:
   :INTRODUCE:     全方位了解网页版github全部功能
   :TOPIC:   
   :END:
*** 快捷键
    :LOGBOOK:  
    CLOCK: [2016-08-28 日 23:27]--[2016-08-28 日 23:30] =>  0:03
    :END:      
    :PROPERTIES:
    :CLOCK:
    :INTRODUCE:     方便操作
    :TOPIC:   shitt + /
    :END:
    - 显示快捷键一览表 shift+/
*** 工具栏
    :LOGBOOK:  
    CLOCK: [2016-08-28 日 23:30]--[2016-08-28 日 23:34] =>  0:04
    :END:      
    :PROPERTIES:
    :CLOCK:
    :INTRODUCE:     出现LOGO那一行
    :TOPIC:   LOGO Notifications *explore* *Gist*
    :END:
    - LOGO 点击进入控制面板
    - Notifications  用户有新建issure 评论 pull request 等会收到通知
    - 搜索窗口 查询用户代码片段信息
   *- explore 从各个角度介绍热门软件 了解最尖端的技术和软件*
   *- Gist 管理没必要保存在仓库中的代码片段 可以方便的为他人编写代码示例*
    - Blog 官方博客链接
    - Help 帮助文档
    - Setting 仓库内置相关选项
*** 控制面板
    :LOGBOOK:  
    CLOCK: [2016-08-28 日 23:34]--[2016-08-28 日 23:37] =>  0:03
    :END:      
    :PROPERTIES:
    :CLOCK:
    :INTRODUCE:     点击LOGO后出现的网页
    :TOPIC:   *News Feed*  Issue Star  Your Repositories
    :END:
   *- News Feed  用户follow和项目watch信息 可通过rss查看*
    - Pull Request  方便追踪Pull Request后续情况
    - Issue  一并查看多个项目的Issue
    - Star  给项目添加标签 方便查找
    - Your Repositories  私有共有和fork的仓库
*** 个人信息 https://github.com/用户名
    :LOGBOOK:  
    CLOCK: [2016-08-28 日 23:37]--[2016-08-28 日 23:41] =>  0:04
    :END:      
    :PROPERTIES:
    :CLOCK:
    :INTRODUCE:     点击个人头像<Your Profile>
    :TOPIC:   Profile Overview Contributs
    :END:
    - Profile 包括姓名 邮箱 所属公司 organization 可以点击follow
    - Overview  显示个人仓库中最受欢迎的
    - Contributs  按时间顺序显示pull request
*** 仓库 https://github.com/用户名/仓库名
    :LOGBOOK:  
    CLOCK: [2016-08-28 日 23:41]--[2016-08-28 日 23:53] =>  0:12
    :END:      
    :PROPERTIES:
    :CLOCK:
    :INTRODUCE:     在个人信息网页中点击一个仓库名
    :TOPIC:         watch star fork code issue <p的第十行 url尾部会添加#L10 程序员讨论时 可以明确指向某一行
   *- 仓库界面按t  模糊搜索相关文件*
*** *:查看差别*
    :LOGBOOK:  
    CLOCK: [2016-08-28 日 23:56]--[2016-08-28 日 23:58] =>  0:02
    :END:      
    :PROPERTIES:
    :CLOCK:
    :INTRODUCE:     通过 url 进行仓库软件进行比对
    :TOPIC:         各版本之间 指定时间 指定日期
    :END:
    - https://github.com/rails/rails/compare/4-0-stable...3-2-stable  查看4-0版本与3-2的稳定版本之间的差别
    - https://github.com/rails/rails/compare/master@{7.day.ago}...master  查看master分支在7天内的差别 {day week month year} 差别过大只会显示部分
    - https://github.com/rails/rails/compare/master@{2013-01-01}...master  查看与指定日期之间的差别
*** Issue
    :LOGBOOK:  
    CLOCK: [2016-08-29 一 08:41]--[2016-08-29 一 08:54] =>  0:13
    CLOCK: [2016-08-29 一 00:33]--[2016-08-29 一 08:34] =>  8:01
    CLOCK: [2016-08-28 日 23:58]--[2016-08-29 一 00:33] =>  0:35
    :END:      
    :PROPERTIES:
    :CLOCK:
    :INTRODUCE:     bug报告 询问 探讨 今后任务
    :TOPIC:         GFW Label milestones 通过commit操纵issue
    :END:
    - GFW  富文本描述
      #+Name: <语法高亮>
      #+BEGIN_SRC <markdown>
         ````ruby
         def hello_world
             puts 'hello world'
         end
         ````
      #+END_SRC

      #+Name: <复选列表样式>
      #+BEGIN_SRC <Tasklist>
         # 本月要做的任务
           - [ ]完成图片
           - [x] 完成部署工具的设置
           - [ ] 实现抽签功能
      #+END_SRC
    - 添加图片  直接拖拽
   *- 添加标签(label)  积攒到一定数量 筛选管理*
   *- 添加里程碑(milestones)  完成下一个版本还剩下几个issue 完成度 ?%*
    - 规范  有些仓库软件会对 issue 界面进行规范制定 请仔细阅读
   *- 通过提交信息操作issue*
      #+Name: <在提交信息中显示issue号>
      #+BEGIN_SRC <commit>
         Add feature user add #24  ;;#24为issue号
      #+END_SRC

      #+Name: <在commit中关闭issue>
      #+BEGIN_SRC <commit>
         fix #24
         fixs #24
         fixed #24
         close #24
         closes #24
         closed #24
         resolve #24
         resolves #24
         resolved #24
      #+END_SRC
    - issue与pull request编号相互通用
*** *Pull Request*
    :LOGBOOK:  
    CLOCK: [2016-08-29 一 08:55]--[2016-08-29 一 11:20] =>  2:25
    :END:      
    :PROPERTIES:
    :CLOCK:
    :INTRODUCE:     开源开发核心功能 [[流程]]
    :TOPIC:         conversation commit <files changed>
    :END:
    #+Name: <获取 diff 与 patch 格式文件>
    #+BEGIN_SRC <https>
      https://github.com/用户名/仓库名/pull/28
      https://github.com/用户名/仓库名/pull/28.diff
      https://github.com/用户名/仓库名/pull/28.patch
    #+END_SRC
    - 按R引用评论内容  选中评论中某一段 在按R
    - 在评论中使用表情  在评论中使用:启动表情自动补全功能
    - commit  该骂更改提交次数
    - Files Changed  更改的文件内容前后差别 标签上数字显示文件数
      - 不显示空格的差别  url 末尾添加 ?w=1
      *- 在修改代码左侧点击＋  针对修改的代码进行评论*
*** Wiki
    :LOGBOOK:  
    CLOCK: [2016-08-29 一 11:20]--[2016-08-29 一 11:31] =>  0:11
    :END:      
    :PROPERTIES:
    :CLOCK:
    :INTRODUCE:     一个简单的软件文档
    :TOPIC:         page
    :END:
    - page  显示所有相关的页面
*** Pulse
    :LOGBOOK:  
    CLOCK: [2016-08-29 一 11:32]--[2016-08-29 一 11:47] =>  0:15
    :END:      
    :PROPERTIES:
    :CLOCK:
    :INTRODUCE:     判断软件是否在积极开发 认真进行bug维护
    :TOPIC:         <active pull request> <active issue>
    :END:
    - active pull request  所有合并以及未合并的pull request
      - merged  已合并的pull request 点击可查看链接
      - proposed  处于开放状态未合并的pull request
    - active issue  open和close的issue
    - commit
*** Graphs
    :LOGBOOK:  
    CLOCK: [2016-08-29 一 13:42]--[2016-08-29 一 13:55] =>  0:13
    :END:      
    :PROPERTIES:
    :CLOCK:
    :INTRODUCE:     仓库信息统计汇总
    :TOPIC:         contributes <commit activate> <code frequency> punchcard member
    :END:
    - contributes  了解代码编写人 分析维护和稳定阶段
    - commit activate  判断是否有人在积极更新
    - code frequency  代码增加量和减少量
   *- punchcard  直观显示哪个时段收到的提交次数最多 用来判断发送pull request在哪个时段内会被处理 软件开发集中在哪个时间段*
    - menmber  所有fork仓库信息
*** Setting
    :LOGBOOK:  
    CLOCK: [2016-08-29 一 13:55]--[2016-08-29 一 14:07] =>  0:12
    :END:      
    :PROPERTIES:
    :CLOCK:
    :INTRODUCE:     仓库信息设置
    :TOPIC:         Option Collaborators <Webhook & Server> <Deploy key>
    :END:
    - Option
      - github page
      - Danger Zone
      - feature
   *- Collaborators*  允许其他用户对仓库进行编辑
      - organization  建议赋予组织权限
    - Webhook & Server
    - Deploy key
*** Notifications
    :LOGBOOK:  
    CLOCK: [2016-08-29 一 14:08]--[2016-08-29 一 14:20] =>  0:12
    :END:      
    :PROPERTIES:
    :CLOCK:
    :INTRODUCE:     实时更新个人相关 issue <pull request> 状态
    :TOPIC:         
    :END:
*** 其他
    :LOGBOOK:  
    CLOCK: [2016-08-29 一 14:22]--[2016-08-29 一 14:29] =>  0:07
    :END:      
    :PROPERTIES:
    :CLOCK:
    :INTRODUCE:     涵盖多领域的其他功能
    :TOPIC:         <github enterprice> <github job>
    :END:
*** 发送pull request
    :LOGBOOK:  
    CLOCK: [2016-09-01 四 13:06]--[2016-09-01 四 13:26] =>  0:20
    :END:      
    :PROPERTIES:
    :CLOCK:
    :INTRODUCE:     了解pull request发送流程 如何高效利用
    :TOPIC:         流程解析 高效开发 正在开发中[WIP]
    :END:
    - 流程 <<流程>>
      - 他人github仓库 : fork -> pull -> 创建特性分支 -> push -> pull request
        - fork到自己的github仓库 -> clone到本地 -> 本地创建分支进行编程 -> 推送到远程github仓库 -> 在branch中create new pull request
      - 自己的github仓库 : pull -> 创建特性分支 -> push -> pull request
    - 在开发过程中发送pull request进行讨论
      - 避免在开发完成后收到设计或功能上面的指正
    - 还没开发完成的特性 在标题中注释[WIP]
*** *仓库维护*
    :LOGBOOK:  
    CLOCK: [2016-09-01 四 13:45]--[2016-09-01 四 20:10] =>  6:25
    :END:      
    :PROPERTIES:
    :CLOCK:
    :INTRODUCE:     让编写的仓库保持最新状态
    :TOPIC:         clone remoting fetch <merge or pull>
    :END:
    - clone  先从原始仓库进行fork 再clone到本地
    - remoting  将 原始仓库 设置upstream名称
    - fetch  从 upstream 获取最新代码(fetch) 与 自己仓库的分支 进行合并
    - merge or pull
      - terminal  merge upstream into master
      - emacs magit  pull from upstream
*** *接收 pull request*
    :LOGBOOK:  
    CLOCK: [2016-09-02 五 08:22]--[2016-09-02 五 09:03] =>  0:41
    :END:      
    :PROPERTIES:
    :CLOCK:
    :INTRODUCE:     如何自动合手动合并 pull request
    :TOPIC:         PR发送者 PR接收者
    :END:
    - PR发送者
      - fork -> pull -> push -> pull request
      - 在本地克隆对方仓库环境 编码发送 PR
    - PR接收者
      - 自动合并
        - 在github上直接操作
          - auto merge
          - 在 PR 上讨论 修正后合并
      - 手动合并
        - clone -> fetch
        - 本地创建特性分支和 fetch 过来的对方仓库进行合并 确认无误后push到 github 仓库
*** 查看图片差别
    :LOGBOOK:  
    CLOCK: [2016-09-02 五 09:05]--[2016-09-02 五 09:09] =>  0:04
    :END:      
    :PROPERTIES:
    :CLOCK:
    :INTRODUCE:     提供各种查看图片的差别的方式
    :TOPIC:         同时显示 两侧分别显示 分阶段过渡到新图片 找茬 161
    :END:
** github 相互协作的工具及服务
*** hub 命令
    :LOGBOOK:  
    CLOCK: [2016-09-02 五 10:08]--[2016-09-02 五 10:39] =>  0:31
    :END:      
    :PROPERTIES:
    :CLOCK:
    :INTRODUCE:     Github 的 API 命令
    :TOPIC:         172
    :END:
*** Travis CI
    :LOGBOOK:  
    CLOCK: [2016-09-02 五 10:40]--[2016-09-02 五 11:10] =>  0:30
    :END:      
    :PROPERTIES:
    :CLOCK:
    :INTRODUCE:     一款针对 github 持续集成的免费服务(开源免费)
    :TOPIC:         178
    :END:
*** Coveralls
    :LOGBOOK:  
    CLOCK: [2016-09-02 五 11:10]--[2016-09-02 五 11:27] =>  0:17
    :END:      
    :PROPERTIES:
    :CLOCK:
    :INTRODUCE:     检测代码测试覆盖率(开源免费)
    :TOPIC:         183
    :END:
*** Gemnasium
    :LOGBOOK:  
    CLOCK: [2016-09-02 五 11:27]--[2016-09-02 五 11:30] =>  0:03
    :END:      
    :PROPERTIES:
    :CLOCK:
    :INTRODUCE:     当前版本提醒(开源免费)
    :TOPIC:         187
    :END:
*** Code Climate
    :LOGBOOK:  
    CLOCK: [2016-09-02 五 11:30]--[2016-09-02 五 11:33] =>  0:03
    :END:      
    :PROPERTIES:
    :CLOCK:
    :INTRODUCE:     Github 的 API 命令(收费)
    :TOPIC:         188
    :END:
*** jenkins
    :LOGBOOK:  
    CLOCK: [2016-09-02 五 11:33]--[2016-09-02 五 16:45] =>  5:12
    :END:      
    :PROPERTIES:
    :CLOCK:
    :INTRODUCE:     持续集成的代表服务(免费)
    :TOPIC:         189
    :END:
** github 开发流程
*** *Git Flow*
**** *Git Flow 以部署为中心的开发模式*
     :LOGBOOK:  
     CLOCK: [2016-09-02 五 18:00]--[2016-09-02 五 19:00] =>  1:00
     CLOCK: [2016-09-02 五 16:51]--[2016-09-02 五 17:22] =>  0:31
     :END:      
     :PROPERTIES:
     :CLOCK:
     :INTRODUCE:     以部署为中心的开发模式
     :TOPIC:         不fork仓库 团队循环开发模式 部署测试自动化
     :END:
     - 不fork仓库  这一流程不需要fork仓库便可进行开发部署
     - 团队循环开发模式(master -> branch -> pull request -> master)
       - 随时部署  master分支保持随时可以部署的状态 防止同时出现多个严重bug
       - 进行新作业要从master分支创建新分支  新分支取名要具有功能描述性 例: redis-transition
         - 在创建的分支中进行提交  绝对不进行与该分支 /内容无关/ 的的修改
           - 提交 /细粒度/  一次提交包含一次差异
       - /定期/ push  备份代码
       - 尽早创建 pull request  /边听取反馈边编写代码/ @用户名 发送 notifications
       - 务必让开发者进行审查  前提是该部分代码已经通过 /自动测试/ 通过后进行master合并
       - 合并后 /立刻进行部署/  再次确认合并的代码是否存在问题
     - 部署自动化
       - 使用部署工具  部署工作简化成一条指令 回滚功能
       - 注意事项  防止一个部署尚未完成 开发者已经处理完下一个pull request
     - 重视测试
       - 测试自动化  检测是否有代码被恶意破坏
       - 编写代码 通过测试  /每一名开发者必须编写测试代码/
       - 维护测试代码  提高测试效率
**** *模拟体验 Github Flow*
     :LOGBOOK:  
     CLOCK: [2016-09-03 六 08:11]--[2016-09-03 六 09:09] =>  0:58
     :END:      
     :PROPERTIES:
     :CLOCK:
     :INTRODUCE:     在 github flow 流程下模拟开发一个软件
     :TOPIC:         提供测试代码 正常文件格式 218
     :END:
**** 团队实践 Github Flow几点建议
     :LOGBOOK:  
     CLOCK: [2016-09-03 六 09:14]--[2016-09-03 六 09:51] =>  0:37
     :END:      
     :PROPERTIES:
     :CLOCK:
     :INTRODUCE:     总结的一些经验
     :TOPIC:         试运行环境 <PR减少体积 不要太多反馈 积攒太多>  230
     :END:
     - 减少PR体积
       - 大代码量的 pull request 不容易查出 bug 进行部署时会畏手畏脚
       - 几小时或者几天的代码量提交会提高审查效率 加快开发进度
       - 进行功能讨论前应该将 /软件功能细化/
     - 准备试运行的环境
       - 对系统有重大影响的关键修改 为了避免在部署时发生意外 最好在预演环境中试运行
       - 不要把所有修改都放到预演环境中 免得画蛇添足
     - 不要让PR太多反馈
       - 团队在开发时 最好先制定规范 共享知识 可参考的资料
       - 避免因个人编程能力不足 团队交流不足造成的 PR迟迟无法合并的现象
     - 不要积攒PR
       - 下一个PR发送前 先帮忙审查完前面PR
       - 大量的PR积累 会导致长期无法部署 引发严重问题
*** *Git Flow* (with develop release hotfix)
**** compare with above
     :PROPERTIES:
     :CLOCK:
     :INTRODUCE:     相比较原始的 git flow 更加复杂
     :TOPIC:         develop开发分支 ?release发布版本分支 hotfix应急措施分支  234
     :END:
     - develop开发分支
       - 用于开发软件功能
       - 特性分支开发完成后与之合并
       - 在特性开发之前应该先将 /获取develop分支最新代码/
     - ?release发布版本分支(/可省略 直接在 master 分支上进行 release 操作/)
       - 建议在 develop 开发分支 功能完善后 /在网页进行 release 操作/
       - 分支完成后 /只做相关bug修复 减少功能上的增减/
     - hotfix应急措施分支
       - 当 develop 分支正在 /开发新功能/ 旧功能出现严重 bug
       - 该分支用于临时开通一个渠道进行 /修复工作/
       - 修复完成后与与 master 合并 进行 release 操作
       - 最后修复 develop 分支上的漏洞
     - 流程图 258
       - [[file:~/desktop/Git_Flow.png]]
** github 应用到企业
   :LOGBOOK:  
   CLOCK: [2016-09-04 日 16:10]--[2016-09-04 日 16:23] =>  0:13
   :END:      
   :PROPERTIES:
   :TOPIC:      Subversion  264
   :END:
** GitBucketA
   :LOGBOOK:  
   CLOCK: [2016-09-04 日 16:24]--[2016-09-04 日 16:27] =>  0:03
   :END:      
   :PROPERTIES:
   :INTRODUCE:  和github类似 提供免费私人仓库的服务
   :TOPIC:      268
   :END:
** Gist
   :PROPERTIES:
   :INTRODUCE:  分享代码片段
   :TOPIC:      275
   :END:
* READING pro git
** 起步 get start
*** 基础要点 git basics
**** 直接快照 而非比较差异 snapshotss not differences
     - 文件数据整体是否发生变化 而不是文件内容的具体差异
       The major difference between Git and any other VCS (Subversion and friends included):
       - git
         Every time you commit, or save the state of your project in Git
         it basically takes a picture of what all your files look like at that moment and stores a reference to that snapshot
         Storing data as snapshots of the project over time [P En 32]
       - other VCS
         store information as a list of file-based changes
         Storing data as changes to a base version of each file [P En 32]
**** 时刻保持数据完整性 git has integrity
     - 哈希值索引
       Everything in Git is check-summed before it is stored and is then referred to by that checksum
       In fact, Git stores everything in its database *not by file name* but by the hash value of its contents
          /24b9da6552252987aa493b52f8696cd6d3b00373/
**** 多数操作仅添加数据 git generally only adds data
     - 一旦提交快照 不用担心丢失数据
       When you do actions in Git, nearly all of them only add data to the Git database
       after you commit a snapshot into Git, it is very difficult to lose, especially if you *regularly push your database to another repository*
**** 三种状态 the three states
     - 已提交 已修改 已暂存 之间的基本流程
       - modify files in your working directory (modified)
         - working directory
           The working directory is a single checkout of one version of the project
       - stage the files, adding snapshots of them to your staging area (staged)
         - staging area
           The staging area is a file, generally contained in your Git directory, that stores information about what will go into your next commit
       - do a commit, which takes the files as they are in the staging area and stores that snapshot permanently to your Git directory
         - Git directory
           The Git directory is where Git stores the metadata and object database for your project.
           This is the most important part of Git, and it is what is copied *when you clone a repository from another computer*

       Working directory, staging area, and Git directory [P En 35]
**** 查看配置信息 checking your settings
     - 查看已有的配置
       $ git config --list
     - 查阅某个环境变量的设定
       $ git config user.name
**** 获取帮助 getting help
     $ git help <cmd>
     $ git <cmd> --help
     $ man git <cmd>
** 基础 git basics
*** 取得项目的git仓库 getting a git repository
**** 从当前目录初始化 initializing a repository in an existing directory
     - 对现有的某个项目开始用git管理
       =# This creates a new subdirectory named .git that contains all of your neces- sary repository files – a Git repository skeleton=
       $ git init
     - 将文件纳入版本控制
       $ git add *.c
       $ git add LICENSE
       $ git commit -m 'initial project version'
**** 从现有仓库克隆 cloning an existing repository
     - git仓库创建副本
       - git clone [url]
         $ git clone https://github.com/libgit2/libgit2
       - clone the repository into a directory
         $ git clone https://github.com/libgit2/libgit2 mylibgit
*** 记录每次更新到仓库 recording changes to the repository
    : The lifecycle of the status of your fles [P En 45]
**** 检查当前文件状态 checking the status of your files
     - 显示任何文件信息
       $ git status
**** 跟踪新文件 tracking new files
     - 跟踪一个新文件
       $ git add README
**** 暂存已修改文件 staging modified files
     - 文件暂存 下次提交时 一并记录到仓库
**** 忽略某些文件 ignoring files
     - .gitignore 避免提交无用的文件
       - The *rules for the patterns* you can put in the .gitignore file
         Blank lines or lines starting with # are ignored.
         Standard [[glob patterns]] work.
         You can end patterns with a forward slash (/) to specify a directory.
         You can negate a pattern by starting it with an exclamation point (!).

         - <<glob patterns>>
           : Glob patterns are like simplified regular expressions that shells use
           (*) matches zero or more characters
           [abc] matches any character inside the brackets (in this case a, b, or c)
           (?) matches a single character
           ([0-9]) match- es any character between them (in this case 0 through 9)
         - .gitignore example
           *.a                 =# no .a files=
           !lib.a              =# but do track lib.a, even though you're ignoring .a files above=
           /TODO               =# only ignore the root TODO file, not subdir/TODO=
           build/              =# ignore all files in the build/ directory=
           doc/*.txt           =# ignore doc/notes.txt, but not doc/server/arch.txt=
           doc/**/*.txt        =# ignore all .txt files in the doc/ directory=
**** 查看已暂存和未暂存的更新 viewing your staged and unstaged changes
     - 浏览暂存前后的变化
       $ git diff
**** 提交更新 committing your changes
     - 暂存的内容提交到仓库
       $ git commit
       $ git commit -m "Story 182: Fix benchmarks for speed"
**** 跳过使用暂存区域 skipping the staging area
     - 无需暂存 直接提交
       $ git commit -a -m 'added new benchmarks'
**** 移除文件 removing files
     - 移除文件
       $ git rm
       $ git rm -f     =# If you modified the file and added it to the index already, you must force the removal with the -f option=
     - 从跟踪文件清单中删除
       $ git rm --cached
     - glob模式
       =# Note the backslash (\) in front of the *, This is necessary because Git does its own filename expansion in addition to your shell’s filename expansion=
       $ git rm log/\*.log
**** 移动文件 moving files
     - 提交前删除老的文件名 再添加新的文件名
       $ git mv README.md README

       =# this is equivalent to running=

       $ mv README.md README
       $ git rm README.md
       $ git add README
*** 查看提交历史 viewing the commit history
    - 
* ABANDON 算法的乐趣
  CLOSED: [2017-02-10 五 16:09]
** READING 
   :LOGBOOK:  
   CLOCK: [2016-08-27 六 16:42]--[2016-08-27 六 16:46] =>  0:04
   :END:      
   :PROPERTIES:
   :COLUMNS:    %25ITEM %55CLOCK %1LEVEL %USED
   :LEVEL_ALL:  "A" "B" "C"
   :END:
*** 循环
**** 单循环
***** 小九宫格遍历
      :LOGBOOK:  
      CLOCK: [2016-08-27 六 17:34]--[2016-08-27 六 17:39] =>  0:05
      CLOCK: [2016-08-27 六 16:50]--[2016-08-27 六 17:03] =>  0:13
      :END:      
      :PROPERTIES:
      :CLOCK:
      :LEVEL:   C
      :USED:    0
      :END:
      #+Name: <标记小九宫格>
      #+BEGIN_SRC <c++>
         for(int i = 0; i < 9; i++)
         {
            int row = i / 3;
            int col = i % 3;
            game -> cells[row][col].fixed = false;
         }
      #+END_SRC
***** 出现相同的数的次数
      :LOGBOOK:  
      CLOCK: [2016-08-27 六 20:34]--[2016-08-27 六 20:40] =>  0:06
      :END:      
      :PROPERTIES:
      :CLOCK:
      :LEVEL:   C
      :USED:    0
      :END:
      #+Name: <计算存储在value数组中取值范围1-100之间的相同的数的次数>
      #+BEGIN_SRC <c++>
         for(int i = 0; i < count; i++)
            numCount[value[i] - 1]++;
      #+END_SRC
*** 递归
**** 二叉树查找
     :LOGBOOK:  
     CLOCK: [2016-08-27 六 17:41]--[2016-08-27 六 17:50] =>  0:09
     :END:      
      :PROPERTIES:
      :CLOCK:
      :LEVEL:   C
      :USED:    0
      :END:
      #+Name: <二叉树查找>
      #+BEGIN_SRC <c++>
         bool findNode(*tr , key)
         {
            if(tr == null)
               return false;
            if(tr -> key == key)
               return true;

            if(key < tr -> key)
               return findNode(tr -> left, key)
            else
               return findNode(tr -> right, key)
         }
      #+END_SRC

*** 判断
**** 闰年
     :LOGBOOK:  
     CLOCK: [2016-08-27 六 20:19]--[2016-08-27 六 20:23] =>  0:04
     :END:      
     :PROPERTIES:
     :CLOCK:
     :LEVEL:   C
     :USED:    0
     :END:
      #+Name: <闰年判断>
      #+BEGIN_SRC <c++>
         if(((year % 4 == 0) && (year % 100 !=0))|| (year % 400 == 0))
         {

         }
      #+END_SRC
* READED vim实用技巧 Practical Vim
  :PROPERTIES:
  :COLUMNS:  %20ITEM %50SUMMARY %30SOURCE %OPERATE
  :END:
** 启动及功能列表
  + $ vim -u NONE -N  恢复出厂设置 19
  + $ vim -u code/essential.vim  自定义插件形式启动 20
  + 功能列表 21 
** 以vim的方式解决问题 The Vim way
   :PROPERTIES:
  :SUMMARY:  思考的方式决定编码效率
  :SOURCE:   the_vim_way
  :END:
*** .命令 meet the dot command                                                 :.u:
  :PROPERTIES:
  :SUMMARY: 不要重复自我
  :SOURCE:  0_mechanics.txt
  :OPERATE: x -> . -> ..  dd －> .
  :END:
  *+ .  重复上次操作 [[:h .]]*
  + x  删除光标下的字符
  + dd  删除光标下一整行
  + u  撤销上次操作
  + >G  缩进层级 30
*** 减少无关的移动 don't repeat yourself                                       :$aA:
  :PROPERTIES:
  :SUMMARY: 注意组合键的使用
  :SOURCE:  2_foo_bar.js
  :OPERATE: A;<Esc> -> j -> . -> j.
  :END:
  + $  移动到行末 31
  + j  下移一行
  + a  光标之后添加内容
  *+ A  组合键 $ a*
*** 以退为进 take one step back, then three forward
  :PROPERTIES:
  :SUMMARY: 要替换可先删除再添加
  :SOURCE:  3_concat.js
  :OPERATE: f+ -> *s␣+␣<Esc>* -> ; -> . -> ;. -> ;.
  :END:
  *+ f[char]  找指定字符 [[:h f]]*
  + ;  向下重复上次查找
  + ,  向上重复上次查找
  + s  组合键 c l 31
*** 执行 重复 回退 act repeat reverse
  :PROPERTIES:
  :SUMMARY: 一系列内部命令的撤销操作
  :END:
  | 操作         | 目的             | 重复 | 回退 |
  |--------------+------------------+------+------|
  | {edit}       | 文本修改         | .    | u    |
  | f{char}      | 向下查找字符     | ;    | ,    |
  | F{char}      | 向上查找自负     | ;    | ,    |
  | /pattern<CR> | 查找下一处匹配项 | n    | N    |
  | ?pattren<CR> | 查找上一处匹配项 | n    | N    |
*** 查找并替换 find and replace by hand
    :LOGBOOK:  
    CLOCK: [2016-08-23 二 19:50]--[2016-08-23 二 20:12] =>  0:22
    CLOCK: [2016-08-23 二 19:41]--[2016-08-23 二 19:50] =>  0:09
    :END:      
    :PROPERTIES:
    :SUMMARY:    [[使用点范式逐个查找替换]]
    :SOURCE:     1_copy_content.txt
    :OPERATE:    光标放在content上 -> * -> cwcopy<Esc> ->n -> .
    :END:
    - 替换所有 content 为 copy
      ...We're waiting for content before the site can go live...
                      (1) ^content
                      (2) copy^
      ...If you are content with this, let's go ahead with it...
                (1) content
               (3) ^content
                (4) copy^
      ...We'll launch as soon as we have the content...
                                         (1) content

      - <<使用点范式逐个查找替换>>
        (1) *   查找当前光标下单词 并高亮显示所有匹配项 [[:h *]]*
        (2) cw  删除光标起始位置到单词结束 并进入插入模式
        (3) n   跳到下一个匹配项
        (4) .   重复(2)(3)  <<点范式>>  [[替换-确认模式]]
*** 结识.范式 meet the dot formula
    :LOGBOOK:  
    CLOCK: [2016-08-23 二 20:13]--[2016-08-23 二 20:18] =>  0:05
    :END:      
    :PROPERTIES:
    :SUMMARY: 总结规律一键移动一键执行
    :END:
** 模式 Modes
*** 普通模式 (normal mode)
    :PROPERTIES:
    :SUMMARY: 操作符与动作命令结合在一起
    :SOURCE:  normal_mode
    :END:
**** 停顿时请移开画笔 pause with your brush off the page
     :LOGBOOK:  
     CLOCK: [2016-08-23 二 20:28]--[2016-08-24 三 08:15] => 11:47
     :END:      
     :PROPERTIES:
     :SUMMARY: 大时间思考小时间编码放松
     :END:
**** 把撤销单元切成块 chunk your undos
     :PROPERTIES:
     :SUMMARY: 模式切换调整细粒度
     :END:      
     - I(插入模式) -> 编写代码 -> <Esc>(思考的时候进入普通模式) -> u(撤销先前操作) 或 A o(继续进入插入模式编写代码)
     - 插入模式 <up> <down> <left> <right>   the same as   普通模式 h j k l操作  result  会产生一个新的撤销快
**** 构造可重复的修改 compose repeatable changes
     :PROPERTIES:
     :SUMMARY: 相同按键效率不同.命令影响
     :SOURCE:  the_end.txt
     :OPERATE: d -> bx  b -> dw  daw
     :END:
     The end is nigh
                   ^
                +nig+   (1)
                   +h+  (2)
                +nigh+  (3)
     - db  删除光标起始位置到单词结束(保留光标下那个词) (1)
     - x  删除光标下那个词 (2)
     - b  移到单词开头
     - dw  删除整个单词 [[:h aw]] (3)
     - daw  删除整个单词(aw为文本对象) (3)
     | 操作 | 目的         | 实际效果 | .命令效果 |
     |------+--------------+----------+-----------|
     | dbx  | 反响删除     | db x     | x         |
     | bdw  | 正向删除     | b dw     | dw        |
     | daw  | 删除整个单词 | daw      | daw       |
**** 用次数做简单的算术运算 use counts to do simple arithmetic
     :LOGBOOK:  
     CLOCK: [2016-08-24 三 09:34]--[2016-08-24 三 10:56] =>  1:22
     :END:      
     :PROPERTIES:
     :SUMMARY: <<带数字的运算>>
     :SOURCE:  sprite.css
     :OPERATE: yyp -> cW.news<Esc> -> *180<C-x>*
     :END:
     target
       .blog, .news { background-image: url(/sprite.png); }
       .blog { background-position: 0px 0px }
     change
       .blog, .news { background-image: url(/sprite.png); }
       .blog { background-position: 0px 0px }
       .news { background-position: -180px 0px }
     - [[:h count]]
     - yyp  复制一整行 光标移到下一行行首
     - cw  修改第一个单词
     - <C-a>  数字加法运算
     - <C-x>  数字减法运算
**** 能够重复 就别用次数 don't count if you can repeat
     :LOGBOOK:  
     CLOCK: [2016-08-24 三 11:05]--[2016-08-24 三 11:20] =>  0:15
     :END:      
     :PROPERTIES:
     :SUMMARY: 因为细粒度更高的.u操作
     :SOURCE:  Delete more than one word
     :OPERATE: 2dw  d2w  dw.
     :END:
     - d  删除命令
     - w  单词
**** 必要时使用次数                                                             :cw:c3w:
     :PROPERTIES:
     :SUMMARY: 同时需要删除修改
     :SOURCE:  I have a couple of questions
     :OPERATE: c3wsome more<Esc>
     :END:
     - cw 删除
**** 双剑合璧 天下无敌 combine and conquer                                      :操作符:动作命令:操作符等待模式:
     :PROPERTIES:
     :SUMMARY: 操作符＋动作命令＝操作
     :OPERATE: dl daw dap  g- gu gU  guaw
     :END:
     -    操作符(Operator)           ＋          动作命令(Motion)            ＝             操作(Action)
       | trigger | effect                |   | trigger   | effect             |   | trigger        | effect |
       |---------+-----------------------+---+-----------+--------------------+---+----------------+--------|
       | c       | change                |   | l         | a single character |   | dl d2l         |        |
       | d       | delete                |   | w aw iw   | a complete word    |   | dw d2w daw diw |        |
       | y       | yank into register    |   | s as is ) | a sentence         |   | dd 2dd         |        |
       | g~      | swap case             |   | p ap ip } | a entire paragraph |   |                |        |
       | gu      | make lowercase        |   |           |                    |   |                |        |
       | gU      | make uppercase        |   |           |                    |   |                |        |
       | >       | shift right           |   |           |                    |   |                |        |
       | <       | shift left            |   |           |                    |   |                |        |
       | =       | autoindent            |   |           |                    |   |                |        |
       | !       | Filter {motion} lines |   |           |                    |   |                |        |

            独立操作符(single Operator)
       | trigger | effect                                                 |
       |---------+--------------------------------------------------------|
       | x       | delete single character                                |
       | r       | replace (insert mode)                                  |
       | J       | cut the next line and paste to the end of current line |

     - 一个操作符被连续调用两次 他会作用当前行
       + dd  删除当千行
       + >>  缩进当前行
       + gUgU gUU  当前行第一个单词大写
     - 操作符等待模式 Operator-Pending Mode
       + 在操作符 与 命令符之间 存在一种模式
       + 在按操作符时 这种模式会等待以激活命令符
       + 同时 按下操作符时 可以按<Esc>取消
     - 操作符 (Operator) [[:h operator]]
     | 操作符 | 用途         |
     |--------+--------------|
     | c      | 修改         |
     | d      | 删除         |
     | y      | 复制到寄存器 |
     | g~     | 反转大小写   |
     | gu     | 转换为小写   |
     | gU     | 转换为大写   |
     | >      | 增加缩进     |
     | <      | 减少缩进     |
     | =      | 自动缩进     |
     - 动作命令 (Motion)
**** 扩展命令组合的威力
     :PROPERTIES:
     :SUMMARY: 自定义操作符 自定义动作命令
     :OPERATE: ae \\
     :END:
     - 自定义操作符
       - [[:h :map-operator]]
       - [[https://github.com/tpope/vim-commentary][vim-commentary]]
          - \\ap  切换但前段落注释状态
          - \\G  从当前行到文件结尾所有内容注释
          - \\\  注释当前行
     - 自定义动作命令
       - [[:h omap-info]]
       - [[https://github.com/kana/vim-textobj-entire][vim-textobj-entire]]
         - =ae  缩进整个文件 功能等同于 gg=G
     - 自定义操作符 ＋ 自定义动作命令
       - \\ae  注释整个文件
*** 插入模式 Insert Mode
    :PROPERTIES:
    :SOURCE:      insert_mode
    :END:
**** 插入模式及时更正错误 make corrections instantly from insert mode                   :<c-h>:<c-w>:<c-u>:
     :PROPERTIES:
     :SUMMARY: 插入模式文本出错 退格键删除错误文本 再输入正确内容
     :OPERATE: <C-h> <C-w> <C-u>
     :END:
     - 插入模式中文本出错 直接使用退格键删除文本
       - 避免切换模式造成的时间浪费
       - 今后再次输入对错误的文本有意识的提高警觉
     - 插入模式组合键删除字符
       | 组合键 | 用途           |
       |--------+----------------|
       | <C-h>  | 删除前一个字符 |
       | <C-w>  | 删除前一个单词 |
       | <C-u>  | 删至行首       |
**** 返回普通模式 get back to normal mode                                              :<Esc><C-[>:<C-o>zz:
     :PROPERTIES:
     :SUMMARY: 经典方式是<Esc> 巧妙方式利用插入-普通模式<C-o>
     :OPERATE: <Esc> <C-o>
     :END:
     - 切换回普通模式 :h i_CTRL-[ [[内置链接1]]
       | 按键  | 用途                |
       |-------+---------------------|
       | <Esc> | 切换到普通模式      |
       | <C-[> | 切换到普通模式      |
       | <C-o> | 切换到插入-普通模式 |
       - 插入-普通模式  在插入模式中直接执行普通模式命令 [[:h i_CTRL-O]]
         - <C-o>zz
           - zz  重绘屏幕 当前显示在屏幕正中
         - 执行完zz后返回插入模式
**** 不离开插入模式 粘贴寄存器中的文本 paste from a Register without leaving insert mode  :<C-r>{register}:
     :PROPERTIES:
     :SUMMARY: 映射<capslock>为<ctrl>
     :SOURCE:  practical-vim.txt
     :OPERATE: <C-h> <C-w> <C-u>
     :END:
     - 映射<capslock>为<ctrl>  用<ctrl-[>代替<Esc>
     - yt,  将,之前的字符放入寄存器
       - t{char}  动作命令
     - jA␣
       - j  下一行
       - A  行末
     - <C-r>0  将刚才复制的寄存器粘贴到光标位置 [[:h i_CTRL-R]]
     - <C-r>{register}  插入寄存器文本 <<技巧15>>
     - <C-r><C-p>{register}  按愿义插入文本 [[:h i_CTRL-R_CTRL-P]]
**** 随时随地做运算 do back-of-the-envelope caculations in place                       :<C-r>=:
     :PROPERTIES:
     :SUMMARY: 插入模式下在寄存器中做运算并返回结果 <<带表达式的运算>>
     :SOURCE:  back-of-envelope.txt
     :OPERATE: 1 A -> 2 <C-r>=6*35<CR>
     :END:
     6 chairs, each costing $35, totals $
                                         ^ 1 2

     - <C-r>=  表明使用表达式寄存器 <<技巧16>> <<practise 16>>
**** 用字符编码插入非常用字符 insert unusual characters by character code                :<C-v>:
      :PROPERTIES:
      :SUMMARY: 用字符编码(Unicode)插入任意字符
      :OPERATE: <C-v>{code}  其中{code}代表字符编码
      :END:
      - 插入非常用字符 <<:h i_CTRL-V_digit>>
        | 按键                | 用途                                 |
        |---------------------+--------------------------------------|
        | <C-v>{123} [fn:例1]   | 以十进制插入字符                     |
        | <C-v>u{1234} [fn:例2] | 以十六进制插入字符                   |
        | <C-v>{nondigit}     | 按原义插入非数字字符                 |
        | <C-k>{char1}{char2} | 插入二合字母{char1}{char2}表示的字符 |
      - 想知道 文档中 任意字符的编码
        - 将光标移到它上面 按 ga <<:h ga>>
      - 想知道 所有字符 的编码
        - 查 unicode表
[fn:例1] 插入A  <C-v>065
[fn:例2] 插入¿  <C-v>u00bf
**** 用二合字母插入非常用字符 insert unusual characters by digraph                       :<C-k>:
      :PROPERTIES:
      :SUMMARY:     用两个字母 代替字符编码 插入非常用字符
      :OPERATE:     <C-k>{char1}{char2} [fn:例1]
      :END:
      - 缺省二合字母集依从一定的规律 <<:h digraphs-default>>
      - 可用二合字符列表 <<:h digraph-table>>
[fn:例1] 非常用字符¿  <C-k>?I
**** 用替换模式替换已有文本 overwrite existing text with replace mode           :R:gR:
      :PROPERTIES:
      :SUMMARY:     输入字符替换已有文本
      :SOURCE:      replace.txt
      :OPERATE:     f. -> R,␣b<Esc>
      :END:      
      - R  进入替换模式 输入的字符都会与当前的文本进行替换
      - gR  虚拟替换模式 按照屏幕上实际显示的宽度来替换字符 [fn:例]
      - 单次版本的替换模式及虚拟替换模式 r{char} gr{char} <<:h r>>
[fn:例]
| 模式 | 替换文本         | 替换效果             |
|------+------------------+----------------------|
| R    | <TAB>(占8个空格) | 输入一个空格即可替换 |
| gR   | <TAB>(占8个空格) | 输入8个空格才可替换  |

*** 可视模式 Visual mode
    :Properties:
    :SUMMARY:    [[激活]] [[切换]] [[高亮选中复杂区域]] 一些按键命令与普通模式不同的另一种模式
    :SOURCE:     visual_mode
    :END:
**** 选择高亮选区 define a visual selection                                     :v:b:o:e:
     :PROPERTIES:
     :SUMMARY:    介绍可视模式3个子模式 以及<<高亮选中复杂区域>>
     :SOURCE:     Select from here to here
     :OPERATE:    1 vbb -> 2 o -> 3 e
     :END:
     Select from here to here
                         ^ 1
                 here to h 2      <-  <<切换光标方向>>
                 here to here 3   ->
     - <<激活>>
       | 命令  | 用途                   |
       |-------+------------------------|
       | v     | 激活面向字符的可视模式 |
       | V     | 激活面向行的可是模式   |
       | <C-v> | 激活面向列快的可是模式 |
       | gv    | <<重选上次的高亮选取>> |
     - <<切换>>
       | 按键            | 用途                                           |
       |-----------------+------------------------------------------------|
       | <Esc> or <C-[>  | 回到普通模式                                   |
       | v or V or <C-v> | 切换到普通模式(在相应的模式下再次输入即可返回) |
       | v               | 切换面向字符的可视模式                         |
       | V               | 切换面向行的可视模式                           |
       | <C-v>           | 切换面向列快的可视模式                         |
       | o               | 切换高亮选区活动端 [[切换光标方向]]                     |
**** 重复执行面向行的可视命令 repeat line-wise visual commands                                  :V:>:
     :PROPERTIES:
     :SUMMARY:    介绍可视模式3个子模式
     :SOURCE:     fibonacci-malformed.py
     :OPERATE:    Vj -> >.
     :END:
     def fib(n):
       a, b = 0, 1
       while a < n:
     print a,
     a, b = b, a+b
     fib(42)
     - >  缩进指定空格数
     - <  取消所缩进的空格数目
     - :set shiftwidth=4 softtabstop=4 expandtab
       - 设定 tab 占据几个空格
**** 只要可能 最好用操作命令 而不是可视命令 prefer operators to visual command where possible :vit:guit:U:
     :PROPERTIES:
     :SUMMARY:    如果想使用.命令重复某些字符替换工作 最好远离可视模式 可视模式所擅长的是修改复杂结构的文本操作
     :SOURCE:     list-of-links.html
     :OPERATE:    <可视 vit -> U> <普通 guit -> j. -> j.>
     :END:
     - 转换链接文字为大写模式
       <a href="#">one</a>
       <a href="#">two</a>
       <a href="#">three</a>

     - U  所选的字符变为大写 <<:h v_U>>
     - gU{motion}  等同于可视模式下的 U <<:h gU>>
**** 用面向列块的可视模式编辑表格数据 edit tabular data with visual-block mode                   :<C-v>:V:r:
     :PROPERTIES:
     :SUMMARY:    用面向列块的可视模式把文本变成表格
     :SOURCE:     chapter-table.txt
     :OPERATE:    <C-v>3j -> x... -> gv -> r| -> yyp -> Vr-
     :END:
     - 使用竖线隔开两列文本
       Chapter        Page
                    ^
       Normal mode    15
       Insert mode    31
       Visual mode    44

       Chapter     | Page
       --------------------
       Normal mode | 15
       Insert mode | 31
       Visual mode | 44

     - <C-v>   进入列块模式
     - x       删除此列
     - gv      重选上次的高亮选区
     - r|      选中的区域用 | 进行替换
     - yyp     复制并粘贴上面一行
       - yy or Y  复制游标所在一整行
       - p        粘贴至游标下方
       - P        粘贴至游标上方
     - Vr-     用面向行的可视模式 字符－进行整行文本替换
**** 修改列文本 change columns of text                                                        :<C-v>c<Esc>:
     :PROPERTIES:
     :SUMMARY:    如何在面向列的可视模式下同时修改多行相同数据
     :SOURCE:     sprite.css
     :OPERATE:    <C-v>jje -> c -> components -> <Esc>
     :END:
     li.one   a{ background-image: url('/images/sprite.png'); }
                                         ^
                                         components
     li.two   a{ background-image: url('/images/sprite.png'); }
     li.three a{ background-image: url('/images/sprite.png'); }

     - c  所有选择区域消失 进入插入模式
**** 在长短不一的高亮块后添加文本 append after a ragged visual block                             :$:A:
     :PROPERTIES:
     :SUMMARY:    面向列的可视模式中 完成技巧2的功能
     :SOURCE:     the_vim_way/2_foo_bar.js
     :OPERATE:    <C-v>jj$ -> A; -> <Esc>
     :END:
     var foo = 1
               ^
     var bar = 'a'
     var foobar = foo + bar

     var foo = 1;
     var bar = 'a';
     var foobar = foo + bar;

     - $  选区扩大至行尾
     - A  添加内容(限可视模式)
       | 按键 | 可视模式模式                        | 普通模式约定                        |
       |------+-------------------------------------+-------------------------------------|
       | a    | [[技巧51]]                              | 切换到插入模式 将光标置于字符之后   |
       | i    | [[技巧51]]                              | 切换到插入模式 将光标置于字符之前   |
       | A    | 切换到插入模式 将光标置于当前行之后 | 切换到插入模式 将光标置于当前行之后 |
       | I    | 切换到插入模式 将光标置于当前行之前 | 切换到插入模式 将光标置于当前行之前 |
*** 命令行模式 command-line mode
    :Properties:
    :SUMMARY:    一些沿用至今的ex命令(ex为vi之父)
    :SOURCE:     ex_mode
    :END:
**** 结识vim命令行模式 meet vim's command line                                                 :
     :PROPERTIES:
     :SUMMARY:    [[基本概念]] [[惊叹的能力]]
     :SOURCE:     
     :OPERATE:    
     :END:
     - <<基本概念>>
       - :       切换到命令行模式
       - /       调出查找提示符
       - <C-r>=  访问表达式寄存器 [[技巧16]]
       - <Esc>   返回到普通模式
     - <<惊叹的能力>>          <<:h ex-cmd-index>>
       - :edit and :write    读写文件
       - :tabnew             创建新标签页
       - :split              分割窗口
       - :copy               快速复制一行
       - :normal             对范围内的行做相同修改 [[技巧30]]
       - :delete :yank :put  [[第十章]]
       - :substitude :global [[第十五章]]
       - <C-w> <C-u> <C-v> <C-k>  插入模式通用的特殊按键
         - <C-w>  删除至上个单词的开头
         - <C-u>  删除至行首
         - <C-v>  <C-k>  插入特殊字符
         - <C-r>{register}  [[技巧15]]
       - 编辑文本的ex命令
         - [[file:~/desktop/操作缓冲区的ex命令.png]]
       - 在一行或者多行上执行命令
         - [[打印]] [[复制和移动]] [[避免重复的.命令]]
**** 在一行或者多个连续行上执行命令 execute command on one or more consecutive lines             :[range]p:
     :PROPERTIES:
     :SUMMARY:    介绍如何用ex命令<<打印>>
     :SOURCE:     practical-vim.html
     :OPERATE:    :1 :p :1p :2,5p :.,$p :%p :%s/a/b/ :/a/+1,/b/-1p :.,.+3p
     :END:      
     - 打印指定 行 / 范围行 / 行尾 / 偏移行 / 标签行
       <html>
         <head>
           <title>Practical Vim</title>
         </head>
         <body>
           <h1>Practical Vim</h1>
         </body>
       </html>

     - *:{address}*
       - :1p  打印第一行
         - :1  数字代表行 定位第一行行首
         - :p  打印当前区域
       - :%p  打印全部行
     - *:{address}+n*
       - :.,.+3p  打印当前行到下面3行
     - *:{start},{end}*
       - :2,5p  打印2到5行
       - :.,$p  打印当前行到末尾
     - *:{start}+n,{end}+n*
       - :/a/+1,/b/-1p  打印含有 a 字符的下面一行到含有 b 字符的上面一行
     - *:print :delete :join :substitude :normal*
       - :%s/a/b/  全文所有 a 替换成 b
     - 高亮选区指定范围
       - 2G -> VG -> : -> '<,'>p(预填充)

     - <<range>>
       | 符号 | 位置                    |
       |------+-------------------------|
       | 1    | 第一行                  |
       | $    | 最后一行                |
       | 0    | 虚拟行 位于第一行的上面 |
       | .    | 当前行                  |
       | 'm   | 标记的行                |
       | '<   | 高亮选取起始行          |
       | '>   | 高亮选区结束行          |
       | %    | 整个文件                |
**** 使用:t和:m复制和移动行 duplicate or move lines using ':t' and ':m' commands               :[range]t{address}:
     :PROPERTIES:
     :SUMMARY:    介绍如何用ex命令<<复制和移动>>
     :SOURCE:     shopping-list.todo
     :OPERATE:    <:6copy.(:6t.)> [[1]]   <Vjj -> :'<,'>m$> [[2]]
     :END:      
     - 复制指定行到指定地点
       Shopping list
           Hardware Store
               Buy new hammer
           Beauty Parlor
               Buy nail polish remover
               Buy nails

       (1)
       Shopping list
           Hardware Store
               Buy nails
               *Buy new hammer*
           Beauty Parlor
               Buy nail polish remover
               Buy nails

     - :[range]copy{address} <<1>>
       - :6copy. (:6t.)  <<:h :copy>>
         - [range]    第6行
         - {address}  . 代表当前行
         - 意思是复制第6行到当前行的下面
         | command  | effect                                                    |
         |----------+-----------------------------------------------------------|
         | :t6.     | Copy line 6 to just below the current line                |
         | :t6      | Copy the current line to just below line 6                |
         | :t.      | Duplicate the current line (similar to Normal mode yyp)   |
         | :t$      | Copy the current line to the end of the file <<:t>>       |
         | :'<,'>t0 | Copy the visually selected lines to the start of the file |
     - :[range]move{address} <<2>>
       - [rnage]    '<,'>当前高亮选区
       - {address}  $文本末尾
**** 在指定范围内执行普通模式 run normal mode commands across a range                           :'<:'>normal .:
     :PROPERTIES:
     :SUMMARY:    用 :normal 命令多行同时执行 . 命令 <<技巧30>>
     :SOURCE:     foobar.js
     :OPERATE:    A;<Esc> -> jVG -> :'<,'>normal .
     :END:
     - 为每一行行尾添加;
       var foo = 1
       var bar = 'a'
       var baz = 'z'
       var foobar = foo + bar
       var foobarbaz = foo + bar + baz

       var foo = 1;
       var bar = 'a';
       var baz = 'z';
       var foobar = foo + bar;
       var foobarbaz = foo + bar + baz;

     - jVG  用面向行的可视模式选中高亮区域
     -  :'<,'>normal .  再由ex命令在高亮选区范围内执行普通模式的 . 命令
        - :normal       在 ex 命令行中执行普通模式命令
     - 在每一行上执行相同的普通模式命令 <<避免重复的.命令>>
       - :%normal A;    每一行的末尾添加;号  [[用可视模式的另一种解决方案]]
       - :%normal i//   每一行都注释掉
**** 重复上次的ex命令 repeat the last ex command  [[重复ex命令]]
**** 自动补全ex命令 tab-complete your ex commands                                             :<TAB>:
     :PROPERTIES:
     :SUMMARY:    如何在补全 ex 命令  启用补全导航列表
     :END:
     - :cmd<C-d>  <<:h c_CTRL-D>>
       - <C-d>  显示可用的补全列表 多次按<TAB>效果相同
     - <TAB>  输入部分命令进行自动补全  <<:h :command-complete>>
     - 多个补全项间选择 缺省状态下<TAB>存在多个补全项 只会匹配第一个 往后每按一次匹配后面一个
       - wildmode  采用自定义补全行为  <<:h 'wildmode'>> <<vimrc相关配置1>>
         | 正向遍历 | <TAB> <C-n> <right>  |
         | 反向遍历 | <S-TAB> <C-p> <left> |
         - bash  采用bash补全
           - set wildmode=longest,list
         - zsh  采用zsh补全
           - set wildmenu
           - set wildmode=full
**** 把当前单词插入到命令行 insert the current word at the command prompt                       :<C-r><C-w>:
     :PROPERTIES:
     :SUMMARY:    <C-r><C-w>把当前光标下的单词插入到 ex 命令行中
     :SOURCE:     loop.js
     :OPERATE:    * -> :%s//<C-r><C-w>/g
     :END:
     - 把指定字符放入寄存器 替换模式进行替换
       var tally;
       for (tally=1; tally <= 10; tally++) {
         // do something with tally
       };

       var tally;
       for (counter=1; tally <= 10; tally++) {
            ^
         // do something with tally
       };

     - *  匹配当前光标下的单词 并跳到下一处匹配项
       - 等效于 /\<C-r><C-w>\><CR>  [[关于\<和\>在模式中的作用]]
     - :%s//<C-r><C-w>/g
        - :%S  整个文本进行:substitute替换
        - //  [[为什么可以将查找域留空]]  要感谢 * 命令
        - <C-r> <C-w>  把光标下的文字插入到ex命令行
**** 回溯历史命令 recall command from history                                                 :q:<C-f>:
      :PROPERTIES:
      :SUMMARY:    用<up><down> <C-n><C-p>对历史记录进行操作  [[使用q;对命令行进行编辑]]
      :SOURCE:     loop.js
      :OPERATE:    q:
      :END:
      - [[提高历史记录上限]]
      *- 命令行窗口*
        - <<使用q;对命令行进行编辑>>  例 [[file:~/desktop/命令行窗口.png]]
        - 编辑 ex 历史记录 k j <up> <down> 进行上下移动    <<重复ex命令>>
        | 命令 | 动作 |
        |------+------|
        | q/   |  打开查找命令的命令行窗口 |
        | q:   |   打开ex命令行窗口 |
        | <C-f> |   从命令行模式切换到命令行窗口 | [fn:注]
        [[命令行窗口的另一个应用实例]]
[fn:注] 在编写ex命令行模式时突然发现需要更为强大的命令行窗口
        这时就需要<C-f>将原先命令行模式的内容映射到命令行窗口中
**** 运行SHELL命令 run commands in the shell                                                 :[range][!]cmd:
      :PROPERTIES:
      :SUMMARY:    在 vim 中与 shell 交互
      :SOURCE:     emails.csv
      :OPERATE:    :2,$!sort -t',' -k2
      :END:
      | 命令                 | 用途                                              |
      |----------------------+---------------------------------------------------|
      | :shell               | 启动一个shell(输入exit返回vim)                    |    [[在shell中挂起 唤回vim]]
      | :!{cmd}              | 在shell中执行{cmd}                                |   [fn:单次执行]
      | :read !{cmd}         | 在shell中执行{cmd} 并把标准输出插入到光标下面     |       [fn:shell结果返回vim]
      | :[range]write !{cmd} | 在shell中执行{cmd} 以[range]作为其标准输入        |     [fn:vim结果返回shell]
      | :[range]!{filter}    | 使用外部程序{filter} 过滤指定的[range]            |     [[例]]
      - :2,$!sort -t',' -k2 <<例>>
        - 2,$               [range] 2到最后一行
        - sort -t',' -k2
          - sort            排序
            - t','          参数以逗号分割
            - k2            以第二个字段进行排序
      - <<在shell中挂起 唤回vim>>
        - <C-z>    挂起
        - fg       唤回
        - $jobs    当前作业列表

[fn:单次执行]  执行一行命令后返回vim
[fn:shell结果返回vim]  将!{cmd}执行结果 返回到vim当前光标下
[fn:vim结果返回shell]  将[range]内容标准输入到shell中
                      注 <:write !sh>  [range]为缓冲区内容  而 <:write! sh> 为将内容输出到一个名字为sh的文件中
**** Run Multiple Ex Commands as a Batch                                        :source:args:argdo:
     :PROPERTIES:
     :SUMMARY:    [[use vim script in a file]]  [[use vim script in a folder]]
     :SOURCE:     emails.csv
     :OPERATE:    [[Write Ex Commands to a Script and Source It]]
     :END:
     - modify this into a plain-text format showing the title followed by the URL
       <ol>
         <li>
           <a href="/episodes/show-invisibles/">
             Show invisibles
           </a>
         </li>
         <li>
           <a href="/episodes/tabs-and-spaces/">
             Tabs and Spaces
           </a>
         </li>
       </ol>

       (1)
       Show invisibles: http://vimcasts.org/episodes/show-invisibles/
       Tabs and Spaces: http://vimcasts.org/episodes/tabs-and-spaces/

       - Run Ex Commands One by One (1)
         :g/href/j
         :v/href/d
         *:%norm A: http://vimcasts.org*
         :%norm yi"$p
         :%s/\v^[^\>]+\>\s//g

       - <<Write Ex Commands to a Script and Source It>>
         - <<use vim script in a file>>
           $ vim vimcasts/episodes-1.html
           :source [[batch.vim]]
         - <<use vim script in a folder>>
                       $ vim vimcasts/*.html
           [[:args]]                 [[:argdo]] source [[batch.vim]]
           :first
           :source [[batch.vim]]
           :next
           :source [[batch.vim]]
         - <<batch.vim>>
           global/href/join
           vglobal/href/delete
           %normal A: http://vimcasts.org
           %normal yi"$p
           %substitute/\v^[^\>]+\>\s//g
** 文件 Files
*** 管理多个文件 manage mutiple files
    :PROPERTIES:
    :SUMMARY: vim允许我们在多个文件上同时工作
    :SOURCE:  files
    :END:
**** 用缓冲区列表管理打开的文件 track open files with the buffer list                     :vim:bn[ext]:bp[rev]:bd[elete]:
     :PROPERTIES:
     :SUMMARY:    vim缓冲区可以对多个文件同时进行管理
     :SOURCE:     
     :OPERATE:    $ cd code/files -> $ vim *.txt -> :ls -> :bnext -> :ls
     :END:
     - 缓冲区列表基本操作
       - $ cd code/files       进入 files 文件夹
       - $ vim *.tx            编辑所有的 txt 文件
       - :ls                   显示所有被载入内存的缓冲区列表
         - %                   当前窗口处在哪个缓冲区
         - #                   代表可轮换文件  用 <C-^> 快速进行切换
       - :bnext(:bn)   :bprev(:bp)       在列表中正向反向移动    [[创建快速遍历VIM列表的按键映射项]]
         - :bfirst   :blast    跳转到列表开头和结尾
         *- :buffer N           直接跳转到指定列表 N代表列表开头数字编号*
         - :buffer {buffername}   输入唯一标识缓冲区的字符 如匹配不止一项 TAB 切换
       - :bufdo                允许我们在所有缓冲区列表中执行 ex 命令
       - :bdelete(:bd)         删除缓冲区
         - :bdelete 5 6 7 9
         - :5,9 bdelete
     - <<创建快速遍历VIM列表的按键映射项>>    [[https://github.com/tpope/vim-unimpaired][链接]]
       - nnoremap <silent> [b :bprevious<CR>
       - nnoremap <silent> ]b :bnext<CR>
       - nnoremap <silent> [B :bfirst<CR>
       - nnoremap <silent> ]B :blast<CR>
     - [[参数列表]] 缓冲区列表的强力补充
**** 用参数列表将缓冲区分组 group buffers into a collection with the argument list :args:
     :PROPERTIES:
     :SUMMARY:    vim缓冲区可以对多个文件同时进行管理
     :SOURCE:     letters      mvc                  .chapters
     :OPERATE:    [[执行参数列表]]  [[填充参数列表(glob模式)]]  [[用反引号指定文件]]
     :END:
     - <<参数列表>>
       - <<执行参数列表>>
         - $ cd code/files/letters -> $ vim *.txt -> :args
           - :args  输出比较简陋 原本是vi的一个功能
       - <<填充参数列表(glob模式)>>
         - $ cd code/files/mvc -> $ vim -> :args index.html app.js -> :args
           - :args {arglist}             {arglist}可以包括文件名 [[通配符]] 甚至一条shell语句 默认执行ls    <<:args>>
             - glob模式指定文件 <<通配符>>   例:[[file:~/desktop/glob模式.png]]
               - *      匹配0个或多个字符 范围仅限于指定目录
               - **     匹配0个或多个字符 范围可以递归进入指定目录的子目录
       - <<用反引号指定文件>>
         - :args `cat .chapters`     反引号内可以是任意shell命令 仅限于unix-like系统
       - :next :prev
**** 管理隐藏缓冲区 manage hidden files                                                 :w[rite]:e[dit]:q[uit]:
     :PROPERTIES:
     :SUMMARY:    vim缓冲区可以对多个文件同时进行管理
     :SOURCE:     
     :OPERATE:    [[修改缓冲区列表文件]] -> [[在缓冲区中切换文件]] -> [[退出时处理缓冲区]]
     :END:
     - <<修改缓冲区列表文件>>
       - $ cd code/files -> $ ls -> $ vim *.txt -> 对 a.txt 执行 Go -> :ls
         - Go     在缓冲区尾部增加一行
         - :ls    这时 a.txt 前面显示 + 表示已经被修改过了
           | 1  %a + "a.txt"   line1 |
           |-------------------------|
           | 2       "b.txt"   line0 |
     - <<在缓冲区中切换文件>>
       - :bnext -> :bnext! -> :ls
         - :bnext!     !强制切换缓冲区 将未保存的缓冲区置为隐藏
         - :ls         a 表示当前活动缓冲区  h表示它是一个隐藏缓冲区
           | 1 #h + "a.txt" line 1 |
           |-----------------------|
           | 2 %a   "b.txt" line 1 |
     - <<退出时处理缓冲区>>
       - :q[uit] -> :w[rite] or :e[dit]! -> :q[uit]
         - 退出时处理隐藏缓冲区的方法
           | 命令     | 用途                      |
           |----------+---------------------------|
           | :w[rite] | 把缓冲区写入磁盘          |
           | :e[dit]  | 把磁盘内容读入缓冲区      |
           | :qa[ll]  | 关闭所有窗口 摒弃所有修改 |
           | :wa[ll]  | 把所有修改写入缓冲区      |
      - hidden选项     不需要! 离开缓冲区自动将其隐藏

**** 将工作区切分成窗口 divide your workspace into split windows                         :<C-w>:
     :PROPERTIES:
     :SUMMARY:    vim窗口管理
     :SOURCE:     
     :OPERATE:    [[分割窗口]] -> [[窗口切换]] -> [[关闭窗口]] -> [[重排窗口]]
     :END:
     - <<分割窗口>>
       |                | 水平分割窗口    | 垂直分割窗口     |
       |----------------+-----------------+------------------|
       | 显示当前缓冲区 | <C-w>s          | <C-w>v           |
       | 载入{file}     | :sp[lit] {file} | :vsp[lit] {file} |
     - <<窗口切换>>
       |------------+------+-------+---+-------|
       |            |      | up    |   |       |
       |            |      | k     |   |       |
       | left       | h    | <C-w> | l | right |
       |            |      | j     |   |       |
       |            |      | down  |   |       |
       |            |      |       |   |       |
       | <C-w><C-w> | loop |       |   |       |
     - <<关闭窗口>>
       | 功能           | 普通模式命令与之等效的ex命令 |
       |----------------+------------------------------|
       | 关闭活动窗口   | <C-w>c  :clo[se]             |
       | 只保留当前窗口 | <C-w>o  :on[ly]              |
     - <<重排窗口>>
       | 命令      | 用途          |
       |-----------+---------------|
       | <C-w>=    | 等宽 等高     |
       | <C-w>_    | 最大化高度    |
       | <C-w>|     | 最大化宽度    |
       | [N]<C-w>_ | 高度设为[N]行 |
       | [N]<C-w>|  | 宽度设为[N]列 |
**** 用标签页将窗口分组 organize your window layouts with tab page              :tab:
     :PROPERTIES:
     :SUMMARY:    标签页(工作区)的管理
     :SOURCE:     
     :OPERATE:    [[如何使用]] -> [[打开及关闭]] －> [[切换]]
     :END:
     - <<如何使用>>
       |            | 设置工作目录      |
       |------------+-------------------|
       | 当前窗口   | :lcd {path}       |
       | 当前标签页 | :windo lcd {path} |
     - <<打开及关闭>>
       | 命令                  | 用途                          |
       |-----------------------+-------------------------------|
       | :tabe[dit] {filename} | 打开 新标签页 {filename}      |
       | <C-w>T                | 移到 新标签页                 |
       | :tabc[lose]           | 关闭 当前标签页(下面所有窗口) |
       | :tabo[nly]            | 只保留当前标签页 关闭其他     |
     - <<切换>>
       | 用途            | 普通模式命令与之等效的ex命令 |
       |-----------------+------------------------------|
       | 切换到{N}标签页 | {N}gt  :tabn[ext] {N}        |
       | 下一标签页      | gt  :tabn[ext]               |
       | 上一标签页      | gT  :tabp[revious]           |
*** 打开及保存文件 open files and save them to disk
**** 用:edit打开文件 open a file by its filepath using ':edit'                          :edit {relative path}:
     :PROPERTIES:
     :SUMMARY:    指定 工作目录 方式 打开文件
     :SOURCE:     
     :OPERATE:    [[相对于当前目录打开文件]] [[相对于活动目录打开文件]] [[优化]]
     :END:
     - <<相对于当前目录打开文件>>
       - $ cd code/files/mvc -> $ vim index.html -> :pwd -> :edit lib/framework.js -> :edit app/controllers/Navigation.js
         - :pwd              打印工作目录
         - *:edit {file}*      基于工作目录 相对路径 打开文件
     - <<相对于活动目录打开文件>>
       - :edit %<Tab> -> :edit %:h<Tab> -> :edit app/controllers/ -> :edit %:h<Tab>M<Tab>
         - %<TAB>          显示 当前缓冲区 的 完整路径
         - %:h<TAB>        显示 当前文件 所在目录 的 路径
         - <TAB>           自动查找目录下的文件(自动补全文件名)
     - <<优化>>
       - [[:edit%20%E5%B1%95%E5%BC%80%E5%BD%93%E5%89%8D%E6%96%87%E4%BB%B6%E6%89%80%E5%9C%A8%E7%9B%AE%E5%BD%95%20vimrc%20%E9%85%8D%E7%BD%AE][:edit 展开当前文件所在目录 vimrc 配置]]
**** 使用:find打开文件 open a file by its filename using ':find'                        :find {specific path}:
     :PROPERTIES:
     :SUMMARY:    指定 多个工作目录 输入文件名 匹配完整目录
     :SOURCE:     
     :OPERATE:    [[进入工程目录]] -> [[配置 path 选项]] -> [[通过文件名查找文件]]
     :END:
     - <<进入工程目录>>
       - $ cd code/files/mvc -> $ vim index.html
     - <<配置 path 选项>>
       - :set path+=app/**
         - app/**                 匹配 app 目录下面所有子目录
     - <<通过文件名查找文件>>
       - :find Navigation.js      精确匹配(只存在一个匹配项)
       - :find Main.js<Tab>       循环匹配(存在多个匹配项)
       - 以上都可以通过<TAB>自动补全 例 :find nav<Tab>
**** 使用netrw管理文件系统 explore the file system with netrw
     :PROPERTIES:
     :SUMMARY:    原生的文件管理器
     :SOURCE:     
     :OPERATE:    [[%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%99%A8][文件管理器]]  [[网络读写文件]]
     :END:
     - 加载 netrw 插件  (可省略)
       - [[加载 VIM 发行版中自带的标配插件]]
     - <<文件管理器>>
       - $ cd code/file/mvc
         - $ vim .              直接以根目录形式打开 vim
         - $ vim index.html     打开根目录下任意文件 在缓冲区中显示根目录
           - :e[dit] .
           - :E[xplore]         netrw 命令
       - k j                    上下移动
       - <CR>                   进入指定缓冲区
     - <<网络读写文件>>
**** 把文件保存到不存在的目录 save files to nonexistent directories                       :edit {nonexistent path}:mkdir:
     :PROPERTIES:
     :SUMMARY:    :edit 命令打开一个不存在的文件路径 并进行保存
     :SOURCE:     
     :OPERATE:    :edit madeup/dir/doesnotexist.yet -> :!mkdir -p %:h -> :write
     :END:
     - :edit madeup/dir/doesnotexist.yet  编辑不存在的新文件
       - <C-g>      该文件被创建为新缓冲区
       - :write     此时如果写入文件会报错
         -  "madeup/dir/doesnotexist.yet" E212: Can't open file for writing   不存在该文件路径
     - :!mkdir -p %:h      外部的 mkdir 进行文件目录创建
       - p                 创建任何不存在的中间目录
       - %:h               当前目录
**** 以超级用户权限保存文件 save a file as the super user
     :PROPERTIES:
     :SUMMARY:    以 root 身份 保存系统文件
     :SOURCE:     
     :OPERATE:    $ ls -al /etc/ | grep hosts -> $ vim /etc/hosts -> :w !sudo tee % > /dev/null
     :END:
     - $ ls -al /etc/ | grep host          打开 etc 下的系统文件
       - $ whoami                        显示当前文件夹拥有着 (root)
     - $ vim /etc/host                   对 hosts 文件进行编辑
       - :write                          'readonly' option is set (add ! to override)      写入文件     只读出错
       - :write!                         "/etc/hosts" E212: Can't open file for writing    强制写入     没有权限
     - :w !sudo tee % > /dev/null        以 root 身份保存文件
       - !sudo                           root 身份进行操作 (需要输入密码)
       - tee % > /dev/null
         - tee                           标准输入读取数据 将其内容输出到标准输出设备 同时保存成文件
         - %                             当前目录 (etc/hosts)
         - > /dev/null                   将标准输出内容丢弃到 /dev/null
** 更快的移动及跳转 getting around faster
   :PROPERTIES:
   :SUMMARY:      vim 动作命令 移动光标 配合操作符待决模式
   :SOURCE:       motions
   :END:
*** 用动作命令在文档中移动 navigate inside files with motions
    :PROPERTIES:
    :SUMMARY:     motion 动作命令
    :SOURCE:  
    :END:
**** 让手指保持在本位行上 keep your fingers on the home row                     :hjkl:
      :PROPERTIES:
      :SUMMARY:    [[本位行]]  [[h j k l]]  [[戒掉用光标键的习惯]]
      :SOURCE:     
      :OPERATE:    
      :END:
      - <<本位行>>
        - 左手停留在      a s d f
        - 右手停留在      j k l ;
      - <<h j k l>>
        | 命令 | 光标动作                                                 |
        |------+----------------------------------------------------------|
        | h    | 左移 (只在距离差一两个字符时使用) [fn:off-by-one-errors] |
        | j    | 下移                                                     |
        | k    | 上移                                                     |
        | l    | 右移 (只在距离差一两个字符时使用) [fn:off-by-one-errors] |
      - <<戒掉用光标键的习惯>>
        - [[禁用光标键映射]]
[fn:off-by-one-errors]  差一错误    通常是指对于边界判断错误 导致多循环或少循环一次
**** 区分实际行和屏幕行 distinguish between real lines and display lines       :[g]:j:k:0:^:$:
     :PROPERTIES:
     :SUMMARY:    [[%E5%AE%9E%E9%99%85%E8%A1%8C%E4%B8%8E%E5%B1%8F%E5%B9%95%E8%A1%8C][实际行与屏幕行]]  [[%E5%AE%9E%E9%99%85%E8%A1%8C%E4%B8%8E%E5%B1%8F%E5%B9%95%E8%A1%8C%E4%BD%8D%E7%A7%BB%E6%93%8D%E4%BD%9C][实际行与屏幕行位移操作]]  [[%E4%BA%A4%E6%8D%A2%E5%AE%9E%E9%99%85%E8%A1%8C%E4%B8%8E%E5%B1%8F%E5%B9%95%E8%A1%8C%E7%9A%84%E4%BD%8D%E7%A7%BB%E6%93%8D%E4%BD%9C][交换实际行与屏幕行的位移操作]]
     :SOURCE:     
     :OPERATE:    
     :END:
     - <<实际行与屏幕行>>
       - 实际行    文本所在实际的行数
       - 屏幕行    超出窗口宽度 回绕显示在屏幕上的行数
     - <<实际行与屏幕行位移操作>>
       | 实际行命令 | 屏幕行命令 | 光标动作       |
       |------------+------------+----------------|
       | j          | gj         | 上移           |
       | k          | gk         | 下移           |
       | 0          | g0         | 行首           |
       | ^          | g^         | 第一个非空字符 |
       | $          | g$         | 行尾           |
     - <<交换实际行与屏幕行的位移操作>> (不建议进行此项配置)
       - [[重新映射面向行的动作命令]]
**** 基于单词移动 move word-wise                                              :b w:ge e:w W:
     :PROPERTIES:
     :SUMMARY:    [[单词跳转]]  [[字串跳转]]
     :SOURCE:     
     :OPERATE:    b w ge e W
     :END:
     - <<单词跳转>>
         b   b   w
       | <- |<-| -> |
       prev current next
          | <- |->| -> |
            ge  e   e
     - <<字串跳转>>
       e.g. we're going too slow
       | -> |                     wwww or  W
            |  -> |               www  or  W
           you're                 cwyou<Esc>
            it's                  cWit's<Esc>
**** 对字符进行查找 find by character                                         :<fF tT ;,>:
     :PROPERTIES:
     :SUMMARY:    [[字符查找]]  [[重复反转]]  [[出现频率]]
     :SOURCE:     
     :OPERATE:    f{char} F{char} t{char} T{char} ; ,
     :END:
     - <<字符查找>>
       f{char}      正向移动到下一个{char}所在之处    \
                                                       在普通模式下使用   \
       F{char}      反向移动到上一个{char}所在之处    /
                                                                                <<普通模式与操作符等待模式>>
       t{char}      正向移动到下一个{char}所在之处的前一个字符上   \
                                                                  在操作符等待模式下使用   /
       T{char}      反向移动到上一个{char}所在之处的后一个字符上   /
     - <<重复反转>>
       Find the first occurrence of {char} and move
       |      fo      |                                 查找字符o
                      |           ;;            |       重复上次查找2次
                                 |       ,      |       撤销最近一次查找

       I've been expecting you, Mister Bond.
                              ^                         f,
       I've been expecting you.                         dt.
     - <<出现频率>>
       在使用字符查找命令时 最好选择 出现频率频率 比较低 的字母作 目标字符
**** 通过查找命令进行移动 search to navigate                                   :</ nN>:
     :PROPERTIES:
     :SUMMARY:    [[%E5%AD%97%E7%AC%A6%E5%8C%B9%E9%85%8D%E5%BD%A2%E5%BC%8F%E6%9F%A5%E6%89%BE][字符匹配形式查找]]  [[操作文本]]
     :SOURCE:     search-haiku.txt
     :OPERATE:    /{char}
     :END:
     - <<字符匹配形式查找>>
       search for your target it only takes a moment to get where you want
                       *ta*     [[n]]->     *ta*                                      /ta<CR>  多行 多个字符 匹配字符  \
                              <-[[N]]                                                                                <<各种查找命令之间的区别>>
                                                                              ft -> ;  单行 单个字符          /
                                      *tas*                                     /tas<CR>
       - <<n>>    匹配字符 正向跳转
       - <<N>>    匹配字符 反向跳转
     - <<操作文本>>
       This phrase takes time but eventually gets to the point
                   *takes time but eventually g*                   (1)
                   *takes time but eventually*                     (2)
                   +takes time but eventually+                     (3)
       - 可视模式
         v 进入可视模式 -> /ge<CR> (1) -> h (2) -> d (3)
       - 普通模式
         d/ge<CR> (1) (3)
**** 用精确的文本对象选择选区 trace your selection with precision text objects  :<cyd ai ">]t>:
     :PROPERTIES:
     :SUMMARY:    [[%E5%8F%AF%E8%A7%86%E6%A8%A1%E5%BC%8F%20%E6%96%87%E6%9C%AC%E5%AF%B9%E8%B1%A1%20%E6%93%8D%E4%BD%9C%E6%8B%AC%E5%8F%B7%20%E8%A2%AB%E5%BC%95%E7%94%A8%E6%96%87%E6%9C%AC%20XML%E6%A0%87%E7%AD%BE][可视模式 文本对象 操作括号 被引用文本 XML标签]]  [[操作等待模式下使用文本对象]]
     :SOURCE:     template.js
     :OPERATE:    v | i/a | }">t]        d/y/c | i/a | }">t
     :END:
     - <<文本对象操作括号 被引用文本 XML标签>>
       var tpl = [ '<a href="{url}">{title}</a>' ]
                               ^                     {start}
                              url                    vi}           可视模式 高亮选中 {}内部
                            "{url}"                  a"                    高亮选中 ""字符范围
                     a href="{url}"                  i>                    高亮选中 <>内部
                                   {title}           it                    高亮选中 xml标签内部
                    <a href="{url}">{title}</a>      at                    高亮选中 xml标签范围
                 [ '<a href="{url}">{title}</a>' ]   a]                    高亮选中 []字符范围
     - <<操作等待模式下使用文本对象>>
       var tpl = [ '<a href="{url}">{title}</a>' ]
                               ^                              {start}
                              {url} ->  *#*                     ci"#<Esc>           修改 ""内部 返回普通模式
                                    {title} ->  click here    citclick here<Esc>  修改 xml标签内部 返回普通模式
                                                              yit                 拷贝 xml标签内部
                                                              dit                 删除 xml标签内部
**** 删除周边 修改内部 delete around, or change inside                         :<dc ai wWsp>
     :PROPERTIES:
     :SUMMARY:    [[操作符与文本块文本对象]]
     :SOURCE:     
     :OPERATE:    i/a | w/W/s/p
     :END:
     - <<操作符与文本块文本对象>>
       Improve your writing by deleting excellent adjectives.
                                           ^                      {start}
                                        +excellent_+                daw               删除 单词 包括后面空格 (around the word)
                                                                                    d{motion} 与 aw as ap 配合使用
                                        +execlient+ -> most         ciwmost<Esc>      修改 单词 不包括后面空格 (inside the word)
                                                                                    c{motion} 与 iw is ip 配合使用
**** 设置位置标记 以便快速跳回 mark your place and snap back to it              :m:`:
     :PROPERTIES:
     :SUMMARY:    [[位置标记跳转]]  [[自动位置标记]]
     :SOURCE:     
     :OPERATE:    m{mark} `{mark}    `` `.
     :END:
     - <<位置标记与跳转>>
       m{a-z}            局部标记
       m{A-Z}            全局标记
       `{mark}           跳转
     - <<自动位置标记>>
       ``                   上次跳转之前的位置     [[跳转列表]]
       `.                   上次修改的地方        [[改变列表]]
       `<                   上次高亮选区起始位置   可视模式补充
       `>                   上次高亮选区结束位置   可视模式补充
**** 在匹配括号间跳转 junmp between matching parentheses                        :%:
     :PROPERTIES:
     :SUMMARY:    [[开、闭括号间跳转]]  [[选中文本添加分隔符 修改已有分隔符]]
     :SOURCE:     
     :OPERATE:    %
     :END:
     - <<开、闭括号间跳转>>
       console.log([{'a':1},{'b':2}])
                  ^                       {start}
                                    ^     %           在一组开、闭括号间跳转
                                   ^      h
                   ^                      %
                    ^                     l
                          ^               %
     - <<选中文本添加分隔符 修改已有分隔符>>  [[https://github.com/tpope/vim-surround][Surround.vim]]
       ities = ["London", "Berlin", New York]
                                    ^                 {start}
                                    New York          vee
                                   "New York"         S"
                                   {New York}         cs"}
*** 在文件间跳转 navigate between files with jumps
    :PROPERTIES:
    :SUMMARY:     跳转列表 改变列表
    :SOURCE:      jumps
    :END:
**** 遍历跳转列表 traverse the jump list                                       :<:junmps><C-o><C-i>:
     :PROPERTIES:
     :SUMMARY:    [[操作跳转列表]]  [[跳转动作]]
     :SOURCE:     
     :OPERATE:    :jumps  <C-o>  <C-i>
     :END:      
     - <<操作跳转列表>>
       显示   :jumps
       移动   <C-o>    <C-i>
              后退      前进
     - <<跳转动作>>       每一个动作都将生成跳转列表
       [count]G          指定行号
       %
       ( or )            上一句 / 下一句 开头
       { or }            上一段 / 下一段 开头
       gf                [[源码定位]]
       <C-[>             光标下 关键字 定义处 [[源码定位]]
       `{mark} or '{mark}
**** 遍历改变列表 traverse the change list                                     :<:changes g; g,>:
     :PROPERTIES:
     :SUMMARY:    [[操作改变列表]] 
     :SOURCE:     
     :OPERATE:    :changes  g;  g,
     :END:      
     - <<改变列表>>
       显示    :changes
       移动    g;     g,
              反向    正向
**** 跳转到光标下的文件 jump to the filename under the cursor
     :PROPERTIES:
     :SUMMARY:    
     :SOURCE:     practical_vim.rb
     :OPERATE:    gf
     :END:      
**** 用全局位置标记在文件间快速跳转 snap between files using global marks         :<mM `M>:
     :PROPERTIES:
     :SUMMARY:    [[全局跳转]]
     :SOURCE:     
     :OPERATE:    `{mark}
     :END:      
     - <<全局跳转>>
       `{mark}        全局标记
                      全局跳转

** 寄存器 registers
   :PROPERTIES:
   :SUMMARY:      剪切版 剪切 复制 粘贴 录制宏
   :SOURCE:       
   :END:
*** 复制和粘贴 copy and paste
    :PROPERTIES:
    :SUMMARY:     删除 delete  复制 yank  粘贴 put
    :SOURCE:      copy_and_paste
    :END:
**** 用无名寄存器实现删除 复制 粘贴操作 delete, yank, and put with vim's unnamed register :xp:ddp:yyp:
     :PROPERTIES:
     :SUMMARY:    [[调换字符]] [[调换文本行]] [[创建文本行的副本]]
     :SOURCE:     
     :OPERATE:    
     :END:      
     - <<调换字符>>
       Practica lvim
                   ^     {start}
               ^         F␣  [[字符查找]]
               \/        xp  调换光标上的字符与后一个字符  --   x  剪切当前字符 放到无名寄存器
                                                       \    p  将无名寄存器中的内容粘贴到光标后面
     - <<调换文本行>>
       2) line two                   1) line one  \
       ^             {start}                        ddp 交换当前行与下一行  --  dd  剪切当前行 放入无名寄存器
       1) line one                   2) line two  /                      \    p   无名寄存器的内容粘贴到下一行
     - <<创建文本副本>>
       1) line one        1) line one
       2) line two        2) line two
       ^                  2) line two
                          ^             yyp 复制一个副本到下面一行
**** 深入理解vim寄存器 grok vim's registers                                             :"ayiw:"ap:
      :PROPERTIES:
      :SUMMARY:    [[引用寄存器]] [[vim术语对照表]] [[常用寄存器]]
      :SOURCE:     
      :OPERATE:    
      :END:
      - <<引用寄存器>> addressing a register
        "{[[register name]]} 常用寄存器名
      - <<vim术语对照表>>
        [d]elete -> cut   [y]ank -> copy   [p]ut -> paste
                剪切             复制            粘贴
      - <<常用寄存器>>
        |                         |                   | collection = getCollection();   process(somethingInTheWay, target); |                 |
        | register                | <<register name>> | ^ 1                                     ^ 2 3                       | properties      |
        |-------------------------+-------------------+---------------------------------------------------------------------+-----------------|
        | the unamaed register    | "                 | yiw (collection) -> diw (somthingInTheWay) -> P (somethingInTheWay) | [[defaultRegister]] |
        | the yank register       | 0                 | yiw (collection) -> diw (collection) -> "0P (collection)            | [[copyRegister]]    |
        | the named register      | a-z               | "ayiw (collection) -> diw (collection) -> "aP (collection)          | [[26Registers]]     |
        | the black hole register | _                 | yiw -> "_diw -> P (collection)                                      | [[nonRegister]]     |
        | the system clipboard    | +                 |                                                                     | [[systemClipboard]] |
        | selection register      | *                 |                                                                     | [[systemClipboard]] |
        | the expression register | =                 |                                                                     | [[practise 16]]   |

<<defaultRegister>> 寄存器名默认为空 即 “”p = p  *if we don't specified which register we want to interact with, then vim will use the unnamed register*
<<copyRegister>> 复制专用寄存器 即只寄存和yank相关的操作  *the specified text is copied not only into the unnamed register but also into the yank register*
<<26Registers>> 26个字母对应26个寄存器 可供使用  *wim has one named register for each letter of the alphabet*
<<nonRegister>> 不寄存任何字符  *is a place from which nothing return*
<<systemClipboard>> 系统剪切版  *if we want to copy some text from inside of vim and paste it into an external program (or vice versa)*
**** 用寄存器中的内容替换高亮选区的文本 replace a visual selection with a register :yiw:ve:p:
     :PROPERTIES:
     :SUMMARY:    [[替换文本]]  [[交换文本]]
     :SOURCE:     
     :OPERATE:    
     :END:
     - 图解 unnamed register 和 visual selection
          y{scope1} d{scope1}
                   |
                 scope1
                           \
                                  v{scope2}
                               +v{scope2}+ scope1
                 scope2    /
     - <<替换文本>> using the unnamed register for both the yank and put operations because there is no delete step
       collection = getCollection();               1 yiw    unnamed register get 'collection' string
       ^ 1
       process(somethingintheway, target);
               ^ 2 3                               2 ve     visual mode select 'somethingintheway'
                                                   3 p      'collection' replace 'somethingintheway'
     - <<交换文本>> swap two word
       I like chips and fish
       ^ 1    ^ 2 3 7   ^ 4 5 6                    1 fc     find the first 'c' character backword the cursor
                                                   2 de     delete 'chips' string and bring it to unnamed register
                                                   3 mm     mark the current cursor
                                                   4 ww     locate the begin of the 'fish'
                                                   5 ve
                                                   6 p      replace 'chips' to 'fish' and give 'fish' to unnanmed register
                                                   7 `m     return to the mark place
                                                   8 P
**** 把寄存器的内容粘贴出来 paste from a register                                        :ciw<C-r>0:<yap gp gP>:
     :PROPERTIES:
     :SUMMARY:    [[面向字符]] [[面向行]]
     :SOURCE:     
     :OPERATE:    
     :END:
     - <<面向字符>> pasting character-wise regions
       - ciw<C-r>0<Esc>        always paste text *in front of* the cursor
         ciw                   delete a word then into insert mode
         <C-r>0                use yank register
     - <<面向行>> pasting line-wise regions
       yap               yank line-regions
       gp gP             put the text before or after line
**** 与系统剪切板进行交互 interact with the system clipboard
*** 宏 Macro
    :PROPERTIES:
    :SUMMARY:     针对相似的行 段落 文件 进行重复性的操作  for repeating changes over a set of similar lines paragraph file
    :SOURCE:      copy_and_paste
    :END:
**** 宏的读取与执行 record and execute a macro                                 :q{register}:@{register}:
     :PROPERTIES:
     :SUMMARY:    [[录制]] [[回放]]
     :SOURCE:     
     :OPERATE:    
     :END:      
     - <<录制>> capture a sequence of commands by recording a macro
              foo = 1                  1 qa              开始录制  q{register}  giving the address of register where we want to *save* the macro
        ^ 3 4 ^ 1    ^ 2               2 A;<Esc>         foo = 1;
              bar = 'a'                3 Ivar␣<Esc>      var foo = 1;
              Foobar = foo + bar       4 q               结束录制

       :reg a
       "a A;^[Ivar ^[
     - <<回放>> play back a sequence of commands by executing a macro
            var foo = 1;
             bar = 'a'
               ^ 1                     1 @a              执行宏  @{register}  execute the contents of the specified register
         Foobar = foo + bar
             ^ 2                       2 j@@             重复上次的宏  @@  repeat the macro that was invoked most recently
**** 规范光标位置 直达目标以及中止宏 normalize strike abort                     :100@a:
     :PROPERTIES:
     :SUMMARY:    [[规范光标位置]] [[可重复的命令直达目标]] [[当动作命令失败时 宏将中止]]
     :SOURCE:     
     :OPERATE:    
     :END:      
     - 录制一个宏时 要确保每条命令都可以被重复执行 *when recording a macro  ensure that every command is repeatable*
     - <<规范光标位置>> normalize cursor position
       - 确保光标位置已就位          make sure your cursor is positioned
       - 确定的位置开始执行          always starting on square one make it easier to strike the right target every time
           n        下一处匹配项           next search match
           0        当前行行首         start of the current line
           gg       文件首行          first line of current file
     - <<可重复的命令直达目标>>
       不要一味的敲方向键          <h j k l>     don't just hammer the *arrow key* until your cursor reaches its target
       使用面向单词的动作命令      <w b e ge>     more flexible
       禁止使用鼠标               using the mouse is *verboten*
     - <<当动作命令失败时 宏将中止>> abort when a motion fails
       如果宏动作命令失败 vim将中止宏的其余命令     10@a 100@a 1000@a   *ignore how many times* we execute this macro (result is the same)
**** 加次数回放宏 play back with a count                                       :qq;.q:
     #+Begin_SRC <vim>
       x = "+a+","+b+","+c+","+d+","+e+")";
       ^ 1                                       1 f+
         " + a 2                                 2 s + <Esc>
           " + a+" 3                             3 qq;.q          begin ;. macro
           " + a + " 4                           4 22@q           give all the + with macro ;.
     #+END_SRC
**** 在连续的文本上重复修改 repeat a change on contiguous lines                 :<j 3@a>:<jVG :'<,'>normal @a>:w~:
     :PROPERTIES:
     :SUMMARY:    [[以串行方式执行宏]] [[以并行方式执行宏]]
     :SOURCE:     broken-lines.txt
     :OPERATE:    
     :END:      
                                     <<以串行方式执行宏>>                                   <<以并行方式执行宏>>
                              qa -> 0f. -> r) -> w~ -> j -> q               qa -> 0f.r)w~ -> q -> jVG -> :'<,'>normal @a
     1. one                  |          1          |    2    |             |        1         |            2            |
        ^                       顺序执行 中间一旦出错 停止执行                 宏与宏的调用相互独立 即使其中一个出错 不会影响其他的宏
     2. two                     1                                                1
     3. three                   | 2                                              -->
     4. four                    V                                              / 1
                                1                                           2  - -->
     1) One                     | 2                                            \ 1
     2) Two                     V                                                -->
     3) Three                   1
     4) Four

**** 给宏追加命令 append commands to a macro                                   :<qa qA>:
     :PROPERTIES:
     :SUMMARY:    [[宏的结尾添加命令]]
     :SOURCE:     
     :OPERATE:    
     :END:      
     - <<宏的结尾添加命令>> track commands on at the end of a macro
       qa   ->   q  ->  qA  ->  q
       | 0f.r)w~ |      |   j   |

       :reg a
       | 0f.r)w~ |
       | 0f.r)w~j               |
**** 在一组文件中执行宏 act upon a collection of files                          :<qa :next q 22@a :wall>:<qa q :edit! :argdo normal @a>:
      :PROPERTIES:
      :SUMMARY:    [[并行方式]] [[串行方式]]
      :SOURCE:     ruby_module/animal.rb  rc.vim
      :OPERATE:    
      :END:      
      # ...[end of copyright notice]
      class Animal
      ^ 1
        # implementation
      end

      # ...[end of copyright notice]
      module Rank
      ^ 2
        class Animal
          # implementation...
        end
      ^^ 3
      end
      ^^^ 4
              建立目标文件列表                       宏的录制                        <<并行方式>>                          <<串行方式>>
       build a list of target files        record a unit of work        execute the macro in parallel         execute the macro in series

        :cd code/macros/ruby_module         qa                                :edit! [fn:edit!]                    qa -> :next -> q
              :args ruby.*                  1 *gg* /class<CR> [fn:1]             [fn:argdo副作用]                           22@a
                  :args                     2 *O* module Rank<Esc>         :argdo normal @a [fn:argdo]               :wall [fn:wall]
        (:first :next :prev :last)          3 j>G [fn:3]
                                            4 *Go* end<Esc>
                                            q

[fn:1] gg  移到文档起始位置 place the cursor at the start of file
[fn:3] >G  本行到文件末尾自动缩进 to indent each line up to the end of the file
[fn:edit!] 放弃所有修改 文件未保存 revert all of the changes  if you had always written the changes to a file  just use the *u* command
[fn:argdo副作用] 需要先执行 edit! 取消对第一个缓冲区所做的修改
[fn:argdo] 参数列表内所有缓冲区文件执行一条ex命令 allow us execute an Ex command once for each buffer in argumnet list    <<:argdo>>
[fn:wall] 保存缓冲区列表内所有文件 save all files in the buffer list
**** 用迭代求值的方式给列表编号 evaluate an iterator to number items in a list   :<:let i=1 qa <C-r>=i :let i+=1 q>:
     :PROPERTIES:
     :SUMMARY:    [[带数字的运算]] [[带表达式的运算]] [[带变量循环的运算]]
     :SOURCE:     incremental.txt
     :OPERATE:    
     :END:      
     - target
       partridge in a pear tree
       turtle doves
       French hens
       calling birds
       golden rings
     - change
       1) partridge in a pear tree
       2) turtle doves
       3) French hens
       4) calling birds
       5) golden rings

     - <<带变量循环的运算>>
       1 设定变量i从1到5 录制宏为每行添加编号 第一行为 '1)'
         :let i=1 -> *qa* -> *I<C-r>=i<CR>)* <Esc> -> :let i+=1 -> q
       2 执行宏为剩下的行添加编号
         *jVG* -> :'<'> normal @a
**** 编辑宏的内容 edit the content of a macro                                  :<:put a !@#$% "ay$>:
      :PROPERTIES:
      :SUMMARY:    [[将宏粘贴到文档中]] [[编辑宏]] [[将宏从文档复制回寄存器]]
      :SOURCE:     mixed-lines.txt
      :OPERATE:    
      :END:
                      <<将宏粘贴到文档中>>            <<编辑宏>>                <<将宏从文档复制回寄存器>>
      1. One              1 :put a               2 f~ -> svU<Esc>               3 0 -> "ay$ -> dd
      2. Two              [fn:put]                 [fn:编辑宏]                    [fn:复制回寄存器]
      3. three
      4. four
      0f.r)w~j
      ^ 1 3 ^ 2
[fn:put] 最下方显示put对象 always pastes belows the current line
[fn:编辑宏] 像编辑文本一样编辑宏
[fn:复制回寄存器] 直接删除回寄存器"add 但会增加拖尾字符^J(换行)    先复制回寄存器 再删除更安全"ay$
** pattern 模式
   :PROPERTIES:
   :SUMMARY:      /进入pattern模式 构造正则表达式 研究查找命令 :substitute :global
   :SOURCE:       patterns
   :END:
*** 按模式匹配及按原义匹配 matcing patterns and literals
    :PROPERTIES:
    :SUMMARY:     如何使用very nonlogic原义开关  使用查找模式中特殊元字符
    :END:
**** 调整查找模式大小写敏感 tune the case sensitivity of search patterns       :\c:\C:
     :PROPERTIES:
     :SUMMARY:    [[全局设置]] [[每次查找设置]]
     :SOURCE:     
     :OPERATE:    
     :END:
     - <<全局设置>> setting case sensitivily global
       :set ignorecase
     - <<每次查找设置>> setting case sensitivily per search
       \c 忽略大小写
       \C 强制区分大小写
       can be used anywhere in a pattern
**** 按正则表达式查找时 使用\v模式开关 use the \v pattern swich for regex searches
     :PROPERTIES:
     :SUMMARY:    [[用/\v模拟perl正则表达式]]
     :SOURCE:     color.css
     :OPERATE:    [[三种正则表达式]]
     :END:
     - 构造正则表达式 匹配CSS颜色代码 compose a regular expression that matches each of color codes in this snippet CSS

       body { color: #3c3c3c; }
       a { color: #0000EE; }
       strong { color: #000; }

       - <<三种正则表达式>>

         *bad*       magic search
                   /#\([0-9a-fA-F]\{6}\|[0-9a-fA-F]\{3}\)      必须转义 ( ) | {
                                                               escape ( ) | { character to confer special meaning upon them

         *better*    very magic search
                   \v#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})          \v模式开启后 ( ) | { 表现出特殊含义 <<用/\v模拟perl正则表达式>>
                                                               using \v pettern switch  the  ( ) | { character assume special meaning

         *best*      use hex character with very magic
                   \v#(\x{6}|\x{3})                            用\x字符类代替[0-9a-fA-F]
                                                               compact expression further by using \x character class
**** 按原义查找文本时 使用\V原义开关 use the \V literal switch for verbatim searches
     :PROPERTIES:
     :SUMMARY:    [[使用\V屏蔽特殊字符]]
     :SOURCE:     excerpt-also-known-as.txt
     :OPERATE:    [[屏蔽查找模式特殊字符]]
     :END:
     - 按照原义匹配 a.k.a.
       The N key searches backward...
       ...the \v pattern switch (a.k.a. very magic search)...

       - <<屏蔽查找模式特殊字符>>
         /\Va.k.a.     <<使用\V屏蔽特殊字符>>
         /a\.k\.a\.    转义特殊字符
                       cancel out the special meaning of . character by escapting it
**** 使用圆括号捕获子匹配 use parentheses capture submatches
     :PROPERTIES:
     :SUMMARY:    [[使用()和\1两次匹配相同的单词]]
     :SOURCE:     springtime.txt
     :OPERATE:    [[匹配重复单词的正则表达式]]
     :END:
     - 匹配重复字符 the the
       I love Paris in the
       the springtime.

       - <<匹配重复单词的正则表达式>>
         /\v<(\w+)\_s+\1>
         - (w+)\_s+\1  <<使用()和\1两次匹配相同的单词)>>
                      the trick to matching the same word twice lies in the combination of () and \1
           ()         括号内部的匹配文本自动保存到一个临时的仓库
                      Anything that matches inside of parentheses is automatically assigned to a temporary silo
           w          单词匹配
           _s        匹配空白符或换行符
                      matches whitespace or a line break
           \1         捕获括号内文本 (第二个括号用\2 以此类推)  <<子匹配调用>>
                      reference the captured text as \1
         - <>         [[技巧76]]
**** 界定单词的边界 stake the boundaries of a word                             :<>:[[%]]:
      :PROPERTIES:
      :SUMMARY:    [[在\v模式下 使用<>表示单词定界符]]
      :SOURCE:     springtime.txt
      :OPERATE:    [[匹配the单词的几种方式]]
      :END:
      - 明确匹配'the'这个单词 而不是其他词的某个组成部分 match 'the' as a word rather than a fragment
        the problem with these new recruits is that
        they don't keep their boots clean.

        - <<匹配the单词的几种方式>>

          精确匹配
            /\v    <    the    >     <CR>                搜索the单词
                                                         <<在\v模式下 使用<>表示单词定界符>> <<技巧76>>
            /\v \W\zs\w the \w\ze\W  <CR>                使用 单词符(\w \W) 匹配定界符(\zs \ze)  模拟<>
                                                         [fn:单词符_匹配定界符]

          模糊匹配
            /the<CR>         搜索包含the单词

      - 使用圆括号 但不捕获其内容 (<<%>>)
        /\v%(And|D)rew Neil

        /\v(%(And|D)rew) (Neil)
        :%s//\2, \1/g

[fn:单词符_匹配定界符] \w 匹配单词类字符 包括字母、数字以及符号'_'
                     \W 匹配单词类字符以外的其他字符
                     \ze \zs [[技巧77]]
**** 界定匹配的边界 stake the boundaries of a match
     :PROPERTIES:
     :SUMMARY:    [[同时使用\zs和\ze对匹配的起始和末尾进行微调]]
     :SOURCE:     
     :OPERATE:    
     :END:
     - 对双引号内匹配的文本进行微调
       Match "quoted words" ---not quote marks.

             "quoted words"                       /\v"[^"]+"<CR>
                                                     "[^"]+"              对双引号内容进行匹配(包括双引号)
              quoted words                        /\v"\zs[^"]+\ze"<CR>    <<同时使用\zs和\ze对匹配的起始和末尾进行微调>> <<技巧77>>
                                                                          use \zs and \ze items to crop the match  makeing it a subset of entire pattern
**** 转义问题字符 escap problem character
      :PROPERTIES:
      :SUMMARY:    [[手动转义查找域结束符]] [[调用=表达式escape函数自动转义]]
      :SOURCE:     
      :OPERATE:    [[将URL复制到寄存器]] -> [[编辑查找域]] -> [[转义URL结束符]]
      :END:
      - 将 http://vimdoc.net/search?q=/\\ 粘贴到寄存器u 并在文本进行查找

        Search items: [http://vimdoc.net/search?q=/\\][s]
        ...
        [s]: http://vimdoc.net/search?q=/\\

        - <<将URL复制到寄存器>>
          - "uyi[
            "u        调用u寄存器
            yi[       yank insert []
        - <<编辑查找域>>
          - 手动转义
            /\V<C-r>u<CR>    粘贴至查找域
          - 调用函数
            /\V<C-r>=<CR>    使用=表达式
        - <<转义URL结束符>>
          - <<手动转义查找域结束符>>
            - 手动转义
              - 屏蔽正向查找域结束符/  escape / character when searching forward
                ->/\Vhttp://vimdoc.net/search?q=/\\
              - 屏蔽反向查找域结束符?  escape ? character when searching backword
                ->/\V?http://vimdoc.net/search\?q=/\\
              - 无论正向反向都要屏蔽的字符\  escape \ every time
                ->/\Vhttp:\/\/vimdoc.net\/search?q=\/\\\\
            - <<调用=表达式escape函数自动转义>>  escap character programmatically
              escape({string}, {chars})  自动转义指定寄存器内容
                     =escape(@u, getcmdtype().'\')          [fn:自判断函数]
                              正反向自判断
                         /                   \
              =escape(@u, '/\')           =escape(@u,'?\')
                   正向搜索                    反向搜索

                                   正向搜索返回      反向搜索返回
[fn:自判断函数] getcmdtype().'\'       '/\'             '?\'        其中.操作符用来连接字符串

*** 查找 search
    :PROPERTIES:
    :SUMMARY:     怎样查找 如何高亮匹配 各个匹配之间的跳转
                  vim增量查找功能 查找偏移功能
                  简单的定制命令 查找当前高亮选区文本
    :SOURCE:      search
    :END:
**** 结识查找命令 meet the search command                                      :</?>:<nN>:<gn gN>:
     :PROPERTIES:
     :SUMMARY:    [[执行查找]] [[查找方向]] [[重复查找]] [[回溯查找]]
     :SOURCE:     
     :OPERATE:    
     :END:
     - <<执行查找>>
       /
       <CR>
       <Esc>
     - <<查找方向>>
       /
       ?
     - <<重复查找>>
       n        N
       /<CR>    ?<CR>
       [[gn]]       gN
     - <<回溯查找>>
       <up>
**** 高亮查找匹配 highlight search matches
**** 匹配的增量功能 preview the first match before execution
     :PROPERTIES:
     :SUMMARY:    [[即时匹配]] [[即时预览]] [[自动补全]]
     :SOURCE:     
     :OPERATE:    
     :END:
     - The car was the color of a carrot.
       (1) car
                              (2) carrot
       (3) ^                  (4) ^

       (1) /car -> (2) /carr -> (3) /carr<CR>         <<即时匹配>>
                             -> (4) /carr<Esc>        <<即时预览>>
                             -> (5) /carr<C-r><C-w>   <<自动补全>>
**** 将光标偏移到查找匹配的结尾 offset the cursor to the end of search match   :/lang/e:
     :PROPERTIES:
     :SUMMARY:    [[前置查找偏移]] [[后置查找偏移]]
     :SOURCE:     langs.txt
     :OPERATE:    [[查找模式字符匹配 n字符跳转 .范式字符操作]]
     :END:
     - 替换 lang 为 language
       Aim to learn a new programming lang each year.
                                  (1) lang^
                                  (2) language^
       Which lang did you pick up last year?
         (1) lang
         (3) lang^
         (4) language^
       Which lang did you pick up last year?
         (1) lang
         (5) languages

       - <<查找模式字符匹配 n字符跳转 .范式字符操作>>
              */lang/e<CR> ->*        <<前置查找偏移>>
                    (1)         \
                                          *a uage<CR> -> n -> . -> n.*
                                              (2)      (3)  (4)  (5)
                    (1)         /
         */lang/<CR> -> //e<CR> ->*    <<后置查找偏移>>
**** 对完整的查找匹配进行操作 operate on a complete search match
      :PROPERTIES:
      :SUMMARY:    [[构造一个指定匹配的正则表达式]] [[转换需要转换的字符为大写]]
      :SOURCE:     tag-heirarchy.rb
      :OPERATE:    [[查找模式下正则表达式匹配字符操作]]
      :END:
      - 指定字符 转换大写
        class XhtmlDocument < XmlDocument; end
          (1)^Xhtml       (1) Xml
        class XhtmlTag < XmlTag; end
          (1) Xhtml  (1) Xml

        class XHTMLDocument < XMLDocument; end
          (2)^XHTML       (3)^XML
        class XHTMLTag < XMLTag; end
          (4)^XHTML
        - <<查找模式下正则表达式匹配字符操作>>
          (1) /\vX(ht)?ml\C<CR>                              <<构造一个指定匹配的正则表达式>>
          (2) gUgn  (3) .  (4) .                             <<转换需要转换的字符为大写>> [fn:gn]

[fn:gn] <<gn>>  把光标移到下一匹配处(或者在当前光标匹配处) 运行动作命令    集 操作命令 和 移动命令 于一身的 .范式
                operates on the next match (or current cursor) and applies the last operation, I call this the Improved Dot Formula.
**** 利用查找历史 迭代完成复杂的模式 create complex patterns by iterating upon search history
      :PROPERTIES:
      :SUMMARY:    [[回溯查找历史]]
      :SOURCE:     quoted-strings.txt
      :OPERATE:    [[替换所有的'为“]]
      :END:
      - 替换 ' -> "
        This string contains a 'quoted' word.
                          (ac) 'quoted'
                      (<<b1>>)  quoted'
        This string contains 'two' quoted 'words.'
                    (<<a2>>) 'two' quoted 'words.'
                        (bc) 'two'        'words.'
        This 'string doesn't make things easy.'
        (ab) 'string doesn't make things easy.'
        (c)

        This string contains a “quoted” word.
        This string contains “two” quoted “words.”
        This “string doesn't make things easy.”

        - <<替换所有的'为“>>
          - :%s/\v'(([^']|'\w)+)'/“\1”/g    最终形态
            ^
          - :%s//“\1”/g                     把匹配的内容从寄存器1中取出 进行替换
                  \1                        <<an effective workflow for building regular expressions>>
                   ^
          - /\v'(([^']|'\w)+)'              把匹配的内容保存在寄存器1中
                (([^']|'\w)+)
                (           )
            ^
          - /\v'([^']|'\w)+'                把撇号的情况包含进来
                ([^']|'\w)
                 [^']
                     |
                      '\w
            ^
          - /\v'[^']+'                      第一行第一个'被当做撇号处理([[b1]]) [fn:撇号]
                [^']                        除了'之外的其他字符
            ^
          - /\v'.+'                         在第二行进行了贪婪匹配 quoted 被多余匹配([[a2]])
            .                               匹配一个或多个字符
        - <<回溯查找历史>>
          /<UP>                 prefill the search field with our pattern
          q/                    summon the command-line window  [fn:example]
[fn:撇号]     示例 won't don't
[fn:example] /\v'[^']+'
             v                   f[ -> c%(<C-r>")<Esc> -> i|\w<Esc>
             /\v'([^']|'\w)+'          c%        delete the +[^']+
                                       c         delete
                                       %         move A to B  [^']
                                                              A  B
                                       <C-r>"    yank the [^']
                                       <C-r>     insert the register text
                                       "         the delete and yank register
**** 统计当前的匹配个数 count the matches for the current pattern
     :PROPERTIES:
     :SUMMARY:    [[:substitude command]]   [[:vimgrep command]]
     :SOURCE:     buttons.js
     :OPERATE:    [[use 2 method to match every button]]
     :END:
     - match every button

       var buttons = viewport.buttons;
       viewport.buttons.previous.show();
       viewport.buttons.next.show();
       viewport.buttons.index.hide();

       - <<use 2 method to match every button>>
         /\<buttons\>                    match every single word of 'button'
         - 1. <<:substitude command>>    lets us know the *total number* of matches for a pattern
           - :%s///gn                    /5 matches on 4 lines/
                //                       delimit the pattern field
                 //                      delimit the replace field
         - 2. <<:vimgrep command>>       populates the *quickfix* list with each match found in the current buffer
           - :vimgrep //g %              /(1 of 5) var buttons = viewport.buttons;/
                                         expands to the filepath of the current buffer
           :cnext                        /(2 of 5) var buttons = viewport.buttons;/
           :cprev                        /(2 of 5) var buttons = viewport.buttons;/
     :%s///gn
**** 查找高亮选区中的文本 search for the current visual selection
      :PROPERTIES:
      :SUMMARY:    [[the * command in visual mode]] [[visual-star]]
      :SOURCE:     visual-star.vim
      :OPERATE:    [[Search for the Current Selection]]
      :END:
      - match 'sea' in visual selection

        She sells sea shells by the sea shore.
        She sells sea^
        She sells sea shells by the s^        *  <<the * command in visual mode>>

        - <<Search for the Current Selection>>
          :vmap X y/<C-R>"<CR>      [fn:note]
                  y                 yank the current visual selection
                   /<C-r>"<CR>      bring up the search prompt, paste the contents of default register and execute the search

          - <<visual-star>>
            * 命令原有功能被覆盖 #命令被重新定义为反向查找文本 overriding the * command, customized the # command
            - paste this into your vimrc file directly or install the visual star search plugin  [fn:install]    <<use * command in visual mode for pattern searching>>
              xnoremap * :<C-u>call <SID>VSetSearch('/')<CR>/<C-R>=@/<CR><CR> xnoremap # :<C-u>call <SID>VSetSearch('?')<CR>?<C-R>=@/<CR><CR>
              function! s:VSetSearch(cmdtype)
              let temp = @s
              norm! gv"sy
              let @/ = '\V' . substitute(escape(@s, a:cmdtype.'\'), '\n', '\\n', 'g') let @s = temp
              endfunction

[fn:note] Note that special characters (like “.” and “*”) will cause problems.
[fn:install] https://github.com/nelstrom/vim-visual-star-search
*** 替换 substitution
    :PROPERTIES:
    :SUMMARY:      substitude 命令从简单到复杂
    :SOURCE:       substitution
    :END:
**** 结识 substitude 命令
     :PROPERTIES:
     :SUMMARY:    [[语法]] [[替换域特殊字符]]
     :SOURCE:     
     :OPERATE:    
     :END:
     - <<语法>>  syntax
       :[[[range]]]s[ubstitute]/{pattern}/{string}/[[[flags]]]

       - <<flags>>  Tweak the Substitute Command Using Flags
         g  [[全局]]  makes the substitute command act globally
         c  [[确认修改]]  gives us the opportunity to confirm or reject each change
         n  [[显示修改数]]  suppresses the usual substitute behavior, causing the command to report the number of command matches
         e  [[屏蔽无匹配错误]]  silence these errors that using a pattern that has no matches in the current file
         &  [[重用上次标志位]]  reuse the same flags from the previous substitute command.

     - <<替换域特殊字符>>  Special Characters for the Replacement String

       |----------------+----------------------------------------------------------------------+-----------------------|
       | \r             | Insert a carriage return                                             |                       |
       | \t             | insert a tab character                                               |                       |
       | \\             | Insert a single backslash                                            |                       |
       | \1             | Insert the first submatch                                            | [[\1 \2 in use]]          |
       | \2             | Insert the second submatch (and so on, up to \9)                     |                       |
       | \0             | Insert the entire matched pattern                                    |                       |
       | &              | Insert the entire matched pattern                                    |                       |
       | ~              | Use {string} from the previous invocation of :substitute             | [[how the ~ taken works]] |
       | \={Vim script} | Evaluate {Vim script} expression; use result as replacement {string} | [[example of usage]]      |
**** 在文件范围内查找并替换每一处匹配 find and replace every matches in a file
     :PROPERTIES:
     :SUMMARY:    [[文件二维平面]]  [[flags g]]
     :SOURCE:     get-rolling.txt
     :OPERATE:    
     :END:
     - 将所有单词 going 替换为 roling
       When the going gets tough, the tough get going.
            (1) rolling                     (2) rolling
       If you are going through hell, keep going.
              (3) rolling              (4) rolling
       - <<文件二维平面>>
         think of a file as a two-dimensional board made up of characters along the x-axis and lines down the y-axis

         [[o]]         [[x]]
            ------------ >
           |
         [[y]] |    file
           |
           v
                           [[x+y]]

         <<o>>    original      :s/going/rolling     (1)
         <<x>>    <<flags g>>   :s/going/rolling/g   (1)(2)  <<全局>>
         <<y>>    range %       :%s/going/rolling    (1)(3)
         <<x+y>>  g + %         :%s/going/rolling/g  (1)(2)(3)(4)
**** 手动控制每一次替换操作 Eyeball Each Substitution
     :PROPERTIES:
     :SUMMARY:    [[观察每一处匹配 再决定是否进行替换]] [[替换-确认模式和点范式]]
     :SOURCE:     
     :OPERATE:    
     :END:
     - 替换所有的 content 为 copy
       ...We're waiting for content before the site can go live...
       ...If you are content with this, let's go ahead with it...
       ...We'll launch as soon as we have the content...

     - <<观察每一处匹配 再决定是否进行替换>>
         :%s/content/copy/gc             <<确认修改>>

         - 所有回复选项
           | trigger | effect                                          |
           |---------+-------------------------------------------------|
           | y       | Substitute this match                           |
           | n       | skip this match                                 |
           | q       | Quit substituting                               |
           | l       | “last”—Substitute this match, then quit         |
           | a       | “all”—Substitute this and any remaining matches |
           | <C-e>   | scroll the screen up                            |
           | <C-y>   | scroll the screen down                          |

     - <<替换-确认模式和点范式>>
         <<替换-确认模式>>    最少的键盘操作完成任务    allows us to complete the task with a minimum of keystrokes
         [[点范式]]              自始至终都在普通模式下    we’re in plain old Normal mode throughout. Everything works just as we expect it to.
**** 重用上次的查找模式 reuse the last match pattern
     :PROPERTIES:
     :SUMMARY:    [[查找域留空]]  [[历史记录调取]]
     :SOURCE:     
     :OPERATE:    
     :END:
     - <<查找域留空>>
       substitution 命令包含两个步骤 The substitute command involves two steps:
         (1) 撰写查找模式 composing a pattern
         (2) 设计合适的替换字符 devising a suitable replacement string

        :[range]s[ubstitute]/{pattern}/{string}/[flags]
                             {pattern}                  (1)  [[use * command in visual mode for pattern searching]]
                                 v                           [[an effective workflow for building regular expressions]]
        :[range]s[ubstitute]/         /{string}/[flags] (2)

       - <<历史记录调取>>
         将查找任务与替换任务分离 会致使两组信息被单独存放 历史记录无法正确调用
         Decoupling the search and replacement tasks causes the two pieces of information to be placed in separate silos

         创建一项完整的记录
         :%s/<C-r>//“\1”/g
             <C-r>/          将 查找域的上次历史记录 传值到 当前替换域中  <<another example>>
**** 用寄存器的内容替换 replace with the contents of a register
     :PROPERTIES:
     :SUMMARY:    [[引用寄存器内容]]
     :SOURCE:     
     :OPERATE:    
     :END:
     - 把替换字符串复制到寄存器  用传值引用的方式将寄存器的内容应用至替换域
       - 传值 pass by value
         :%s//<C-r>0/g          [[another example]]
              <C-r>0            在执行substitute命令之前 对查找域的内容进行一番检查并存储在寄存器0中
                                但会出现 寄存器0中的特殊含义字符无法进行转义 多行文本显示不全等问题
                                examine the contents of register before we execute the substitute command.
                                but can't edit the special meaning within the replacement field and a multiline excerpt of text might not fit on the command line

       - 引用 pass by reference
         :%s//\=@0/g
              \=@0              动态替换模式   [[动态替换与静态替换的区别]]

     - <<动态替换与静态替换的区别>>
       - 静态替换  历史记录一目了然 直接调用执行
         :%s/Pragmatic Vim/Practical Vim/g
       - 动态替换  执行结果随着 /查找域 和 a寄存器 的改变而改变
         :let @/='Pragmatic Vim'
         :let @a='Practical Vim'
         :%s//\=@a/g
**** 重复上一次substitute 命令
     :PROPERTIES:
     :SUMMARY:    [[g&]] [[&&]]
     :SOURCE:     mixin.js
     :OPERATE:    
     :END:
     - 扩展替换模式到整个文件
       (1) :s/target/replacement/g    ->                       <<g&>>    =    :%s//~/&    =    <<:%&&>>
                                                                     重复(1)命令 作用范围扩展到全文件
                                            (repeat last substitute with last search pattern on all lines with the same flags)

     - 扩展文本
       (1)
       mixin = {
           applyName: function(config) {
          ^
               return Factory(config, this.getName());
           },
       }

       (2)
       mixin = {
          applyNumber: function(config) {
               return Factory(config, this.getNumber());
          },
          applyNumber: function(config) {
               return Factory(config, this.getNumber());
          },
       }

       (3)
       mixin = {
           applyName: function(config) {
               return Factory(config, this.getName());
           },
           applyNumber: function(config) {
               return Factory(config, this.getNumber());
           },
       }

       (2) Vjj -> yP -> :%s/Name/Number/g
       (3) u -> gv -> :'<,'>&&
                gv                         [[重选上一次高亮选取]]
                      :'<,'>&&             在当前高亮选区范围内 重复上次替换操作 ([[:%&&]] 作用于整个文件 )
                       '<,'>               当前高亮选区 (可视模式进入命令行模式自动填充)
                            &              :& 组成部分 重复上一次 :substitute 命令
                             &             重用上一次 :s 的标志位  <<重用上次标志位>>
**** 使用子匹配重排CSV字段 Rearrange CSV Fields Using Submatches
     :PROPERTIES:
     :SUMMARY:    
     :SOURCE:     subscribers.csv
     :OPERATE:    [[利用查找域子匹配 重排字段]]
     :END:
     - 修改字段排列顺序
       last name,first name,email
       neil,drew,drew@vimcasts.org
       doe,john,john@example.com

       email,first name,last name
       drew@vimcasts.org,drew,neil
       john@example.com,john,doe

       - <<利用查找域子匹配 重排字段>>
         /\v^([^,]*),([^,]*),([^,]*)$
                \1      \2      \3      [[子匹配调用]]
             ([^,]*),                   匹配0次或多次连续的非逗号字符
                      v
                  :%s//\3,\2,\1
**** 在替换过程中执行算术运算 Perform Arithmetic on the Replacement
     :PROPERTIES:
     :SUMMARY:    [[匹配<h或<h/之后的数字]]  [[submatch函数执行算术运算]]
     :SOURCE:     subscribers.csv
     :OPERATE:    
     :END:
     - 提升每一处标题的层级
       <h2>Heading number 1</h2>
       <h3>Number 2 heading</h3>
       <h4>Another heading</h4>

       <h1>Heading number 1</h1>
       <h2>Number 2 heading</h2>
       <h3>Another heading</h3>

       - <<匹配<h或</h之后的数字>>
         */\v\<\/?h\zs\d*
            \<\/?                 < or </
                 h\zs\d           匹配紧随h后的任意数字(例 h1 1)
                  \zs             [[技巧77]]
            v
       - <<submatch函数执行算术运算>>
         :%s//\=submatch(0)-1/g
         submatch(0)       获得当前匹配内容  <<submatch函数>>

**** 交换两个或更多的单词 swap one or more words
      :PROPERTIES:
      :SUMMARY:    [[定义数据字典]]
      :SOURCE:     who-bites.txt
      :OPERATE:    [[substitute命令]] [[超级substitute命令]]
      :END:
      - 交换 man 和 dog
        The dog bit the man.

        - <<substitute命令>>
          查找
          /\v(<man>|<dog>)
             (           )    捕获匹配文本
              <man>|<dog>     匹配整个单词 man 或 dog

          替换
          :%s//\={"dog":"man","man":"dog"}[submatch(1)]/g
             /
               \=                                           调用vim脚本表达式
                 {"dog":"man","man":"dog"}                  <<定义数据字典>> [fn:example_dictionary]
                                          [submatch(1)]     [[submatch函数]]
        - <<超级substitute命令>>
          :%S/{man,dog}/{dog,man}/g

[fn:example_dictionary] :let swapper={"dog":"man","man":"dog"}
                        :echo swapper["dog"]
                        -> man
                        :echo swapper["man"]
                        -> dog
**** 多个文件中执行查找 Find and Replace Across Multiple Files                  :copen:cfdo:vimgrep:
     :PROPERTIES:
     :SUMMARY:    
     :SOURCE:     refactor-project/
     :OPERATE:    [[sustitute one file]]  [[search mutiple files]]  [[sustitute mutiple files]]
     :END:
     - 修改 Pragmatic Vim 为 Practical Vim    同时保持 Pragmatic Bookshelf不变
       refactor-project/
         about.txt
         Pragmatic Vim is a hands-on guide to working with Vim.

         credits.txt
         Pragmatic Vim is written by Drew Neil.

         license.txt
         The Pragmatic Bookshelf holds the copyright for this book.

         extra/
           praise.txt
           What people are saying about Pragmatic Vim...

           titles.txt
           Other titles from the Pragmatic Bookshelf...


       - <<substitude one file>>
         /Pragmatic\ze Vim                 (1)
                   \ze                     [[技巧77]]
            v
         :%s//Practical/g
       - <<search mutiple files>>
         (1)
         :vimgrep // **/*.txt              (2)
          [[vimgrep]]
                     **/*.txt              to tell vimgrep to look inside all files in current directory that use .txt extension
       - <<substitute mutiple files>>
         $ vim path/to/refactor-project/   open a *nerd tree* for 'refactor-project' folder

         *:copen*                            quickfix appearance
         (1)(2)                            add search txt file in quickfix, you can browse the content by click the file name

         :set hidden                       This setting enables us to navigate away from a modified file without first saving it.
         :cfdo %s//Practical/g | update
         :cfdo                             run the substitute command on every file that appears in the quickfix list.
                               |           combine   :cfdo %s//Practical/gc   and   :cfdo update
                                 update    saves the file, but only if it has been changed
*** Global 命令
    :PROPERTIES:
    :SUMMARY:      在 指定模式 所有匹配行上 运行 ex命令  runs an Ex command on each line that matches a specified pattern
    :SOURCE:       global
    :END:
**** 结识 global 命令
     :PROPERTIES:
     :SUMMARY:    [[语法]]
     :SOURCE:     
     :OPERATE:    
     :END:
     - <<语法>>
       *:[range]global[!]/{pattern}/[cmd]*    [fn:grep]
        [range]                             default range for the :global command is the entire file (%)
                         {pattern}          leave it blank and Vim will automatically use the *current search pattern*
                                   [cmd]    The [cmd] could be any Ex command except for another :global command, default use :print
               global!                      [[:vglobal]]
**** 删除所有包含模式的文本行 Delete Lines Containing a Pattern
      :PROPERTIES:
      :SUMMARY:    [[用 g/re/d 删除所有匹配行]]  [[用 v/re/d 只保留匹配行]]
      :SOURCE:     episodes.html
      :OPERATE:    [[:global和:delete组合使用]]
      :END:
      - 利用 global 命令  分别取出  主题标题 以及 URL
        <ol>
          <li>
            <a href="/episodes/show-invisibles/">
              Show invisibles
            </a>
          </li>
          <li>
            <a href="/episodes/tabs-and-spaces/">
              Tabs and Spaces
            </a>
          </li>
          <li>
            <a href="/episodes/whitespace-preferences-and-filetypes/">
              Whitespace preferences and filetypes
            </a>
          </li>
        </ol>

        (2)
        Show invisibles
        Tabs and Spaces
        Whitespace preferences and filetypes

        (3)
        <a href="/episodes/show-invisibles/">
        <a href="/episodes/tabs-and-spaces/">
        <a href="/episodes/whitespace-preferences-and-filetypes/">

        - <<:global和:delete组合使用>>
          - <<用 g/re/d 删除所有匹配行>> (2)
            */\v\<\/?\w+>*
               \<                       match <
                 \/?                    match / (option)
                    \w+                 match one or more word characters
                       >                match >
              v
            :g//d                       delete the global match line [fn:grep]
          - <<用 v/re/d 只保留匹配行>> (3)
            :v/href/d
            :v                          it executes a command on each line that does not match the specified pattern <<:vglobal>>

[fn:grep] :g/re/p
           g         global command
             re      regular expression
                p    print
**** 将todo项收集至寄存器 Collect TODO Items in a Register                      :global:args:argdo:
     :PROPERTIES:
     :SUMMARY:    
     :SOURCE:     markdown.js
     :OPERATE:    [[组合:global和:yank]]
     :END:
     - 收集TODO信息
       Markdown.dialects.Gruber = {
         lists: function() {
           // TODO: Cache this regexp for certain depths.
           function regex_for_depth(depth) { /* implementation */ }
         },
         "`":function inlineCode( text ) {
               var m = text.match( /(`+)(([\s\S]*?)\1)/ );
               if ( m && m[2] )
                 return [ m[1].length + m[2].length ];
               else {
                 // TODO: No matching end code found - warn!
                 return [ 1, "`" ];
               }
             }
       }

       (1)
       // TODO: Cache this regexp for certain depths.
       // TODO: No matching end code found - warn!

       (2)
       --- Registers ---
       "a

       (3)
       "a // TODO: Cache this regexp for certain depths.
          // TODO: No matching end code found - warn!

       - :g/TODO (1)
         - :g/TODO/yank A (3) <<组合:global和:yank>>
            g                 :global
                   yank       :yank
                        A     将:global命令复制的内容 A 附加到 寄存器a 中
                                                    a 覆盖  寄存器a 内容
         - :argdo g/TODO/yanl A    收集一组文件所有TODO项
         - :g/TODO/t$ (3)
                   t$         [[:t]]
       - :reg a (2)
**** 将CSS文件中所有规则的属性按字母排序 Alphabetize the Properties of Each Rule in a CSS File
     :PROPERTIES:
     :SUMMARY:    [[Sort Properties for a Single Block of Rules]]  [[Sort Properties for Every Block of Rules]]
     :SOURCE:     unsorted.css
     :OPERATE:    [[组合:global和:yank]]
     :END:
     - 每一组规则内的属性 按照字母顺序排序
       (1)
       html {
         margin: 0;
         padding: 0;
         border: 0;
         font-size: 100%;
         font: inherit;
         vertical-align: baseline;
       }
       body{
         line-height: 1.5;
         color: black;
         background: white;
       }

       (2)
       html {
         border: 0;
         font-size: 100%;
         font: inherit;
         margin: 0;
         padding: 0;
         vertical-align: baseline;
       }

       (3)
       html {
         border: 0;
         font-size: 100%;
         font: inherit;
         margin: 0;
         padding: 0;
         vertical-align: baseline;
       }
       body {
         background: white;
         color: black;
         line-height: 1.5;
       }

       - <<Sort Properties for a Single Block of Rules>> (1)(2)
         vi{ -> :'<,'>sort
       - <<Sort Properties for Every Block of Rules>> (1)(3)
         :g/{/ .+1,/}/-1 sort
          g                         global 命令           范围扩展至整个文件
           */{/     /}/*              pattern 查找匹配       查找匹配字符{ 或 }
           */{/ .+1*                  ex 命令                当前行直到匹配到}字符为止
** 工具
   :PROPERTIES:
   :SUMMARY:      工具箱 外部协同工具  调用 make grep 外部程序  拼写检查自动补全和:vimgrep
   :SOURCE:       
   :END:
*** 通过 ctags 建立索引 并用其浏览源代码  Index and Navigate Source Code with ctags
    :PROPERTIES:
    :SUMMARY:      通过扫描代码库 生成关键字的索引
    :SOURCE:       ctags
    :END:
**** 结识 ctags
     :PROPERTIES:
     :SUMMARY:    [[标签文件]] [[关键字]]
     :SOURCE:     unsorted.css
     :OPERATE:    [[组合:global和:yank]]
     :END:
     - <<标签文件>>
       $ cd code/ctags
       $ ctags *.rb
       $ ls
         anglophone.rb francophone.rb speaker.rb [[ctags]]

       - <<ctags>>
         !_TAG_FILE_FORMAT      2       /extended format/
         ... metadata
         Anglophone      anglophone.rb   /^class Anglophone < Speaker$/;"        c
         ...keyword        filename                                          flags
           <<关键字>>
**** 配置vim使用ctags  Configure Vim to Work with ctags
     :PROPERTIES:
     :SUMMARY:    [[手动执行]] [[自动执行]] [[回调执行]]
     :SOURCE:     
     :OPERATE:    
     :END:
     - 查看 缺省标签文件 目录
       :set tags?
     - <<手动执行>>    最简单 定期更新索引
       :!ctags -R     更新当前文件夹索引
       :nnoremap <f5> :!ctags -R<CR>    设置快捷键F5
     - <<自动执行>>    保证了标签文件处于最新状态 只适用于规模较小的项目
       :autocmd BufWritePost * call system("ctags -R")    每次保存文件时自动调用ctags
     - <<回调执行>>    每当提交代码时 自动更新代码库 兼顾了以上两种方法的优缺点 [[http://tbaggery.com/2011/08/08/effortless-ctags-with-git.html][链接]]
**** 使用vim的标签跳转命令 来浏览关键字的定义
     :PROPERTIES:
     :SUMMARY:    [[普通模式]]  [[ex命令]]
     :SOURCE:     
     :OPERATE:    
     :END:
     - 跳转到关键字的定义处
       require './speaker.rb'

       class Anglophone < Speaker
       ^ (1)              ^ (2)
         def speak
           puts "Hello, my name is #{@name}"
         end
       end

       class Speaker
       ^ (3)
         def initialize(name)
              @name = name
            end
            def speak
              puts "#{name}"
         end
       end

       Anglophone.new('Jack').speak
       ^ (4)

       (5)
       # pri kind tag
       1 F C c    Anglophone        anglophone.rb
                       class Anglophone < Speaker
       2 F   c    Francophone       francophone.rb
                       class Francophone < Speaker
       Type number and <Enter> (empty cancels): (6)


       <<a>>    Jump to the *first tag that matches* the word under the cursor
                (4) -> (1)    (2) -> (3)

       <<b>>    acts as the *back button* for our tag history
                (1) -> (4)    (3) -> (2)

       <<c>>    Prompt user to select from *multiple matches* for the word under the cursor.
                If only one match exists, jump to it without prompting.
                (5)

       <<d>>    operate mutiple matches
                (6)
     - <<普通模式>>
       <C-]>        [[a]]
       <C-t>        [[b]]
       g<C-]>       [[c]]
     - <<ex命令>>
       :tag {keyword} <tab>            [[a]]
       :tjump {keyword} <tab>          [[c]]
       :pop                            [[b]]
       :tnext :tprev :tfirst :tlast    [[d]]
       :tselect                        [[c]]
*** 编译代码 并通过quickfix浏览错误信息 Compile Code and Navigate Errors with the Quickfix List
    :PROPERTIES:
    :SUMMARY:      :make命令通过对编译器的错误信息进行解析 生成quickfix列表浏览
    :SOURCE:       quickfix
    :END:
**** 不离开vim也能编译代码 Compile Code Without Leaving Vim
     :PROPERTIES:
     :SUMMARY:    [[在shell中编译]]  [[在vim中编译]]
     :SOURCE:     
     :OPERATE:    
     :END:
     - <<在shell中编译>>
       $ cd code/quickfix/wakeup
       $ make
     - <<在vim中编译>>
       $ cd code/quickfix/wakeup
       $ pwd; ls
       $ vim -u NONE -N wakeup.c
       :make                        error
         :cnext                     amend
         :write                     save
         :make                      correct
**** 浏览quickfix列表 Browse the Quickfix List
     :PROPERTIES:
     :SUMMARY:    [[quickfix命令]]
     :SOURCE:     
     :OPERATE:    
     :END:
     - <<quickfix命令>>
       :cnext :cprev :cfirst :clast           item
       :5cnext
       :cnfile :cpfile  :cc N                 file
       :copen :cclose                         quickfix window
       k j <CR> :q
       :cdo {cmd}  :cfdo {cmd}                execute cmd in quickfix list
**** 回溯之前的quickfix列表 Recall Results from a Previous Quickfix List
**** 定制外部编译器 Customize the External Compiler
*** 通过grep、vimgrep以及其他工具对整个工程进行查找 Search Project-Wide with grep, vimgrep, and Others
    :PROPERTIES:
    :SUMMARY:      扫描多文件工具 grep ack
    :SOURCE:       
    :END:
**** 不必离开vim也能调用grep  Call grep Without Leaving Vim
     :PROPERTIES:
     :SUMMARY:    [[shell中]]  [[vim中]]
     :SOURCE:     
     :OPERATE:    
     :END:
     - <<shell中>>
       $ grep -n Waldo *
     - <<vim中>>
       :grep Waldo *
       :grep -i Waldo *    不区分大小写
**** 定制grep  Customize the grep Program
     :PROPERTIES:
     :SUMMARY:     [[ack插件]]
     :SOURCE:     
     :OPERATE:    
     :END:
**** 使用vim内部的grep  Grep with Vim’s Internal Search Engine
     :PROPERTIES:
     :SUMMARY:     [[语法]]  [[指定文件]]  [[查找域留空]]  [[调用查找历史]]
     :SOURCE:     
     :OPERATE:    
     :END:
     - 匹配所有含有going文件
       quotes/
         about.txt
           Don't watch the clock; do what it does. Keep going.
       <<tough.txt>>
           When the going gets tough, the tough get going.
         where.txt
           If you don't know where you are going,
           you might wind up someplace else.

     - <<语法>>
       :vim[grep][!] /{pattern}/[g][j] {file}
                                 [[g]]
                                    j
                                        [[##]]
     - <<指定文件>>    Specifying Which Files to Look Inside
       :vimgrep / going / about.txt tough.txt where.txt
       -> (1 of 3): Don't watch the clock; do what it does. Keep going.
       v
       add <<g>> flag    display all matches on quickfix line (the [[tough.txt]] contain two going)
       v
       :vim /going/g clock.txt tough.txt where.txt
       -> (1 of 4): Don't watch the clock; do what it does. Keep going.
       v
       :vim /going/g *.txt
       -> (1 of 4): Don't watch the clock; do what it does. Keep going.
     - <<查找域留空>>    Search in File, Then Search in Project
       /[Dd]on't
       :vim //g *.txt
     - <<调用查找历史>>
       :vim //g ##
       :vim /<C-r>//g ##
                    <<##>>    to represent the names of each file in the argument list, act as *.txt
*** 自动补全 Dial X for Autocompletion
**** 结识关键字自动补全 Meet Vim’s Keyword Autocompletion
     :PROPERTIES:
     :SUMMARY:    [[当前缓冲区关键字]]  [[操作补全菜单]]  [[标签文字关键字]]  [[补全字典项]]  [[补全整行]]  [[智能补全]]
     :SOURCE:     
     :OPERATE:    
     :END:
     - <<当前缓冲区关键字>>
       <C-x><C-n>
     - <<标签文字关键字>>
       <C-x><C-]>
     - <<补全字典项>>
       <C-x><C-k>
     - <<补全整行>>
       <C-x><C-l>
     - <<智能补全>>
       <C-x><C-o>
**** 与自动补全菜单交互 Work with the Autocomplete Pop-Up Menu
     :PROPERTIES:
     :SUMMARY:    [[操作]]
     :SOURCE:     
     :OPERATE:    
     :END:
     - <<操作>>  <<操作补全菜单>>
       <C-n>                    下一个匹配项
       <C-p>                    上一个匹配项
       <C-y>                    确认
       <C-e>                    取消
** vimrc
   :PROPERTIES:
   :CLOCK:
   :SUMMARY: vim高度可配置文件
   :END:
*** 启动时不加载vimrc
    :LOGBOOK:  
    CLOCK: [2016-08-30 二 17:33]--[2016-08-30 二 17:38] =>  0:05
    :END:      
    :PROPERTIES:
    :CLOCK:
    :SUMMARY:    -u NONE 定制项不会生效  -N 防止进入vi兼容模式
    :SOURCE:     $ vim -u NONE -N
    :END:
*** 把所有数字当成10进制
    :LOGBOOK:  
    CLOCK: [2016-08-30 二 17:38]--[2016-08-30 二 17:40] =>  0:02
    :END:      
    :PROPERTIES:
    :CLOCK:
    :SUMMARY:    避免把0开头的数字当成8进制 例:007+001=010
    :SOURCE:     set nrformats=
    :END:
*** 启用 wildmode
    :LOGBOOK:  
    CLOCK: [2016-09-08 四 12:12]--[2016-09-08 四 12:16] =>  0:04
    :END:      
    :PROPERTIES:
    :SUMMARY:    ex自动补全列表自定义行为 [[vimrc相关配置1]]
    :END:
*** 提高命令的历史记录保存上限
    :LOGBOOK:  
    CLOCK: [2016-09-08 四 15:53]--[2016-09-08 四 15:56] =>  0:03
    :END:      
    :PROPERTIES:
    :SUMMARY:    缺省为20条 这里<<可以提高历史记录上限>>
    :SOURCE:     set history=200
    :END:
*** 轻松展开当前文件所在的目录
    :LOGBOOK:  
    CLOCK: [2016-09-18 日 16:18]--[2016-09-18 日 16:22] =>  0:04
    :END:      
    :PROPERTIES:
    :SUMMARY:    <<:edit 展开当前文件所在目录 vimrc 配置>> 使命令 %% 操作等效于 %:h<Tab>
    :SOURCE:     cnoremap <expr> %% getcmdtype( ) == ':' ? expand('%:h').'/' : '%%'
    :END:
*** 配置为可加载插件
    :LOGBOOK:  
    CLOCK: [2016-09-23 五 08:01]--[2016-09-23 五 08:04] =>  0:03
    :END:      
    :PROPERTIES:
    :SUMMARY:    <<加载 VIM 发行版中自带的标配插件>>
    :SOURCE:     set nocompatible
                 filetype plugin on
    :END:
*** 禁用光标键映射
    :PROPERTIES:
    :SUMMARY:    <<禁用光标键映射>>
    :SOURCE:     noremap <Up> <Nop>
                 noremap <Down> <Nop>
                 noremap <Left> <Nop>
                 noremap <Right> <Nop>
    :END:
*** 重新映射面向行的动作命令
    :LOGBOOK:  
    CLOCK: [2016-09-24 六 21:29]--[2016-09-24 六 21:31] =>  0:02
    :END:      
    :PROPERTIES:
    :SUMMARY:    <<重新映射面向行的动作命令>>
    :SOURCE:     nnoremap k gk
                 nnoremap gk k
                 nnoremap j gj
                 nnoremap gj j
    :END:       
** :h
   :LOGBOOK:  
   CLOCK: [2016-08-30 二 16:14]--[2016-08-30 二 16:17] =>  0:03
   :END:      
   :PROPERTIES:
   :CLOCK:
   :SUMMARY: vim内置文档入口的超链接
   :SOURCE:  :h vimtutor
   :END:
*** <?>
**** .
     :LOGBOOK:  
     CLOCK: [2016-08-30 二 16:22]--[2016-08-30 二 16:23] =>  0:01
     :END:      
     :PROPERTIES:
     :CLOCK:
     :SUMMARY:    重复上次命令帮助文档
     :SOURCE:     :h .  <<:h .>>
     :END:
**** f{char}
     :LOGBOOK:  
     CLOCK: [2016-08-30 二 16:28]--[2016-08-30 二 16:30] =>  0:02
     CLOCK: [2016-08-30 二 16:24]--[2016-08-30 二 16:28] =>  0:04
     :END:      
     :PROPERTIES:
     :CLOCK:
     :SUMMARY:    让vim查找下一处字符出现的位置
     :SOURCE:     :h f  <<:h f>>
     :END:
**** *
     :LOGBOOK:  
     CLOCK: [2016-08-30 二 16:31]--[2016-08-30 二 16:33] =>  0:02
     :END:      
     :PROPERTIES:
     :CLOCK:
     :SUMMARY:    查找当前光标下的单词
     :SOURCE:     :h *  <<:h *>>
     :END:
**** aw
     :LOGBOOK:  
     CLOCK: [2016-08-30 二 16:36]--[2016-08-30 二 16:37] =>  0:01
     :END:      
     :PROPERTIES:
     :CLOCK:
     :SUMMARY:    删除光标下这个单词
     :SOURCE:     :h aw  <<:h aw>>
     :END:
**** count
     :LOGBOOK:  
     CLOCK: [2016-08-30 二 16:41]--[2016-08-30 二 16:43] =>  0:02
     :END:      
     :PROPERTIES:
     :CLOCK:
     :SUMMARY:    普通模式命令执行 次数前缀
     :SOURCE:     :h count  <<:h count>>
     :END:
**** 自定义操作符
     :LOGBOOK:  
     CLOCK: [2016-08-30 二 17:24]--[2016-08-30 二 17:26] =>  0:02
     :END:      
     :PROPERTIES:
     :CLOCK:
     :SUMMARY:    如何自己定义操作符
     :SOURCE:     :h :map-operator  <<:h :map-operator>>
     :END:
**** 自定义动作命令
     :LOGBOOK:  
     CLOCK: [2016-08-30 二 17:26]--[2016-08-30 二 17:27] =>  0:01
     :END:      
     :PROPERTIES:
     :CLOCK:
     :SUMMARY:    如何自己定义动作命令
     :SOURCE:     :h omap-info  <<:h omap-info>>
     :END:
**** operator
     :LOGBOOK:  
     CLOCK: [2016-08-30 二 16:44]--[2016-08-30 二 16:47] =>  0:03
     :END:      
     :PROPERTIES:
     :CLOCK:
     :SUMMARY:    操作符完整列表
     :SOURCE:     :h operator  <<:h operator>>
     :END:
**** ga
     :LOGBOOK:  
     CLOCK: [2016-08-30 二 20:24]--[2016-08-30 二 20:25] =>  0:01
     :END:      
     :PROPERTIES:
     :CLOCK:
     :SUMMARY:    查找光标下字符对应的字符编码(Unicode)
     :SOURCE:     :h ga  [[:h ga]]
     :END:
**** r{char} gr{char}
     :LOGBOOK:  
     CLOCK: [2016-08-31 三 09:16]--[2016-08-31 三 09:18] =>  0:02
     :END:      
     :PROPERTIES:
     :CLOCK:
     :SUMMARY:    单次替换文本 马上回到普通模式
     :SOURCE:     :h r  [[:h r]]
     :END:
**** U
     :LOGBOOK:  
     CLOCK: [2016-09-06 二 11:09]--[2016-09-06 二 11:10] =>  0:01
     :END:      
     :PROPERTIES:
     :CLOCK:
     :SUMMARY:    选中的字符变为大写
     :SOURCE:     :h v_U  [[:h v_U]]
     :END:
**** gU{motion}
     :LOGBOOK:  
     CLOCK: [2016-09-06 二 11:13]--[2016-09-06 二 11:14] =>  0:01
     :END:      
     :PROPERTIES:
     :CLOCK:
     :SUMMARY:    等同于可视模式下的 U
     :SOURCE:     :h gU  [[:h gU]]
     :END:
**** Ex命令
***** 全部功能列表
      :LOGBOOK:  
      CLOCK: [2016-09-06 二 15:50]--[2016-09-06 二 15:51] =>  0:01
      :END:      
      :PROPERTIES:
      :CLOCK:
      :SUMMARY:    相应功能ex命令列表
      :SOURCE:     :h ex-cmd-index  [[:h ex-cmd-index]]
      :END:
***** :copy :t
     :LOGBOOK:  
     CLOCK: [2016-09-07 三 13:30]--[2016-09-07 三 13:37] =>  0:07
     :END:      
     :PROPERTIES:
     :CLOCK:
     :SUMMARY:    ex 复制命令
     :SOURCE:     :h :copy  [[:h :copy]]
     :END:
*****                                                                           :@:
      :LOGBOOK:  
      CLOCK: [2016-09-07 三 18:34]--[2016-09-07 三 18:38] =>  0:04
      :END:      
      :PROPERTIES:
      :SUMMARY:    重复上次的 ex 命令
      :SOURCE:     :h @:  [[:h @:]]
      :END:
***** 寄存器
      :LOGBOOK:  
      CLOCK: [2016-09-07 三 18:38]--[2016-09-08 四 10:05] => 15:27
      :END:      
      :PROPERTIES:
      :SUMMARY:    寄存器总保存最后执行的命令
      :SOURCE:     :h quote_:  [[:h quote_:]]
      :END:
***** 自动补全列表
      :LOGBOOK:  
      CLOCK: [2016-09-08 四 10:28]--[2016-09-08 四 10:56] =>  0:28
      :END:      
      :PROPERTIES:
      :SUMMARY:    显示可用的补全列表
      :SOURCE:     :h c_CTRL-D  [[:h c_CTRL-D]]
      :END:
***** 自动补全
      :LOGBOOK:  
      CLOCK: [2016-09-08 四 10:56]--[2016-09-08 四 10:59] =>  0:03
      :END:      
      :PROPERTIES:
      :SUMMARY:    ex命令自动补全
      :SOURCE:     :h :command-complete  [[:h :command-complete]]
      :END:
***** 多个补全项间选择
      :LOGBOOK:  
      CLOCK: [2016-09-08 四 10:59]--[2016-09-08 四 11:00] =>  0:01
      :END:      
      :PROPERTIES:
      :SUMMARY:    ex自定义补全行为
      :SOURCE:     :h 'wildmode'  [[:h 'wildmode']]
      :END:
*** <C-?>
**** <C-[>
     :PROPERTIES:
     :CLOCK:
     :SUMMARY:    返回普通模式 与<Esc>效果相同
     :SOURCE:     :h i_CTRL-[  <<内置链接1>>
     :END:
**** <C-o>
     :LOGBOOK:  
     CLOCK: [2016-08-30 二 17:02]--[2016-08-30 二 17:11] =>  0:09
     :END:      
     :PROPERTIES:
     :CLOCK:
     :SUMMARY:    插入模式下 执行一次普通模式命令 马上回到插入模式
     :SOURCE:     :h i_CTRL-O  <<:h i_CTRL-O>> 例:<C-o>zz
     :END:
**** <C-r>{register}
     :LOGBOOK:  
     CLOCK: [2016-08-30 二 17:11]--[2016-08-30 二 17:14] =>  0:03
     :END:      
     :PROPERTIES:
     :CLOCK:
     :SUMMARY:    插入模式下 用寄存器粘贴几个单词 {register}是寄存器的名字
     :SOURCE:     :h i_CTRL-R  <<:h i_CTRL-R>>
     :END:
**** <C-v>{code}
     :LOGBOOK:  
     CLOCK: [2016-08-30 二 20:16]--[2016-08-30 二 20:20] =>  0:04
     :END:      
     :PROPERTIES:
     :CLOCK:
     :SUMMARY:    用字符编码插入非常用字符
     :SOURCE:     :h i_CTRL-V_digit  [[:h i_CTRL-V_digit]]
     :END:
**** <C-k>{char1}{char2}
     :LOGBOOK:  
     CLOCK: [2016-08-31 三 08:29]--[2016-08-31 三 08:31] =>  0:02
     :END:      
     :PROPERTIES:
     :CLOCK:
     :SUMMARY:    用 二合字符 插入非常用字符
     :SOURCE:     二合字符规律 :h digraphs-default  [[:h digraphs-default]]  可用二合字符 :h digraph-table [[:h digraph-default]]
     :END:
*** <C-?><C-?>
**** <C-r><C-p>{register}
     :LOGBOOK:  
     CLOCK: [2016-08-30 二 17:22]--[2016-08-30 二 17:24] =>  0:02
     :END:      
     :PROPERTIES:
     :CLOCK:
     :SUMMARY:    插入模式下 按原义插入寄存器文本 {register}是寄存器的名字
     :SOURCE:     :h i_CTRL-R_CTRL-P  <<:h i_CTRL-R_CTRL-P>>
     :END:      
* ABANDON mastering-emacs
  :PROPERTIES:
  :COLUMNS:  %20ITEM %MEAN %SHOTCUTS
  :END:
** first step
*** command to start
   :LOGBOOK:  
   CLOCK: [2016-08-13 六 08:30]--[2016-08-13 六 11:02] =>  2:32
   :END:      
   :PROPERTIES:
   :SHOTCUTS:   --help -nw -q -Q
   :END:
   + --help 显示帮助
   + -nw 强制在终端中执行
   + -q 不加载初始文件(init.el)
   + -Q 不加载站点范围内的文件(系统 运行环境相关)
*** modifier key use
    :LOGBOOK:  
    CLOCK: [2016-08-13 六 11:04]--[2016-08-13 六 11:17] =>  0:13
    :END:      
   + C- Control
   + M- Meta (“Alt” on most keyboards) 
   + S- Shift
   + s- Super (not shift!)
   + H- Hyper
   + A- Alt (redundant and not used)
*** move ctrl to capslock
    :LOGBOOK:  
    CLOCK: [2016-08-13 六 11:17]--[2016-08-13 六 11:20] =>  0:03
    :END:      
*** key chord
   :LOGBOOK:  
    CLOCK: [2016-08-13 六 13:09]--[2016-08-13 六 13:25] =>  0:16
    CLOCK: [2016-08-13 六 11:28]--[2016-08-13 六 11:40] =>  0:12
    :END:      
   :PROPERTIES:
   :SHOTCUTS:   M-x C-u M- C- C-M-
   :END:
   + M-x  Commands and functions
   + C-u  Universal Arguments
   + M- C- C-M-  sceen modefier
   + C-h  help system
*** customize
    :LOGBOOK:  
    CLOCK: [2016-08-13 六 13:25]--[2016-08-13 六 14:00] =>  0:35
    :END:      
   :PROPERTIES:
   :SHOTCUTS:   M-x customize
   :END:
   + M-x customize 自定义配置(学会elip配置前的过度)
*** something for evaluated
    :LOGBOOK:  
    CLOCK: [2016-08-14 日 21:42]--[2016-08-14 日 21:50] =>  0:08
    :END:      
   :PROPERTIES:
   :SHOTCUTS:   M-x eval buffer
   :END:
   + M-x eval buffer  在函数定义的buffer中不适用
*** package manage
    :LOGBOOK:  
    CLOCK: [2016-08-14 日 21:50]--[2016-08-15 一 07:24] =>  9:34
    :END:      
    :PROPERTIES:
    :SHOTCUTS:   M-x package-list-packages
    :END:
   + M-x package-list-packages  更新三方包
   + M-x package-install
*** info
    :LOGBOOK:  
    CLOCK: [2016-08-24 三 17:47]--[2016-08-24 三 19:18] =>  1:31
    :END:      
    :PROPERTIES:
    :MEAN:        emacs's info manual written in TeXinfo
    :SHOTCUTS:    M-x info   C-h i
    :END:
    + table of the keyboards shotcuts 65
*** apropos
    :LOGBOOK:  
    CLOCK: [2016-08-24 三 19:19]--[2016-08-25 四 08:28] => 13:09
    :END:      
    :Properties:
    :MEAN:       search aspects of Emacs’s self-documenting internals(part of symbol)
    :SHOTCUTS:   C-h a   M-x apropos-command  M-x apropos ..etc 69
    :END:
    + M-x apropos   list both variables command and function
    + M-x apropos-command   just list command
*** the describe system
    :PROPERTIES:
    :MEAN:        captures the Emacs’s self-documenting of command(total of sysbol)
    :SHOTCUTS:    M-x describe-mode  C-h m   M-x describe-funtion  C-h f .. 72
    :END:
** the theory of movement
*** the basic
    :LOGBOOK:  
    CLOCK: [2016-08-25 四 08:52]--[2016-08-25 四 09:38] =>  0:46
    :END:      
    :PROPERTIES:
    :MEAN:        important commands of navigation and editing
    :SHOTCUTS:    C-x C-f|C-x C-s|C-x b|C-x k|C-x C-b|C-x C-c|C-/|F-10   .. 77
    :END:
**** find file
     :LOGBOOK:  
     CLOCK: [2016-08-25 四 09:53]--[2016-08-25 四 09:55] =>  0:02
     :END:      
     :PROPERTIES:
     :MEAN:        opening an existing file and creating a new file
     :SHOTCUTS:    C-x C-f  .. 78
     :END:
**** major mode load order
     :LOGBOOK:  
      CLOCK: [2016-08-25 四 09:39]--[2016-08-25 四 09:45] =>  0:06
      :END:      
     :PROPERTIES:
     :MEAN:       When you visit a file, Emacs will pick a major mode(can self-documnet)
     :SHOTCUTS:   #!/bin/bash magic-mode-alist auto-mode-alist  .. 80
     :END:
     - file local-variable
     - program loader directory  file begin with #! emacs will figure out the major mode
     - Magic mode detection  use the magic-mode-alist to detection mode
     - Automatic mode detection  open /etc/passwd emacs will detect this and open etc-passwd-generic-mode
**** Coding Systems and Line Endings
     :LOGBOOK:  
     CLOCK: [2016-08-25 四 09:45]--[2016-08-25 四 09:52] =>  0:07
     :END:      
     :PROPERTIES:
     :MEAN:       excellent Unicode support | determine the line endings used
     :SHOTCUTS:   C-h C <RET> .. 81
     :END:
**** Save Buffer
     :LOGBOOK:  
     CLOCK: [2016-08-25 四 09:56]--[2016-08-25 四 10:01] =>  0:05
     :END:      
     :PROPERTIES:
     :MEAN:       save it to a file associated with the buffer
     :SHOTCUTS:   <C-x C-s>  <C-x C-w>   <C-x s> .. 83
     :END:
     - C-x C-w  save a buffer to a different file
     - C-x s  to save each unsaved file
**** Exit Emacs
     :LOGBOOK:  
     CLOCK: [2016-08-25 四 10:02]--[2016-08-25 四 10:07] =>  0:05
     :END:    
     :Properties:
     :MEAN:       several options when Emacs asks you to save a file
     :SHOTCUTS:   C-x C-c  y  n  q  C-g  !  d .. 83
     :END:
**** Switch Buffer
     :LOGBOOK:  
     CLOCK: [2016-08-31 三 10:09]--[2016-08-31 三 10:21] =>  0:12
     CLOCK: [2016-08-25 四 10:07]--[2016-08-25 四 11:20] =>  1:13
     :END:      
     :PROPERTIES:
     :MEAN:       like ALT+TAB in windows
     :SHOTCUTS:   <C-x b> <C-x C-b>  <C-x C-f> .. 84
     :END:
     - buffers is different from files
     - buffer name format  *buffer name*
     - <C-x b>  swich buffer
     - <C-x C-b>  list all buffers
     - <C-x C-f>  ido mode  create a buffer from local file
**** kill buffer
     :LOGBOOK:  
     CLOCK: [2016-08-31 三 10:21]--[2016-08-31 三 10:24] =>  0:03
     :END:      
     :PROPERTIES:
     :MEAN:       close buffer
     :SHOTCUTS:   <C-x k> .. 86
     :END:
**** keyboard escape
     :LOGBOOK:  
     CLOCK: [2016-08-31 三 10:28]--[2016-08-31 三 10:30] =>  0:02
     :END:     

     :PROPERTIES:
     :MEAN:       go back to normal if something wrong with emacs
     :SHOTCUTS:   Esc Esc Esc .. 86
     :END:
**** Undo
     :LOGBOOK:  
     CLOCK: [2016-08-31 三 10:30]--[2016-08-31 三 10:35] =>  0:05
     :END:      
     :PROPERTIES:
     :MEAN:       undoing previous operate
     :SHOTCUTS:   <C-/> .. 86
     :END:
**** Redo
     :LOGBOOK:  
     CLOCK: [2016-08-31 三 10:35]--[2016-08-31 三 10:37] =>  0:02
     :END:      
     :PROPERTIES:
     :MEAN:       reversion of undo
     :SHOTCUTS:   <C-S-/> .. 86
     :END:
**** windows managment
     :LOGBOOK:  
     CLOCK: [2016-08-31 三 10:37]--[2016-08-31 三 10:54] =>  0:17
     :END:      
     :PROPERTIES:
     :MEAN:       manage windows in shotcut
     :SHOTCUTS:   <C-x> 0 1 2 3 .. 90
     :END:
     | key binding | purpose |
     |---+---|
     | C-x 0 | delete the active window |
     | C-x 1 | delete other windows  |
     | C-x 2 | split window below |
     | C-x 3 | split window right |
**** working with other windows
     :LOGBOOK:  
     CLOCK: [2016-08-31 三 11:19]--[2016-08-31 三 11:20] =>  0:01
     :END:      
     :PROPERTIES:
     :MEAN:       switch another window in split window
     :SHOTCUTS:    .. 93
     :END:
**** frame management
     :LOGBOOK:  
     CLOCK: [2016-08-31 三 11:21]--[2016-08-31 三 11:22] =>  0:01
     :END:      
     :PROPERTIES:
     :MEAN:       some operate about frame
     :SHOTCUTS:    .. 94
     :END:
**** moving
***** moving by character
     :LOGBOOK:  
     CLOCK: [2016-08-31 三 13:37]--[2016-08-31 三 13:38] =>  0:01
     :END:      
     :PROPERTIES:
     :MEAN:       
     :SHOTCUTS:    .. 97
     :END:
***** moving by line
     :LOGBOOK:  
     CLOCK: [2016-08-31 三 13:38]--[2016-08-31 三 13:39] =>  0:01
     :END:      
     :PROPERTIES:
     :MEAN:       
     :SHOTCUTS:    .. 98
     :END:
***** moving by mord
     :LOGBOOK:  
     CLOCK: [2016-08-31 三 13:38]--[2016-08-31 三 13:39] =>  0:01
     :END:      
     :PROPERTIES:
     :MEAN:       
     :SHOTCUTS:    .. 101
     :END:

***** moving by sentence
     :LOGBOOK:  
     CLOCK: [2016-08-31 三 13:38]--[2016-08-31 三 13:39] =>  0:01
     :END:      
     :PROPERTIES:
     :MEAN:       
     :SHOTCUTS:    .. 115
     :END:
***** moving by defun
     :LOGBOOK:  
     CLOCK: [2016-08-31 三 13:38]--[2016-08-31 三 13:39] =>  0:01
     :END:      
     :PROPERTIES:
     :MEAN:       
     :SHOTCUTS:    .. 116
     :END:      
***** moving by page
     :LOGBOOK:  
     CLOCK: [2016-08-31 三 13:38]--[2016-08-31 三 13:39] =>  0:01
     :END:      
     :PROPERTIES:
     :MEAN:       
     :SHOTCUTS: .. 117
     :END:
**** scrolling
     :LOGBOOK:  
     CLOCK: [2016-08-31 三 13:45]--[2016-08-31 三 13:56] =>  0:11
     :END:
     :PROPERTIES:
     :MEAN:       moveing in window
     :SHOTCUTS:   <C-v> <M-v> <C-x <> <M-<> .. 118
     :END:
     | key binding | puepose                             |
     |-------------+-------------------------------------|
     | C-v         | scroll down one page                |
     | M-v         | scroll up one page                  |
     | C-M-v       | scroll down other window            |
     | C-M-S-v     | scroll up other window              |
     |             |                                     |
     | C-x <       | scroll left                         |
     | C-x >       | scroll right                        |
     |             |                                     |
     | M-<         | move to the beginning of the buffer |
     | M->         | move to the end of buffer           |
     |             |                                     |
     |             |                                     |
**** bookmarks and registers
     :LOGBOOK:  
     CLOCK: [2016-08-31 三 13:58]--[2016-08-31 三 14:24] =>  0:26
     :END:      
     :PROPERTIES:
     :MEAN:       speed access to everywhere
     :SHOTCUTS:   <C-x r m|l|b>  <C-x r s|spc|j|w|f> .. 121
     :END:
     - bookmarks (permanent)
       | key binding  | purpose |
       |---+---|
       | C-x r m | set a bookmark |
       | C-x r l | list all bookmark |
       | C-x r b | jump to bookmark |
     - registers (transient)
       | key binding | purpose                                |
       |-------------+----------------------------------------|
       | C-x r s     | store region in register               |
       | C-x r spc   | store point in register                |
       | C-x r j     | jump to register                       |
       | C-x r w     | store window configuration in register |
       | C-x r f     | store frameset in register             |
       |             |                                        |
**** selections and regions
     :LOGBOOK:  
     CLOCK: [2016-08-31 三 14:25]--[2016-08-31 三 14:31] =>  0:06
     :END:      
     :PROPERTIES:
     :MEAN:       mark and select a region
     :SHOTCUTS:   .. 127
     :END:
**** setting the mark (relate up section)
     :LOGBOOK:  
     CLOCK: [2016-08-31 三 14:33]--[2016-08-31 三 14:36] =>  0:03
     :END:      
     :PROPERTIES:
     :MEAN:       make precise selections
     :SHOTCUTS:   .. 131
     :END:
**** searching and indexing
     :LOGBOOK:  
     CLOCK: [2016-08-31 三 14:36]--[2016-08-31 三 14:52] =>  0:16
     :END:      
     :PROPERTIES:
     :MEAN:       precise tool getting you from a to b
     :SHOTCUTS: <C-s>  <C-r> <C-M-s> <C-M-r> .. 134
     :END:
     - isearch
     | key binding | purpose            |
     |-------------+--------------------|
     | C-s         | down search        |
     | C-r         | up search          |
     | C-M-s       | regexp down search |
     | C-M-r       | regexp up search   |
     | ret         | pick select match  |
     | C-g         | exit search        |
     - control how isearch behaves using its toggles 139
**** Occur
     :LOGBOOK:  
     CLOCK: [2016-08-31 三 14:52]--[2016-08-31 三 14:56] =>  0:04
     :END:      
     :PROPERTIES:
     :MEAN:       print lines matching an expression
     :SHOTCUTS:   <M-s o> .. 142
     :END:
**** Imenu
     :LOGBOOK:  
     CLOCK: [2016-08-31 三 14:57]--[2016-08-31 三 15:00] =>  0:03
     :END:      
     :PROPERTIES:
     :MEAN:       
     :SHOTCUTS:   .. 146
     :END:      
* READING github资源汇总
** 正则表达式
   :LOGBOOK:  
   CLOCK: [2016-09-21 三 21:15]--[2016-09-21 三 21:18] =>  0:03
   :END:      
** Learn X in Y minutes
* READING 计算机程序的构造和解释 sicp
** 目录 17
** 构造过程抽象 19
   - lisp
     - scheme
*** 程序设计的基本要素 The Elements of Programming 3 6
    - 语言
      - 三种机制  three mechanisms
        基本表达形式  primitive expression
        组合的方法    means of combination
        抽象的方法    means of abstraction
      - 处理要素  elements
        过程       procedures
        数据       data
**** 表达式 expressions
     - 基本表达式  number
       486
     - 组合表达式  combinations
           (+         22        44)
          运算符          运算元
         operator       operands
     - 嵌套表达式  nested
       (+ (- 22 11) (* 2
                       (+ 2 2)))
**** 命名和环境 naming and environment
         environment     memory
            环境     -     存储
                           |
                    name-object pairs
                         键值对
         (define     size      2)
           定义       变量     对象
         naming    variable  object
**** 结合式的求值 Evaluating Combinations
     Evaluating Combinations           leftmost subexpression(the operator)                     Subexpressions of the combination(the operands)
              求值                =             最左子表达式(运算符)                   ＋                        其他子表达式的值(运算对象)
                                                                                                                        |
                                                                                                 nested operator                         nested operands
                                                                                                 最左子表达式(运算符)          +            其他子表达式的值(运算对象)
                                                                                                                                                   |
                                                                                                                                                  ...
**** 复合过程 Compound Procedures
     procedure definitions
     (define                  (<name>    <formal parameters>)   <body> )
                              关联符号           形式参数          表达式
     (define                  (square              x        )   (* x x))
     (square 3)
      => 9
**** 过程应用的代换模型 substitution model
     - 代换模型 substitution mode
       (f 5)                                   combination f 组合式
       (sum-of-squares (+ a 1) (* a 2))        retrieving the body f
       (sum-of-squares (+ 5 1) (* 5 2))        replace argument 5
       (+ (square 6) (square 10))              reduce to the evaluation of a combination with two operands 运算对象
       (+ (* 6 6) (* 10 10))                   definition of square
       (+ 36 100)
       136
     - 应用序 application order 与 正则序 normal order
                                     (sum-of-squares (+ 5 1) (* 5 2))
                                   /                                 \
                  正则序求值(完全展开)                                   应用序求值(避免重复求值)
       (+ (square (+ 5 1))   (square (* 5 2))  )                   (+ (square 6) (square 10))
       (+ (* (+ 5 1)(+ 5 1)) (* (* 5 1)(* 5 1)))                   (+ (* 6 6) (* 10 10))
**** 条件表达式和谓词 conditional expressions and predicates
     - case analysis
           /  x    if x > 0
       |x|    0    if x = 0
           \  -x   if x < 0
     - conditional expressions and predicates
       - (cond <p> <e>)
           cond - conditional expression
           p - predicates

           (define (abs x)
             (cond ((> x 0) x)
                   ((= x 0) 0)
                   ((< x 0) (-x))))
     - absolute-value procedure
       - else
         (define (abs x)
            (cond ((> x 0) x)
                  (else (-x))))
       - (if <predicate> <consequent> <alternative>)
           predicate -- true    consequent
                     \  false   alternative

           (define (abs x)
             (if (< x 0)
                 (-x)
                 x))
       - (and <e1> ... <en>)
                   | \
                   |   = false    if <ef> = false     (1 <= f <= n)
                 = true    if all <e> = true

         (and (> x 5) (< x 10))
       - (or <e1> ... <en>)
                   | \
                   |   = true    if <ef> = true     (1 <= f <= n)
                 = false    if all <e> = false

         (define (>= x y)
           (or (> x y) (= x y)))
       - (not <e>)
               | \
               |   = true    if <e> = false
             = false    if <e> = true

         (define (>= x y)
           (not (< x y)))
**** 实例: 采用牛顿法求平方根 example: square roots by newton's method
      - 牛顿法特例求平方根
        求2的平方根
        | Guess | Quotient        | Average                   |
        |-------+-----------------+---------------------------|
        |     1 | (2/1) = 2       | ((2 + 1)/2) = 1.5         |
        |   1.5 | (2/1.5) = 1.333 | ((1.333 + 1.5)/2) = 1.416 |
        | 1.416 | ...             | ...                       |

        - lisp 实现

          (define (sqrt-iter guess x)                     (define (sqrt-iter guess x)          [[new-if]]
            (if (good-enough? guess x)                      (new-if (good-enough? guess x)
                guess                                               guess
                (sqrt-iter (improve guess x) x)))                   (sqrt-iter (improve guess x) x)))

          (define (improve guess x)
            (average guess (/ x guess)))

          (define (average x y)
            (/ (+ x y) 2))

          (define (good-enough? guess x)                  (define (good-enough? old-guess new-guess)   [[good-enough?]]
            (< (abs (- (square guess) x)) 0.001))             (> 0.01
                                                                  (/ (abs (- new-guess old-guess))
                                                                                      old-guess)))
          - <<new-if>>
            对于重新定义的 if 函数 new-if     [fn:new-if]
            他没有 if 所具有的 特殊形式       [fn:特殊形式]
            sqrt-iter 函数将被无限递归调用
          - <<good-enough?>>
            书本给出的 sqrt 函数 (平方根之差0.001)
            对于特别小的数 0.00009 无法给出正确的数
            对于特别大的数 由于小数精度精度不足 会出现死循环

[fn:new-if] (define (new-if predicate then-clause else-clause)
              (cond (predicate then-clause)
                    (else else-clause)))
[fn:特殊形式] 根据编译器所使用的 应用序求序规则
             每个函数的实际参数在传入时都会被求值

             示例:
             (if #t (display "good") (display "bad"))
             -> good
             (new-if #t (display "good") (display "bad"))
             -> badgood
**** 过程作为黑箱抽象 Procedures as Black-Box Abstractions
     - sprt 过程分解
       一个过程应该隐藏起一些细节 So a procedure definition should be able to suppress detail.
       用户在使用一个过程时 应该不需要去弄清楚如何实现的 A user should not need to know how the procedure is implemented in order to use it
       |--------+-------------+-----------+---------+---------|
       |        |             | sprt      |         |         |
       |        |             | sqrt-iter |         |         |
       |        | good-enough |           | improve |         |
       | square | abs         |           |         | average |
     - 局部名 local names
       过程的意义不应该依赖于作者为形式参数所选用的名称 a procedure should be independent of the parameter names used by its author

       ;;  the x in good-enough? must be a different x than the one in square
       (define (good-enough? guess x)
         (< (abs (- (square guess) x))
                               0.001))
     - 内部定义 块结构 Internal definitions and block structure

       将 x 作为参数在过程之间 显示传递
       (define (sqrt x)
         (define (good-enough? guess x)
           (< (abs (- (square guess) x)) 0.001))
         (define (improve guess x) (average guess (/ x guess)))
         (define (sqrt-iter guess x)
           (if (good-enough? guess x)
               guess
               (sqrt-iter (improve guess x) x)))
         (sqrt-iter 1.0 x))

       由于过程都定义在sqrt里 x在sqrt里受约束
       可以让x作为内部定义的自由变量
       词法作用域 lexical scoping
       (define (sqrt x)
         (define (good-enough? guess)
           (< (abs (- (square guess) x)) 0.001))
         (define (improve guess)
           (average guess (/ x guess)))
         (define (sqrt-iter guess)
           (if (good-enough? guess)
               guess
               (sqrt-iter (improve guess))))
       (sqrt-iter 1.0))

*** 过程与它们所产生的计算 Procedures and the Processes They Generate 20 40
    考察一些简单过程产生的计算过程的 ‘形状’ 研究其消耗资源的速率
    learn to visualize the processes generated by various types of procedures
    learn to reliably construct programs that exhibit the desired behavior
**** 线性递归和迭代 Linear Recursion and Iteration
     - 计算阶乘
       - 线性 递归计算过程 linear recursive process
         (factorial 3)
         (* 3 (factorial 2))
         (* 3 ())
         (* 3 (* 2 (factorial 1)))
         
         (define factorial n
             if(= n 1)
                1
         (* n (factorial (- n 1))))
       - 线性 迭代计算过程 linear iterative process <<迭代相关>>
         (factorial 6)
         (fact-iter 1 1 6)
         (fact-iter 1 2 6)
         (fact-iter 2 3 6)
         (fact-iter 6 4 6)
         (fact-iter 24 5 6)
         (fact-iter 120 6 6)
         (fact-iter 720 7 6)

         (define (factorial n)
         (define j(iter product counter)
           (if (> counter n)
               product
               (iter (* counter product)
                       (+ counter 1))))
         (iter 1 1))
     - Ackermann’s function
       (define (A x y)
           (cond ((= y 0) 0)
               ((= x 0) (* 2 y))
               ((= y 1) 2)
               (else (A (- x 1) (A x (- y 1))))))

       (A 0 n)      2n
       (A 1 n)      2^n
       (A 2 n)      2^2^(n-1)
**** 树形递归 Tree Recursion
     - 斐波那契数列 Fibonacci numbers
       0, 1, 1, 2, 3, 5, 8, 13, 21, ....
       - 树形递归 prototypical tree recursion
         (define (fib n)
           (cond ((= n 0) 0)
                 ((= n 1) 1)
                 (else (+ (fib (- n 1))
                      (fib (- n 2))))))
         - 黄金分割 golden ratio
           φ = (1+√5)/2 ≈ 1.6180
           φ^2 = φ + 1
       - 线性递归 linear iteration
         (define (fib n) (fib-iter 1 0 n))
           (define (fib-iter a b count)
             (if (= count 0)
                 b
                 (fib-iter (+ a b) a (- count 1))))
     - 换零钱 Counting change
       - 采用状态变量的迭代 iteration with state variables [[Θ]]

         (define (count-change amount) (cc amount 5))

         (define (cc amount kinds-of-coins)
             (cond ((= amount 0) 1)
                   ((or (< amount 0) (= kinds-of-coins 0)) 0)
                   (else (+ (cc amount
                                 (- kinds-of-coins 1))
                            (cc (- amount
                                 (first-denomination
                                    kinds-of-coins))
                                 kinds-of-coins)))))

         (define (first-denomination kinds-of-coins)
           (cond ((= kinds-of-coins 1) 1)
                 ((= kinds-of-coins 2) 5)
                 ((= kinds-of-coins 3) 10)
                 ((= kinds-of-coins 4) 25)
                 ((= kinds-of-coins 5) 50)))
     - 帕斯卡三角 Pascal’s triangle
                   1
                  1 1
                 1 2 1
                1 3 3 1
               1 4 6 4 1
                  ...
       - 迭代
         相比较递归方式 没有最大递归深度限制 效率高 [[迭代相关]]
         - 计算方法
           (row col) = row! / col!(row - col)!

         (define (factorial n)
           (fact-iter 1 1 n))

         (define (fact-iter product counter max-count)
             (if (> counter max-count)
                 product
                 (fact-iter (* counter product)
                            (+ counter 1)
                            max-count)))

         (define (pascal row col)
             (/ (factorial row)
                (* (factorial col)
                   (factorial (- row col)))))
**** 增长的阶 Orders of Growth
     - 换零钱 Counting change <<Θ>>
       - 流程图 graph
         (count-change 11)
         |----------+-----------+----------+----------|
         | cc(11 5) | cc(-39 5) |          |          |
         | cc(11 4) | cc(-14 4) |          |          |
         | cc(11 3) | cc(1 3)   | cc(-9 2) |          |
         |          | cc(1 2)   | cc(-4 2) |          |
         |          | cc(1 1)   | *cc(0 1)*  |          |
         | cc(11 2) | cc(6 2)   | cc(1 2)  | cc(-4 2) |
         |          |           | cc(1 1)  | *cc(0 1)*  |
         |          |           | cc(1 0)  |          |
         |          | cc(6 1)   | cc(6 0)  |          |
         |          | cc(5 1)   | cc(5 0)  |          |
         |          | ...       |          |          |
         |          | cc(1 1)   | *cc(0 1)*  |          |
         |          | cc(1 0)   |          |          |
         | cc(11 1) | cc(10 1)  | cc(10 0) |          |
         |          | cc(9 1)   | cc(9 0)  |          |
         |          | ...       |          |          |
         |          | cc(1 1)   | *cc(0 1)*  |          |
         |          | cc(1 0)   |          |          |
         | cc(11 0) |           |          |          |

       - 空间增长阶 the orders of growth of the space

         | Θ(n)    | Θ(n^2)              | Θ(n^k)  |
         |---------+---------------------+---------|
         | cc(n 1) | cc(n 2)             | cc(n k) |
         |         | cc(n 1) + cc(n-5 2) |         |
         |         | Θ(n) * n/5          |         |
**** 求幂 exponentiation
     b^n
     b^n = b * b^(n-1)
     b^0 = 1
     - linear recusive process (less code)
       (define (expt b n)
         (if (= n 0)
             1
             (* b (expt b (- n 1)))))
     - linear iteration (less space)
       (define (expt b n)
         (expt-iter b n 1))
       (define (expt-iter b counter product)
         (if (= counter 0)
             product
             (expt-iter b
                        (- counter 1)
                        (* b product))))

     b^2 = b * b
     b^4 = b^2 * b^2
     b^8 = b^4 * b^4
     b^n = (b^(n/2))^2  ; n is even
     b^n = b * b^(n-1)
     - linear iterator (less step)
       (define (fast-expt b n)
         (define (iter a b n)
           (cond ((= n 0) a)
                 ((even? n) (iter a (square b) (/ n 2))) ;  predicate n is even
                 (else (iter (* a b) b (- n 1)))))
         (iter 1 b n))

       (define (square x) (* x x))
**** 最大公约数 greatest common divisors (GCD)
     a % b = r
     GCD(a,b) = GCD(b,r)
     - Euclid's Algrithm
       (define (gcd a b)
         (if (= b 0)
             a
             (gcd (remainder a b))))
     b >= Fib(k) ~ Φ^k / √5
     - lame's Thearem
       if Euclid's Algorithm requires k steps
       the smaller one must be greater than or equal to the k^th fibonacci number
**** 实例 素数检测 example testing for primality
     - 寻找因子 searching for divisors (have order of growth Θ(sqrt(n))
       : The following program finds the smallest integral divisor (greater than 1) of a given number n
       =;; It does this in a straightforward way, by testing n for divisibility by successive integers starting with 2=
       (define (smallest-divisor n)
         (find-divisor n 2))
       =;; The end test for find-divisor is based on the fact that if n is not prime it must have a divisor less than or equal to sqrt(n)=
       (define (find-divisor n test-divisor)
         (cond ((> (square test-divisor) n) n)
               ((divides? test-divisor n) test-divisor)
               (else (find-divisor n (+ test-divisor 1)))))

       (define (divides? a b)
         (= (remainder b a) 0))

       =;; We can test whether a number is prime as follows:
       ;;    n is prime if and only if n is its own smallest divisor=
       (define (prime? n)
         (= n (smallest-divisor n)))
     - 费马检查 the fermat test
       based on a result from number theory known as *Fermat’s Little Theorem*
       - 费马小定理 Fermat's Little Theorem
         If n is a prime number and a is any posi- tive integer less than n, then a raised to the nth power is congruent to a modulo n
         (Two numbers are said to be congruent modulo n if they both have the same remainder when divided by n)
         a^n % n = a % n
       - 实现费马检查
         (define (expmod base exp m)
            (cond ((= exp 0) 1)
                  ((even? exp)
                   (remainder (square (expmod base (/ exp 2) m))
                               m))
                  (else
                   (remainder (* base (expmod base (- exp 1) m))
                               m))))
       - 验证
         =;; The Fermat test is performed by choosing at random a number a be- tween 1 and n − 1 inclusive and checking whether the remainder modulo n of the nth power of a is equal to a=
         (define (fermat-test n)
           (define (try-it a)
             (= (expmod a n n) a))
           (try-it (+ 1 (random (- n 1)))))
     - 费马检查的概率性 Probabilistic methods
       if n ever fails the Fermat test, we can be certain that n is not prime
       - But the fact that n passes the test, while an extremely strong indication, is still not a guarantee that n is prime
         There do exist numbers that fool the Fermat test:
           numbers n that are not prime and yet have the property that an is congruent to a modulo n for all integers a < n
       - the Probabilistic methods for Fermat test
         If n passes the test for two random choices of a, the chances are better than 3 out of 4 that n is prime
         The existence of tests for which one can prove that the chance of error becomes arbitrarily small has sparked interest in algorithms of this type
           which have come to be known as probabilistic algorithms
       - the apply of Probabilistic methods
         cryptography, electronic funds transfer, and information retrieval
* READING 代码大全
** 打好基础 laying the foundation
*** 软件构建的世界
**** 什么是软件构建 40
    - 软件  40下
    - 构建  42下
**** 软件构建为何如此重要 43
*** 隐喻了解软件开发 metaphors for a richer understanding of software development 46
**** 隐喻重要性 the importance of metaphors
     - 建模 modeling
       - 类比 analogy
**** 如何使用隐喻 how 48
     - 更像启示 heuristic
     - 而不是算法 algorithm
       - 算法特性
         predictable            可预测的
         deteministic           确定性的
         not subject to change  不易变化的
**** 常见软件隐喻 common 50
     - 软件中的书法 writing code
       程序可读性      readability
       重用              reuse
       测试用例         test case
       昂贵的试错过程  trial and error
     - 软件耕作法  growing a system
       每天做一点
     - 软件牡蛎养殖法 system accretion
       增量的    incremental
       迭代的     iterative
       自适应的    adaptive
       演进的    evolutionary
     - 软件构建 building software
       问题定义       problem definition
       软件架构设计  architectural design
       构建             construction
       优化             optimization
       复查 审查      review inspection

       容器类         container class

       结构性支持    structural support

       轻量级的方法     lightweight
       容灾规划      over-engineered

       支撑性的测试代码 scaffolding
       基础类      foundation classes
       分离代码    tearing code apart
     - 应用软件技术 the intellectual toolbox
       规矩              rule
       分析工具    analytical tools
       
*** 三思而后行 前期准备 measure twice, cut once  upstream prerequisites
**** 前期准备的重要性 importance of prerequisites
     pontiac aztek    劳斯莱斯
**** 前期准备适用于现代软件项目吗 do prerequisites apply to modern software projects
     降低风险 平稳进行
**** 准备不周全的原因 causes of incomplete preparation
     
**** 关于开始构建之前要做前期准备的绝对有力且简明的论据 utterly compelling and foolproof argument for doing prerequisites before construction
     诉诸逻辑 appeal to logic
       有效编程
     诉诸类比 appeal to analogy
       正确的顺序做事情
     诉诸数据 appeal to data
       进行非必要的修改是昂贵的
**** 辨明你所从事的软件类型 determine the kind of software you're working on
     三种常见的软件种类 68
     迭代开发法对前期准备的影响 *iterative approaches' effect on prerequisites*
     在序列式开发法与迭代式开发法之间做出选择 *choosing between iterative and sequential approaches*
**** 问题定义的先决条件 *problem definition prerequisites*
     产品设想 product vision
     设想陈述 vision statement
     任务陈述 mission statement
     产品定义 product definition
     花大量时间去解决错误的问题
**** 需求的先决条件 requirements prerequisites
     需求开发 requirements development
     需求分析 requirements analysis
     分析 analysis
     规格书 specification
     功能规格书 function spec
     规格 spec

     为什么要有正式的需求 why have official requirements
       范围 scope 描述 specify
       没有好的需求 可能对问题有总体的把握 但是没有击中问题的特定方面

     稳定需求的神话 the myth of stable requirements
       项目理解深入 需求变更

     在构建期间需求变更 handling requirements changes during construction
       需求核对表 *requirements checklist* 79
       演进原型 evolutionary prototyping 演进交付 evolutionary delivery
**** (*)架构的先决条件 architectural prerequisites
     离开良好的架构 Nike 可能瞄准了正确的问题 使用了错误的方案
     - 架构典型组成部分 typical architectural components
       - 程序组织 program organization
         构造块 building block 相互联系 越少越好
       - 主要的类 major class
         80%的行为 20%的类
       - 数据设计 data design
         数据通常只由一个子系统或一个类访问
       - 业务规则 business rule
         架构依赖特定规则 应该详细描述 客户信息 及时更新
       - 用户界面设计 user interface design
         人性化 模块化 替换用户界面 不影响业务逻辑
       - 资源管理 resource management
         如内存管理
       - 安全性 security
         处理缓冲区、非受信数据的规则
       - 性能 performance
         速度 成本 内存 优先度
       - 可伸缩性 scalability
         系统增长满足未来需求 用户数 服务器数 网络节点 数据库记录长度
       - 互用性 interoperability
         软件 硬件资源共享
       - 国际化 本地化 internationalization localization
         字符串翻译为另一种语言 不影响代码和界面
       - 输入 输出 input output
         读取策略 reading scheme : 先做 look-ahead
                                  后做 look-behind
                                  即时做 just-in-time
       - 错误处理 error processing
         纠正 检测 主动 被动 抛出 记录
       - 容错性 fault tolerance
         错误中恢复 部分运转 patial operation 功能退化 degraded functionality
       - 架构可行性 architectural feasibility
         验证概念的原型 proof-of-concept-prototype
         有限资源下运转 技术可行性
       - 过度工程 overengineering
         做出最简单的能工作的东西
       - 关于买还是造
         下载开源软件 购买付费软件
       - 关于复用的决策
         如何对软件进行加工 测试用例 数据格式 其他原料
       - 变更策略 change strategy
         变更  输入输出格式
              用户交互风格
               需求的处理    影响少数几个类
         保留  将来使用的字段
         保存  数据到外部文件  不重新编译修改代码
       - 架构总体质量 general architectural quality
         决策的动机 机器编程语言无关 风险的区域 多个视角

**** 花费前期准备的时间长度 amount of time spend on upstream prerequisites
     10%~20%工作量 20%～30%时间
     建筑师在完成蓝图之前 不会着手其他事宜
*** 关键的构建决策 key construction decisions
**** 选择编程语言 choice of programming language
     高级语言比低级语言表达能力更强 每行代码能表达更多的含义
     - 语言描述 language description
       某些语言发展历史
       *ada*          通用高级编程语言 基于pascal 强调数据抽象和信息隐藏       适合实时及嵌入式系统 军事 航空航天系统

       assembly language
       汇编语言      低级语言 每条语句对应一条机器指令 冲破执行速度 避免使用    针对特定处理器 Intel CPU

                    general purpose mid-level language
       *C*            通用的中级语言 结构化数据 控制流程 机器无关性运算符       unix操作系统相关 微型计算机和工作站的事实标准
                    指针和地址 低级构建(位操作) 弱类型

                    object-oriented
       *C++*          面向对象的语言 与c兼容 提供了类多态 异常处理
                    健壮的类型检查功能 内容广泛而强大的标准库

       *C#*           面向对象语言和编程环境                                 帮助在Microsoft平台上进行开发

       common business-oriented language
       *Cobol*        像英语的编程语言                                      商业应用

       FORmula TRANslation 公式翻译
       *fortran*      第一个高级计算机语言 引入变量 高级循环                   科学工程应用

       *java*         是一个面向对象语言                                     web应用编程
                    源代码变为字节码 在各个平台虚拟机上运行

       *javascript*   解释执行的脚本语言                                     游戏 桌面和移动应用程序的开发和在服务器端网络环境运行
                    指令化 结构化 动态化

       practical extraction and report language
       *perl*         处理字符串的语言 基于c和部分unix                        系统管理任务 生成脚本 处理报表

       hypertypetext processor 超文本处理器
       *php*          开源脚本语言                                          嵌入web页面 访问及呈现数据库信息
                    操作系统上运行 与服务器进行交互

       *python*       解释性 交互式面向对象语言                               除了系统内核 在其他领域都能插足 被称为胶水语言
                    多种编程范式

       structured query language 结构化查询语言
       *SQL*          声明式语言                                            定义一系列操作 以及操作的结果
                    查询 更新 管理数据库 标准

       *visual basic* 面向对象可视化高级语言 由 microsoft 开发                 开发桌面应用程序
**** 编程约定 programming convention
     任何大型程序都需要一个控制结构 该结构可以统一编程语言细节
       将每个类衔接到一种完整的设计 comprehensive design
**** 你在技术浪潮中的位置
     在一种语言上编程 programming in a language
     深入一种语言编程 programming into a language
**** 选择主要的构建方法 selection of major construction practices 107
     编码
       编码约定 不受限于语言
     团队工作
       代码 check in 到主源码中之前 履行哪些步骤
       结对编程 独自编程
       测试用例 单元测试 集成测试
       复审别人的代码
     工具
       版本控制工具 编译器 重构工具 调试器 测试框架

** 创建高质量的代码 creating high-quality code
*** 软件构建中的设计 design in construction
**** 设计中的挑战
***** 设计是一个险恶的问题  design is a wicked problem
      先把问题解决一遍 才能明确定义它 再次解决 形成一个可行的方案
***** 设计是个了无章法的过程  design is a sloppy process
      在设计阶段犯错加以修正
***** 设计就是确定取舍调整顺序的过程  design is about tradeoffs and priorities
      衡量彼此冲突的各项设计特性 快速反应速度 开发时间
***** 设计受到诸多限制  design involves restrictions
      设计要点 创造可能发生事情 限制可能发生事情
      对时间 资源 空间进行限制
***** 设计是不确定的  design is nondeterministic
      不同的人 往往会设计出 不同的程序
***** 设计是一个启发式的过程  design is a heuristic process
      设计技术具有探索性 过程中总会有试验和犯错
***** 设计是自然而然形成的  design is emergent
      不断的评估 非正式讨论 写试验代码 修改试验代码中眼花和完善的
**** 关键的设计理念 key design concept
***** 软件的首要技术使命：管理复杂度  software primary technical imperative: manageing complexity
****** 偶然的难题和本质的难题  accidental and essential difficulties
       汽车具有引擎 和 是V8引擎还是涡轮增压引擎
****** 管理复杂度重要性  imprtance of managing complexity
       失控的复杂度会让软件变得极端复杂 代码修改无处着手 项目中止
       一个时刻专注于一个特定的部分 从问题领域着手 写出短小精悍 通俗易懂的代码
****** 如何应对复杂度  how to attack complexity
       - 错误的设计根源
           复杂方法解决简单的问题
           简单但错误的方法解决复杂的问题
           用不恰当的方法解决复杂的问题
       - 管理复杂度
           任何人 同一时间 本质复杂度 量减到最低
           不要让 偶然复杂度 无谓的快速增长
***** 理想的设计特征  desirable characteristics of a design
      最小复杂度  minimal complexity
        简单易于理解 专注程序的一部分安心忽略其他部分
      易于维护  ease of maintenance
        把维护程序员当成你的听众 设计出能自明(self-explanatory)的系统
      松散耦合  loose counpling
        各个组成部分关联最小 通过接口合理抽象 封装 隐蔽
        相互关联尽量少的类 减少集成 测试 维护 工作
      可扩展性  extensibility
        改动系统某一部分 不会给系统造成什么破坏
      可重用性  reusability
        系统的组成部分 能在 其他系统中 重复使用
      高扇入  high fan-in
        系统 很好的利用 较低层次上的工具类 utility classes
      低扇出  low fan-out
        一个类尽量少的使用其他类 _低扇出优于高扇入_
      可移植性  portability
        能方便的移植到其他系统中
      精简性  leanness
        一个系统的完成 不在于它不能加入任何内容 而在于他不能删除任何内容
      层次性  stratification
        保持 各个分解层 的 层次性
        低劣的旧层 -> _创建同新系统的交互层_ -> 新的层次
        抛弃或重构旧层 -> _修改交互层_ -> 新的层次
      标准技术  standard techniques
        要尽量用 标准化的 常用的 方法 给人以一种熟悉的感觉
***** 设计的层次性  levels of design 119
      一个程序中的设计层次
****** 第一层：软件系统  Level 1: software system
       子系统或者包(package)
****** 第二层：分解为子系统或包 Level 2: Division into Subsystems or packages
       限制子系统之间的通信
       接口封装 方便修改扩展
****** 第三层：分解为类 Level 3: Division into Classes
       对象(object)与类(class)
****** 第四层：分解成子程序 Level: Division Into Routines
****** 第五层：子程序内部的设计 Level5: Internal Routine Design
       功能实现
***** 设计构造块：启发式方法 Design Building Blocks: Heuristics 124
****** 找出现实世界中的对象 find Real-World Objects
****** 形成一致的抽象 Form Consistent Abstractions
       关注某一概念同时忽略其中一些细节
****** 封装实现细节 Encapsulate Implementation Details
       简化一切复杂实现 所看即所得
****** 当继承能简化设计时就继承 Inherit-When Inheritance Simplifies the Design
       辅佐抽象的概念
****** 隐藏秘密(信息隐藏) Hide Secrets (Information Hiding)
       隐藏复杂度 好的类接口大部分内容都不会暴露出来
       隐藏变化源 减少改动所影响的代码量
* ABANDON 算法导论 introduction to algorithmns
** 基础知识 foundations
   第一章 综述
   第二章 排序
   第三章 渐进表示
   第四章 分治法
   第五章 概率分析 随记化算法
*** 算法 algorithm
    交通图                     十字路口                         最短路径
    DNA链         X有m个序列 Y有n个序列 2^m或2^n次方子序列        动态规划
    机械设计           列出部件 m个部件 m!可能的顺序              拓扑排序
    寻找凸壳        给定平面上n个点 包含2^n次方凸壳定点            凸壳求法

    数据结构                  存取和组织数据 访问和修改
    技术          求中位数 顺序统计量 计算最小生成树 确定网络中的最大流 ...
    难题                            NP完全算法
*** 作为一种技术的算法
    插入排序    排序n个项 所花时间c1*n^2       c1是常数 \
                                                       c1<c2  n较小     插入排序快
                                                       n较大  lgn<n^2   归并排序快
    归并排序    排序n个项 所花时间c2*n*lgn     c2是常数 /

  * 算法需要 f(n) 毫秒    在时间 t 内求解的最大规模 n
    | f(n)\t |  1 sec |      1 min | 1 hour       | 1 day | 1 month | 1 year | 1 century | n          |
    |--------+--------+------------+--------------+-------+---------+--------+-----------+------------|
    | lgn    | 2^1000 | 2^(6*10^4) | 2^(3.6*10^5) |       |         |        |           | 2^t        |
    | √n     | 1*10^6 |   3.6*10^8 | 1.2*10^12    |       |         |        |           | t^2        |
    | n      | 1*10^3 |     6*10^4 | 3.6*10^5     |       |         |        |           | t          |
    | nlgn   |    140 |       5000 | 2.3*10^4     |       |         |        |           | 2^(t/n)    |
    | n^2    |     31 |      244.9 | 600          |       |         |        |           | √t         |
    | n^3    |    9.9 |       39.1 | 71.6         |       |         |        |           | 3√t        |
    | 2^n    |    9.9 |       15.5 | 18.4         |       |         |        |           | lgt        |
    | n!     |    6.1 |        8.1 | 9            |       |         |        |           | √(2t) -1/4 |
** 算法基础
*** 插入排序 insettion sort
    #+Name: <INSERTION-SORT(A)>
    #+BEGIN_SRC <pseudocode>
       for j = 2 to A.length
           key = A[j]
           i = j - 1
           while i > 0 and A[i] > key
                 A[i+1] = A[i]
                 i = i - 1
           A[i+1] = key
    #+END_SRC

    + +  +  + ... +  +
    \ /
    \ /\ /
    \ /\ /\ /
    \ /\ /\ / ...  \ /
*** 分析算法 analyzing algorithm
    - 插入排序耗时分析 running time of algorithm 47
      - 代价与对应元素求和 sum the products of the cost and time columns 47
        - 最佳情况 best-case           an+b
        - 最差情况 worst-case          an^2+bn+c
        - 增长量级 order of growth     n^2 > n
*** 设计算法 designing algorithm
**** 分治法 the divide-and-conquer approach
     分解 Divide
     解决 Conquer
     合并 Combine

     - 归并排序 merge sort
                         分解n个元素序列成n/2个子序列                  ->                         递归排序两个子序列             ->             合并排序结果
       divide n-elements sequence into two subsequence of n/2 element each            sort two subsequence recursively           merge two sorted subsequence
       #+Name: <MERGE(A,p,q,r)>    A-array    p,q,r-indices under A (p<q<r)    A[p..q] and A[q..r] in sort order (1)
       #+Begin_SRC <pseudocode>
         n_1 = q - p + 1  // (2) computes the length n_1 of subarray A[p..q]
         n_2 = r - q  // (3) computes the length n_2 of subarray A[q+1..r]
         let L[1..n_1+1] and R[1..n_2+1] be new array  // (4) create array L and R of lengths n_1+1 and n_2+1 respectively (the extra position in each array will hold the sentinel)
         for i = 1 to n_1
           L[i] = A[p + i -1]  // (5) copy A[p..q] into L[1..n_1+1]
         for j = 1 to n_2
           R[j] = a[q + j]  // (6) copy A[p+1..q] into L[1..n_2+1]
         L[n_1 + 1] = ∞
         R[n_2 + 1] = ∞  // (7) set sentinel into L and R
         i = 1
         j = 1
         for k = p to r
           if L[i] <= R[j]
              A[k] = L[i]
              i = i + 1
           else A[k] = R[j]
              j = j + 1  // (8)
       #+END_SRC

                                                                     A  [2 4 5 7 1 2 3 6]                            (1)
                                                            A  [1..n_1]                A  [1..n_2]                 (2) (3)
                                                          A/2 [2 4 5 7]              A/2 [1 2 3 6]                   (4)
                                                            L [2 3 5 7]                R [1 2 3 6]                 (5) (6)
                                                           L [2 3 5 7 ∞]              R [1 2 3 6 ∞]                  (7)

                                                                             A  []
                                                                             k ->
                                                                               |
                                                                               <?
                                                                          /         \
                                                                        i ->   :   j ->
                                                                    L []               R []                          (8)
** 数学基础知识 appendix mathematical background
*** 求和 summations
* ABANDON 编程珠玑 programming pearls
* READED 程序员的修炼之道 the pragmatic programmer, from journeyman to master
  CLOSED: [2017-02-19 日 17:48]
** 注重实效的哲学 21 pragmatic philosophy 18
*** 我的源码给猫吃了 the cat ate my source code
    提供各种选择 不要找蹩脚的借口 *provide options  don't make lame excuses*
*** 软件的熵 software entropy
    - 无序增长 软件腐烂 software rot
      未实现注释 comment out
      虚设的数据 dummy data
    - 不要容忍破窗户 *don't live with broken windows*
*** 石头汤和青蛙 stone soup and boiled frogs
    - 做变化的催化剂 *be a catalyst for change*
      开发一个产品 让大家聚集在你的周围
    - 记住大背景 *remember the big picture*
      沸水煮青蛙            跳出来
      先放在冷水 慢慢加热    被煮熟
      观察周围发生的事情 不只是你自己在做的事
*** 足够好的软件 good-enough software
    - 让你的用户参与权衡 involve your users in the trade-off
      使质量成为需求问题 *make quality a requirements issue*
    - 知道何时止步 know when to stop
      不要因为过度修饰和过于求精而损坏完好的程序
*** 你的知识资产 your kownledge portfolio
    - 知识 是 有时效的资产 expiring asset
      定期为你的知识资产投资 *invest regularly in your knowledge portfolio*
    - 批判地分析你读到的和听到的 *critically analyze what you read and hear*
      是否受到媒体炒作的影响
      警惕提供唯一答案的狂热者
*** 交流 communicate
    - 你说什么和你怎么说同样重要 *it's both what you say and the way you say it*
      - 知道你要说什么 know what you want to say
        写出大纲 构思情节
      - 了解你的听众 know your audience
        技术 还是 兴趣
      - 选择时机 choose your moment
        找到刚刚因为丢失源码而遭到老板批评的经理 向他介绍关于源码仓库的构想
      - 选择风格 choose a style
        简报 书面文档 电子邮件
      - 让文档美观 make it look good
      - 回复他人 be a listener
      - Email communication
** 注重实效的途径 45 a pragmatic approach 43
*** 重复的危害 the evil of duplication
    系统中每一项知识必须具有单一 无歧义 权威的表示
    Every piece of knowledge must have a single, unambiguous, authoritative representation within a system.

    不要重复你自己 *DRY-don't repeat yourself*

    - 重复是怎样发生的 how does duplication arise
      - 强加的重复 imposed duplication
        重复信息的文档 documents that contain duplicated information
          编写简单的过滤器 代码生成器
          write a simple filter or code generator
        重复代码中的信息 documents that duplicate information in the code
          把低级的知识放在代码中 把注释保留给其他的高级说明
          keep the low-level knowledge in the code where it belongs, and reserve The comments for other, high-level explanations.
        不同平台 不同编程语言 库 开发环境 Multiple target platforms each require their own programming languages, libraries, and development environments
          客户修改它们的规范时 测试套件自动改变
          When the client amended their specification, the test suite changed automatically
          编程环境强制重复 c/c++/java 头文件 命名重复
          Many languages impose considerable duplication in the source
      - 无意的重复 inadvertent duplication
          有时 无意的重复来源于设计上的错误
          Sometimes, duplication comes about as the result of mistakes in the design.

          当我们拥有互相依赖的元素时 会出现一种不显而易见的不规范数据
          There is a slightly less obvious kind of unnormalized data that occurs when we have multiple data elements that are mutually dependent
            class Line {
｀            public:
              Point start; Point end; double length; // change one of the points and the length changes. It's better to make the length a calculated field
            };
      - 无耐性的重复 impatient duplication
          开发者的懒惰 拷贝修改源码 项目重新构建
          shortcuts make for long delays
      - 开发者之间的重复 interdeveloper duplication
          让复用 变得容易 make it easy to reuse
*** 正交性 Orthogonality
    当任何系统各组间互相高度依赖时 就不再有局部修正这样的事情
    消除无关事物之间的影响 Eliminate Effects Between Unrelated Things
    模块化 modular  基于组件 component-based
    分层抽象 a level of abstraction  底层实现 underlying implementation
**** 提高生产率 Gain Productivity
     与编写单个大块代码相比 编写多个相对较小的自足的组件更为容易
**** 降低风险 Redu ce Risk
     隔离 测试 避免供应商绑定
**** 测试 testing
***** 单元测试 unit test
      每个模块都拥有自己的内建在代码中的单元测试
      在构建中自动运行
**** 编码 coding
***** 代码保持解耦 keep your code decoupled
      不暴露任何事情 不依赖其他实现的模块
***** 避免使用全局数据 avoid global data
***** 避免编写相似的函数 重构
*** 可撤销性 reversibility
**** 要实现一种东西 总有不止一种方法
**** 关键决策不容易撤销
     一旦决定使用供应商数据库 特定的部署模型 将受制于无法撤销的动作进程
**** 不存在最终决策 there are no final decisions
**** 灵活的架构 flexible architecture
     平台移植 系统部署
     把需求写入元数据 自动添加 自动去除
*** 曳光弹 tracer bullets
**** 用曳光弹找到目标 use tracer bullet to find the target
     曳光弹与常规弹药交错装在弹药带上
     发射时 在枪与击中的地方之间留下一条烟火踪迹
     如果曳光弹击中目标 那么常规子弹也会击中目标
**** 从代码出发 我们要找到某种东西 能快速 直观 可重复的从需求出发 满足系统某个方面的要求
     开发复杂的用c编写的数据库项目
       许多未知因素和许多不同的环境 没有人清楚gui该怎样工作
     开发前端框架结构
       用来检查ui是否能够与库交互 以及序列化和解序列化
**** 曳光代码并非用过就仍的代码
     它含有任何一段产品代码都拥有的完整的错误检查 结构 文档 以及自查
     一旦各组件实现乐端到端的连接 就可以检查你离目标还有多远 必要情况下进行调整
**** 原型与便笺 prototypes and post-it notes
     : 为了学习而制作原型 prototype to learn
     - 原型用于测试项目的一个或多个具体方面
       任何带有风险的 以前没有试过的 对于最终系统极端关键 未被证明的 实验性的事物
       架构 系统新功能 外部数据 三方组件 性能问题 用户界面
     - 原型制作应忽略
       正确性 完整性 健壮性 风格
     - 用户界面的原型可以是白板上的图形 或是用绘图程序的界面构建器的无功能模型
     - 制作架构原型
       主要组件得到良好定义
       主要组建间的协作
       耦合最小化
       是否重复
       接口各项约束是否可接受
     - 当原型不再是用过就扔的代码 我们将不再使用原型
**** 领域语言 domain languages
     : 靠近问题 领域编程
     : program cloase to the problem domain
     - 实现小型语言 implementing a mini-language
       数据语言产生某种形式的数据结构给应用使用 这些语言表示配置信息
       data languages produce some from of data structure used by an application. these languages are often used to represent configuration inform action
     - 扩展已有的语言(与python集成在一起)
       把高级命令语言直接嵌入你的应用 通过改变应用读取的脚本 改变应用的行为
       it's common to embed high-level imperative languages directly into your application,
       you can change your application's behaveior by changeing the scripts it reads, all without compiling
**** 估算 estimating
     : 估算， 可避免发生意外
     : estimate to avoid surprises
     : 通过代码对进度表进行迭代
     : iterate the schedule with the code
     - 估算时要考虑的内容
       多准确才足够准确 how accurate is accurate enough
       估算来自哪里 where do estimates come from
       理解提问内容  understand what's being asked
       建立系统的模型 build a model of the system
     - 在被要求进行估算时
       我等会儿回答你
       I'll get back to you
** 基本工具 the basic tools
*** 纯文本的威力 the power of plain text
    : 用纯文本保存知识
    : keep knowledge in plain text
    保证不过时 insurance against obsolescence
    可读性 human readable
    unix哲学 each small sharp tools intended to do one thing well. when a system crashes, you may be faced with only a minimal envionment to restore it(use text)
*** shell游戏 shell games
    : 利用命令shell的力量
    : use the power of command shells
    去熟悉shell 你会发现自己的生产率迅速提高  gain familiarity with the shell, and you'll find your productivity soaring
    在windows下使用shell  using unix tools under windows (cygwin)
*** 强力编辑 power editing
    : 用好一种编辑器
    : use a single editor well
    选一种编辑器 彻底了解它 并将其用于所有的编辑任务  choose an editor, know it thoughly, and use it for all editiong tasks
    编译器特性  editor features
      可配置 可扩展 可编程
      configurable extensible programmable
      语法突显 自动完成 自动缩进 初始代码或模版 与帮助系统挂接 类IDE特性(编译 调试 等等)
      syntax highlighting  auto-completion  auto-indentation  initial code or document template  tie-in to help systems  IDE-like features(compile debug and so on)
*** 源码控制 source code control
    : 总是使用源码控制
    : always use source code control
    一个项目级的时间机器 你总能够返回软件的前一版本 维护的源码保存在某个中央仓库(repository)中
    在指定的时间 自动从仓库中取出源码块 进行构建测试
*** 调试 debugging
    : 要修正问题 而不是发出指责
    : fix the problem, not the blame
    : 不要恐慌
    : don't panic
    : 不要假定 要证明
    : don't assume it-prove it
    - 调试的思维方式 a debugging mindset
      要总是设法找出问题的根源 而不只是问题的特定表现  always try to discover the root cause of a problem, not jest this particular appearance of it
      确保能够在成功编译的代码上工作
      需要和报告bug的用户多交流
      测试边界条件  test both boundary conditions and realistic end-user usage patterns
    - 测试策略 denbugging strategies
      - 再现bug  bug reproduction
        通过一条命令再现bug
        强迫自己隔离显示出bug的环境
      - 使你的数据可视化 visualize your data
        使用数据及其所有的相互关系可视化的调试器 you can gain a much deeper insight into your data by using a debugger
        自己进行可视化 纸和笔
        单步跟踪 让bug自己跳出来
      - select没有问题  select isn't broken
        新版本升级
        os很可能没有问题 数据库也很可能情况良好
        在提交报告之前 必须先消除你代码中的bug
*** 文本操纵 text manipulation
    : 学习一种文本操纵语言  learn a text manipulation language
    - 编写perl程序
      分析c c++ schema makefile源文件 数据库维护 java属性访问 测试数据生成 写书 生成web文档
*** 代码生成器 code generators
    : 编写能编写代码的代码 write code that writes code
    - 被动代码生成器 passive code generators
      - 创建新的源文件
        模版 源码指示 版权说明 标准注释块...
      - 编程语言之间进行一次性转换
    - 主动代码生成器 active code generators
      - 根据某项知识的表示形式 转换为你的应用需要的所有形式(yasnippet)
** 注重实效的偏执 pragmatic paranoia
   : 你不可能写出完美的软件 you can't write perfect software
*** 按合约设计 design by contract
    - java基类
      子类必须要能通过基类的接口使用 而使用者无需知道其区别
      在基类中合约一次 子类可以(可选的)接受和保证至少喝父类一样多
    - 断言 assertions
      断言式编程不能继承
    - 给软件增加前置条件和后置条件
*** 断言式编程 assertive programming
    : 如果他不可能发生 用断言确保他不会发生 if it can't happen, use assertions to ensure that it won't
    if增加条件判断
    try catch错误类型
    不要让调试改变了被调试系统的行为
*** 何时使用异常 when to use exceptions
    : 将异常用于异常问题 use exceptions for exceptional problems
*** 释放资源 how to balance resources
    : 有始有终 finish what you start
** 弯曲或折断 bend or break
*** 解耦与得墨儿法则 decoupling and the law of demeter
    : 使模块之间的耦合至最少 minimize coupling between modules
**** TODO 大型系统中如何保持模块物理解耦又能高度依赖
     逻辑设计和物理设计必须协同进行
*** 元程序设计 metaprogramming
    : 要配置 不要集成  configure, don't intergrate
    - 用元数据描述应用的配置选项
      调谐参数 用户偏好 安装目录
    - 元数据对应用进行描述的数据
      应该怎样运行 应该使用什么资源...
    : 将抽象放进代码 细节放进元数据  put abstractions in code, details in metadata
    - 创建更强壮的抽象设计 推迟细节处理
    - 无需重新编译 就可以进行定制
    : 不要编写渡渡鸟代码
    - 元数据使你的代码获得他应有的适应性与灵活性
      不要让你的代码走向灭亡
*** 时间耦合 temporal coupling
    : 分析工作流 改善并发性  analyze workflow to improve concurrency
    : 总是为并发性进行设计  always design for concurrency
    - 兼容并发 考虑解除任何次序上的依赖
      - UML活动图  UMLacticity diagram
        - 工作流分析 workflow
          - 步骤 1-12 顺序执行 的调制冰镇果汁朗姆酒 进行并发性调整 ---中文pdf第172页
        - 架构 architecture
          - 数据库分布式应用 ---中文pdf第173页
      - 部署 deployment
        - 并发与不并发间进行选择
          单机  standlone
          客户-服务器  client-server
          动态系统架构
*** 视图 just a view
    : 使视图与模型分离  separate vviews from models
    - 三层架构 model-view-controller
      模型    表示目标对象的抽象数据模型
      视图    解释模型的方式
      控制器  控制视图 并向模型提供新数据
*** 黑板 blackboards
    : 用黑板协调工作流  use blackboards to coordinate workflow
    - 案情追踪
      不同地区 拥有不同经验 侦探们
      在黑板上 通过图片 判断 物证
      进行协同破案
    - 黑板方式编程消除了对太多接口的需要
      - 接受并处理抵押或贷款申请
        封装法律需求规则引擎
        数据到达次序无关紧要
        任何规则集输出到黑板
        并触发更为适用的规则
** 当你编码时 while you are coding
*** 靠巧合编程 programming by conincidence
    : 不要靠巧合编程 don't programming by conincidence
    - 黑白战争片
      灌木丛的士兵试图通过雷区
      刺刺这里 戳戳那里 最后确信这个地方是安全的
      于是直起身向前走去 结果被炸成了片
    - 确认实现并非偶然
*** 算法速率 algorithm speed
    : 估算你的算法的阶 estimate the order of your algorithms
    : 测试你的估算 test your estimates
    - O()表示法
      处理近似计算的一种数学途径
      a mathematical way of dealing with approximations
    - 一些常用算法的近似表示
      速率对比 runtimes of various algorithms (英文第185页)
      O(1)         常量型(constant)              数组访问 简单语句
      O(n)         线性型(linear)                简单循环(simple loop) 顺序查找(swquential search)
      O(m*n)       平方型(square law)            嵌套循环(nested loops) 冒泡排序(bubble sort) 外循环(outer loop)
      O(n^2)                                                          选择、插入排序(selection and insertion sorts) 内循环(inner loop)
      O(lg(n)      对数型(logarithmic)           二分法(binary chop) 二分查找(binary search) 每次循环把事物一分为二(halvs the set of thing it considers each time around the loop)
      O(In(n))                                                     有序列表二分查找(a binary search of a sorted list) 遍历二叉树(traversing a binary tree) 查找机器字节第一个出现位置
      O(n*In(n))   比线性稍差(worse than linear)  分而治之(divide and conquer) 快速排序(quicksort) 堆排序(heapsort)
      O(c^3)       立方形(cubic)                 2n*n矩阵相乘(multiplication of 2n * n matrices)
      O(n!)        指数型(exponential)           事物的排列
      O(c^n)                                    组合(combinatoric) 旅行商问题(traveling salesman problem) 集合划分(set partitioning)
*** 重构 refactoring
    : 早重构 长重构 refactor early, refactor often
    - 园艺
      软件像园艺
      根据最初的计划在花园里种植许多花木
      有些茁壮生长 有些注定要成为堆肥
      你会改变蜘蛛的相对位置 以有效利用光影 风雨交互作用
      过度生长植株会被裁剪 颜色不协调会被移到从美学上更怡人的地方
      你拔除野草 并给需要额外照料的植株施肥
    - 何时进行重构
      重复 非正交设计 过时的知识 性能
    - 怎样进行重构
      不要试图在重构的同时增加功能
      在开始重构之前 确保你拥有良好的测试
*** 易于测试的代码 code that's easy to test
    : 为测试而设计 design to test
    : 测试你的软件 否则你的用户就得测试 test your software, or your users will
    - 针对合约进行测试 test against contract
      广泛的测试用例 边界条件 允诺的功能
      全面测试模块内的子组件 再测试模块 确保模块没有暴露子组件
      设计模块时 同时设计其公约 也设计测试该合约的代码
    - 编写单元测试 writing unit tests
      模块的单元测试潜入模块自身 或把每个测试都放进一个易于找到的目录
    - 使用测试装备 using test harnesses
      - Junit 被设计成可组合的 把任意多的测试加到这个套件中
      - 测试装备应该具有的功能
        指定设置与清理的标准途径 a standard way to specify setup and cleanup
        选择个别或所有可用的测试方法 a method for selecting individual tests or all available tests
        分析输出是否是预期结果 a means of analyzing output for expected(or unexpected) results
        标准化故障形式 a standardlized from of failure reporting
*** 邪恶的向导 evil wizards
    : 不要使用你不理解的向导代码 don't use wizard code you don't understand
    - 向导
      向导会为你生成骨架代码 然后就没有然后了
      如果他们制作的代码不完全正确 或者事情变了 需要修改代码 就只能靠你自己了
** 在项目开始之前 before the project
*** 需求之坑 the requirements pit
    : 不要搜集需求-要挖掘它们 don't gather requirements-dig for them
    - 把政策的文档与需求的文档分开 政策可以成为应用中的元数据
    : 与用户一同工作 以像用户一样思考 work with a user to think like a user
    - 建立需求文档 (用例样本 中文第227页 英文第208页)
    : 抽象比细节要活得更长久 abstractions live longer than details
    - 不要规定多度 看远些
    : 使用项目词汇表 use a project glossary
    - 维护词汇表
      一旦讨论需求 领域专家就会使用对他们有特定含义的术语
*** 解开不可能解开的谜题 solving impossible puzzles
    : 不要在盒子外面思考-要找到盒子 don't think outside the box-find the box
    - 盒子约束
      找到约束的边界
    - 戈尔迪斯结
      如何解开死结
      用剑砍断
*** 等你准备好 not until you're ready
    : 倾听反复出现的顾虑-等你准备好再开始 listen to nagging doubts-start when you're ready
    - 知道何时开始 何时等待
      跳水运动员站在高台 等待完美时刻起跳
      指挥官站在乐队前面 手臂举起 直到他感觉到某个瞬间开始演奏
*** 规范陷阱 the specification trap
    : 对有些事情"做"胜于"描述" some things are better done than described
    - 客户需求
      一般客户可能无法准确的说出他们所需的系统
      他们可能在你制作的200页文档上签字
      但你可以确信 一旦他们看到运行的系统
      你就会被各种变更要求淹没
*** 圆圈与箭头 circles and arrows
    : 不要做形式方法的奴隶 don't be a slave to formal methods
    - 海难
      在许多已沉没项目的大海里漂流
      新的技术时尚像漂来的木头 你会费力地游过去
      但到最后 不管漂浮物有多好 开发者仍然漫无目的的漂浮着
    - 不要盲目采用任何技术 而不把它放进你的开发实践和能力的语境中
** 注重实效的项目 pragmatic projects
*** 注重实效的团队 pragmatic teams
    : 围绕功能 而不是工作职务进行组织 organize around functionality, not job functions
    - 按照功能划分团队
      分成小团队 分别负责最终系统特定方面
      团队按个人的能力 在内部自行进行组织
    - 构造和部署使项目中苦差事自动化工具
      指定工具构建员
      制作 makefile shell脚本 编辑器模版 实用程序
*** 无处不在的自动化 ubiquitous automation
    : 不要使用手工流程 don't use manual procedures
    - T 型福特车
      老型福特车说明书有两页多 遵循一串指令汽车还不一定会启动
      构建启动器和喷油器 只需转动钥匙就能启动了
    - 使用 cron
      完成任何 unattended automatically 的事情
      自动备份 夜间构建 网站维护 ...
    - 使用 makefile
      项目编译脚本化 it is a scripted, automatic procedure
      增加挂钩 add in hooks to generate code
      运行回归测试 run regression tests automatically
      代码生成
        利用 make 的依赖分析机制 exploit make's dependency analysis mechanism to make this process easy
        给 makefile 增加规则 根据其他源 自动生成文件 it's pretty simple matter to add rules to a makefile to generate a file some other source automatically
      构建自动化 build automation
        仓库取源码 从头构建项目 运行规定测试
    - 使用 perl
      快速开发自制工具
*** 无情的测试 ruthless testing
    : 早测试 常测试 自动测试
    : 通过全部测试 编码才算成功
    : 通过蓄意破坏测试你的数据
    : 测试状态覆盖 而不是代码覆盖 test state coverage, not code coverage
    - 先通过单元测试 在进行集成测试
    - 资源 可用性测试
    - 回归测试
      对增加的代码与旧代码进行对比
      确保开发新代码时没有损失任何领地
    - 大量数据进行测试
    - 一次 bug 抓到一次 就应该在每次测试中检查那个特定的 bug
*** 全都是写 it's all writing
    : 把英语当作又一种编程语言 treat english as just another programming language
    - 内部文档
      - 注释
        简单的模块级头注释
        重要类型声明
      - 变量名
        有意义
        不要误导人
      - 修订历史
    - 外部文档
      - 使用标记语言(DcoBook HTML LaTex ...) 并可以用 perl 进行格式化
      - 放上日期或版本号 留下文档撰写者
*** 极大的期望 great expectations
    : 温和的超出用户的期望 gently exceed your users' expectations
    - 额外的一英里
      用一点外努力 给你的用户带来惊喜
*** 傲慢与偏见  pride and prejudice
    : 在你的作品上签名 sign your work
    - 尊重他人的代码
      黄金法则 do unto others as you would have them do unto you
    - 在大型项目中匿名
* READING 计算机程序设计艺术 the art of computer program
** READING 第一卷
   :PROPERTIES:
   :COLUMNS:  %20ITEM %50DISCRIBE %50OVERVIEW %30MATHEMATIC
   :END:
*** 欧几里得算法 euclidean algorithm
    :PROPERTIES:
    :DISCRIBE:     给定两个正整数m和n 求它们最大公因子 能够同时整除m和n的最大正整数
    :OVERVIEW:     [[算法E的流程图]] [[算法E的流程表]]
    :MATHEMATIC:   [[算法E的集合论]]
    :END:
    - <<算法E的流程图>>
                         V------------------------------|
      E0.确保(m>=n)  ->  E1.求余数  ->  E2.余数为0?  -->  E3.减少
                                           |        N
                                           | Y
                                           V
    - <<算法E的流程表>>
      | step | purpose        | detail                       | m    | n    | r     | tag                                                        |
      |------+----------------+------------------------------+------+------+-------+------------------------------------------------------------|
      | E0   | ensure(m>=n)   | if(m < n) m <-> n            | m(n) | n(m) |       | .            [fn:input]                                    |
      | - E1 | find remainder | m % n = r (0 <= r < n)       | m    | n    | m % n | <<E1>>       [fn:definiteness] [fn:effectiveness]          |
      | - E2 | is it zero?    | if(r = 0) return n           |      | *n*    | r = 0 | terminate    [fn:finiteness]   [fn:output]    [fn:analyze] |
      | - E3 | reduce         | else m <- n, n <- r  goto E1 | n    | r    |       | [[E1]]                                                         |

    - <<算法E的集合论>>
      - template 1
                 *Q* -- *Ω*        (1) input x_0  -----------------------------E0
        *(1)*    /               (2) x_1 = f(x_0)  --------------------------E1
        -->  *I*      /          (3) if exist k>=0  f(x_k) = x_k = min Ω  ---E2
               \   / *(3)*           else goto (2)  -------------------------E3
            *(2)* \
               f(x_k)

        | elements            | Q                             | I                                      | Ω        | f                           |
        |---------------------+-------------------------------+----------------------------------------+----------+-----------------------------|
        | quadruple (Q I Ω f) | a set contain subsets I and Ω | x_0 = x  and  x_k+1 = f(x_k)  for k>=0 | f(q) = q | function from Q into itself |

      - template 2

        (m,n,0,1)  ->  (m,n,remainder of m divided by n,2)  ->  r = 0 ?  ->  (n)
           (1)                         (2)                               Y   (3)
                                        ^--         <--         --| N
                                           (n,r,r,1)    (m,n,r,3)
                                              (5)          (4)
        - <<f2:>>
          (1) f((m,n)) ------------------- E0
            (2) f(m,n,r,1) --------------- E1
              (3) f((n)) ----------------- E2 output
            (4) f(m,n,r,2) --------------- E2 loop (4) (5) (2)
            (5) f(m,n,p,3) --------------- E3

        | elements  | Q                                        | I     | Ω   | f  |
        |-----------+------------------------------------------+-------+-----+----|
        | (Q I Ω f) | (n) (m, n) (m,n,r,1) (m,n,r,2) (m,n,p,3) | (m,n) | (n) | [[f2:]] |

      - *template 3*

        *one state of complutation*      *states of computation*      *instantiation A*      *E*
                                                                                            Y                  N
                    A              -->           A^*          -->        σ       ->    Q    - >   loop (σ, j)  -> (3)
              (xj  1≤ j≤ n)              (x1 x2 ... xn  n>=0)                         (1)  \   / Y
                                                                                            < -
                                                                                       | N
                                                                                       V

                                                              -->        θ       ->   (2)
                                                                      (0<=j<N)   Y

        - <<f3:>>
          (1) f(σ, j) = (σ,       a_j)  if θ_j does not occur in σ ------------------------------------E3
          (2) f(σ, j) = (α φ_j ω, b_j)  if α is the shortest possible string for which σ = α θ_j ω ----E2 output
          (3) f(σ, N) = (σ,       N  )  ---------------------------------------------------------------E1

        | elements        | A                       | A^*                     | N                     |
        |-----------------+-------------------------+-------------------------+-----------------------|
        | A A^* N Q I Ω f | a finite set of letters | set of all strings on A | a nonnegative integer |

        | elements | Q                                    | I                      | Ω                      | f   |
        |----------+--------------------------------------+------------------------+------------------------+-----|
        | Q I Ω f  | set of all (σ, j) *[fn:restriction_Q]* | subset of Q with j = 0 | subset of Q with j = N | [[f3:]] |

        | elements  | σ | θ | α | ω        | j                       |
        |-----------+---+---+---+----------+-------------------------|
        | σ θ α ω j | m | n | r | constant | the step of computation |

[fn:finiteness]     有限性 一个算法在有限步骤后必然要中止
                    算法E中: r<n 有限次计算后 n的值逐渐减少 最终r=0 算法中止并给出最终解n
[fn:definiteness]   确定性 算法每个步骤必须精确定义
                    算法E中: 确切的理解m%n 执行E1时m和n都为正整数
[fn:input]          输入 一个算法有零个或多个输入
                    算法E中: 输入为m和n
[fn:output]         输出 一个算法有一个或多个输出
                    算法E中: 输出为n
[fn:effectiveness]  能行性 (或称有效的) 原则上每个步骤要充分描述 并在有效的时间内精确完成
                    算法E中: 如果m和n涉及的是无穷小数 同样的运算就不是可行的
[fn:analyze]        算法分析 给定一个算法 确定它的性能特征
                    算法E中: 执行的平均次数Tn近似于(12(In 2)/π^2)In n [[详情]]
*[fn:restriction_Q]*  对Q添加能行性的描述:
                    1) σ in A^*
                    2) j is a integer(0 ≤ and ≤ N)

*** 数学准备 mathematical preliminaries
**** 数学归纳法 mathematical induction
     :PROPERTIES:
     :DISCRIBE:     给定公式 如何用数学归纳法证明
     :OVERVIEW:     [[算法I的流程图]] [[古代等式序列]] [[斐波那契数列]] [[扩充欧几里得算法]] [[如何真正了解一种算法]]
     :MATHEMATIC:   [[等式归纳]] [[递归归纳]] [[断言归纳]]
     :END:
     - <<算法I的流程图>>
                      v--------------------------|
       *I1*.证明P(1) -> *I2*.k=n? -> *I3*.证明P(k+1) -> *I4*.k加1
                      v 是    否
     - <<古代等式序列>>

       | *formula*                                              |   | *diagram* | 1 | 2 | 3 | ... | n | n+1 |
       |------------------------------------------------------+---+---------+---+---+---+-----+---+-----|
       | 1 = 1^2                                      <<(1)>> |   | 1       | + | + | + |     | + | +   |
       | 1 + 3 = 2^2                                          |   | 2       | + | + | + |     | n | +   |
       | 1 + 3 + 5 =3^2                                       |   | 3       | + | + | + |     | n | +   |
       | ...                                                  |   | ...     |   |   |   | ... |   |     |
       | 1 + 3 + ... + (2n-1) = n^2                   <<(2)>> |   | n       | + | + | + |     | + | +   |
       | 1 + 3 + ... + (2n-1) + (2n+1) = (n+1)^2      <<(3)>> |   | n+1     | + | + | + |     | + | +   |

       | step | condition  | describe                        | detail | next step |
       |------+------------+---------------------------------+--------+-----------|
       | I1   | set k <- 1 | P(1) is true, since 1 = 1^2     | [[(1)]]    | I3        |
       | -I2  |            |                                 |        | output    |
       | I3   | let k <- n | if P(n) is true                 | [[(2)]]    | I4        |
       | I4   | then k + 1 | then proves P(n+1) is also true | [[(3)]]    | I2        |

       - <<等式归纳>>
         1  2  3  ... n                 n+1
          \   get n  /
         | 1 is true?
                        \ n+1 is true? /

     - <<斐波那契数列>>

       条件:     对于数列  0 1 1 2 3 5 8 13 ...
                    存在  Φ = (1+sqrt(5))/2

       证明:     F(n) <= Φ^(n-1)

       - <<递归归纳>>
       | step  | F        | Φ             |                                      |
       |-------+----------+---------------+--------------------------------------|
       | I1    | F(1) = 0 | 1             | true                                 |
       |       | F(2) = 1 | 1.6           | true                                 |
       | I3-I4 | F(n-1)   | Φ^(n-2)       | if true                              |
       |       | F(n)     | Φ^(n-1)       | if true                              |
       |       | F(n+1)   | Φ^(n-2)x(1+Φ) | proof valid     F(n-1) + F(n)        |
       | I2    | F(n+1)   | Φ(n)          | true            because  1 + Φ = Φ^2 |

       - <<递归归纳>>
         Φ     Φ   Φ   Φ        Φ             Φ        Φ
         1     2   3   5  ...  n-1            n       n+1
         | 1 is true?
                                  \ if true /   ->   true?
     - <<扩充欧几里得算法>>

       条件:     给定两个正整数 m 和 n
       证明:     计算它们的最大公因子 d
                 和两个整数 a 和 b
                 使得 am + bn = d

                                     A6
                            v-----------------|
       start   -   E1   -   E2   -   E3   -   E4
               A1       A2       A3   \   A5
                                     A4\
                                       stop

       | operation | assertion | describe                              | detail          |
       |-----------+-----------+---------------------------------------+-----------------|
       |           | A1        | m > 0    n > 0    (m n is integer)    | limit           |
       | E1        |           | a <- 0    a' <- 1    c <- m           | initialize      |
       |           |           | b <- 1    b' <- 0    d <- n           |                 |
       |           | A2        | c = m > 0     d = n > 0               |                 |
       |           |           | a = b' > 0    a' = b = 1              |                 |
       | E2        |           | q <- quotient (c / d)                 | divide          |
       |           |           | r <- remainder(c / d)                 |                 |
       |           | A3        | am + bn = d    a'm + b'n = c = qd + r |                 |
       |           |           | 0 < = r < d    gcd(c, d) = gcd(m, n)  | [fn:gcd]        |
       | E3        |           | r = 0?                                | remainder zero? |
       |           | -A4       | am + bn = d = gcd(m, n)               | output          |
       |           | -A5       | am + bn = d    a'm + b'n = c = qd + r |                 |
       |           |           | 0 < = r < d    gcd(c, d) = gcd(m, n)  |                 |
       | -E4       |           | c <- d    d <- r                      | recycle         |
       |           |           | t <- a'   a' <- a    a <- t - qa      |                 |
       |           |           | t <-b'    b' <- b    b <- t - qb      |                 |
       |           | -A6       | am + bn = d    a'm + b'n = c    d > 0 |                 |
       |           |           | am + bn = d = gcd(m, n)               |                 |

       - <<断言归纳>>

         - operator
           m = qn + d
           c = qd + d  <-  d = am + bn
           c = (aq + 1)m + (bq + 1)n
           c = a'm + b'n  ->  a' = aq + 1 and b' = bq + 1

         - assertion
           c = a'm + b'n
           d = am  + bn

         - induction
           如果在执行一个框的操作之前 引向本框的任意一个箭头所附的断言为真
           if any one of assertions on the arrows leading into box is true before the operation in that box is performed
           则在该操作之后离开本框的有关箭头上的断言也为真
           then all of the assertions on the arrows leading away from the box are true after the operation

           A2 (A6 (A3 (A4 A5)))
     - <<如何真正了解一种算法>>

                               the understanding of the theory of a routine
             may be greatly aided by providing, at the time of construction
                  one or two statements concerning the state of the machine
                                                   at well chosen point ...

                                                    编写程序的时候 在合适的地方
                                                   提供一两个涉及机器状态的命题
                                          可能会大大有助于对对程序理论的理解 ...

                              in the extreme form of the theoretical method
             a watertight mathematical proof is provided for the assertions

                                                               在理论方法一端
                                                     对于断言提供严密的数学证明

                                  in the extreme of the experimental method
           the routine is tried out in the machine with a variety of inital
       conditions and is pronounced fit if the assertions hold in each case

                                                               在实验方法一端
                                         应用各种各样的初始条件在机器上对程序试验
                                              如果每种情况下断言都成立则宣告成功

                                           both methods have their weakness
                                                            两种方法都有其弱点

                                       -- A. M. TURING | Programming Manual

[fn:gcd] 最大公因數（greatest common divisor)
**** 数 幂和对数 numbers powers and logarithms
     - integers
       ..., -3, -2, -1, 0, 1, 2, 3 ,...
     - rational number
       p / q
       radio(quotient) of two integers
     - real number
       x =   n   +   0.d₁d₂d₃...
          integers   a digit between 0 and 9
       π = 3.1415926...  the radio of circumference to diameter in a circle
       φ = 1.6180339...  the golden radio(1 + √5)/2
     - complex numbers
       z = x + iy
       x and y is real number
       i² = -1
       $$|z| = √{x²+y²}$$
       \macr{z}z = x² + y² = |z|²  % the complex conjugate of z
     - logarithm
       bˣ = y
       x = log_b y = b^{log_b x} = log_b (bˣ)
       log (xy) = log_b x + log_b y  (x > 0, y > 0)
       log_b cʸ = y log_b c  (x > 0)
       lgₓ = log₂ x
       log_c x = log_b x / log_b c
       - natural logarithms
         In x = logₑ x  (e = 2.71828...)
         [[~/Desktop/In x.png]]
         eʳ (the interest for 1 dollar)
**** 和与积 sums and products
     
* READING 编译原理 compilers principles, techniques & tools
** 第一章 引论  chapter 1 introduction  17 24
   介绍设计和实现编译器的方法  the book is about how to design and implement compilers
*** 语言处理器  language processors  17 24
    ------------- 编译器 -------------    ------------------- 解释器 ---------------
                  源程序                       源程序     >
              source program              source program      [[解释器]]     >     输出
                    V                                      interpreter       output
                  [[编译器]]                        输入      >
                 Compiler                     input
                    V
     输入    >    [[目标程序]]    >    输出
    input     target program    output

    ----------------------------------------------------------------------------- [[java混合编译器]] -------------------------------------------------------------------------------
                                                                                hybird compiler
           源程序
       source program            (1) 源程序     >  (1) [[预处理器]]   >     (1) 经过预处理的源程序
       (1)   v                 source program     preprocessor      modified source program
           [[翻译器]]                                                              v
         translator                                                     (2) 编译器    >      (2) 目标汇编程序       >  (2) [[汇编器]]   >      (2) 可重定位机器码
             v            (2)                                              compiler     target assembly program      assembler      relocatable machine code
          [[中间程序]]          >                    (3)                                                                                             v
    intermediate program            虚拟机        >    输出                          (3) 库文件        (3) 其他可重定位机器码文件     >    (3) [[链接器]]   [[加载器]]   >     (3) 目标机器代码
                               virtual machine       output                       library files     relocalable object files             linker  loader       taget machine code
            输入            >
           input

    - <<编译器>>
      阅读某一种语言(源程序)编写的程序 并翻译成一个等价的 另一种语言(目标程序)编写的程序
      a compiler is a program that can read a program in one language - source program -
      and translate into an equivalent program in another language - the target language -
      - <<目标程序>>
        如果是一个可执行的机器语言程序 那么它可以被用户调用 处理 并产生输出
        If the target program is an executable machine-language program, it can
        then be called by the user to process inputs and produce outputs
    - <<解释器>>
      从用户的角度来看 解释器直接利用用户提供的输入执行源程序中指定的操作
      an interpreter appears to directly execute the operations specifled
      in the source program on inputs supplied by the user
    - <<混合编译器>>
      结合了编译和解释的过程
      combine compilation and interpretation
      - <<翻译器>>
        源程序首先被翻译成被称为 字节码 的中间表示形式
        source program may first be compiled into an intermediate form called /bytecodes/
        - <<中间程序>>
          可以在任何虚拟机上运行的字节码
          bytecodes compiled on one machine can
        - <<预处理器>>
          一个源程序可能被分割成多个模块存放于独立的文件中 预处理器将这些程序聚合在一起 还负责解读宏的缩写形式
          A source program may be divided into modules stored in separate files.
          The task of collecting the source program is sometimes entrusted to a separate program, called a preprocessor.
          The preprocessor may also expand shorthands, called macros, into source language statements.
        - <<汇编器>>
          对编译器产生的 目标汇编程序 进行处理  生成 可重定位的机器代码
          It translates from the assembly language to machine code. This machine code is relocatable.
        - <<链接器>>
          把 重定位文件的 和 库文件的 可重定位机器码 连接到一起
          解决外部内存寻址问题
          the relocatable machine code may have to be linked together with other relocatable object files and library files into the code that actually runs on the machine.
          The linker resolves external memory addresses, where the code in one file may refer to a location in another file.
        - <<加载器>>
          把所有组合在一起的 机器代码 在内存中执行
          The loader then puts together all of the executable object files into memory for execution.

[fn:chapter_1] 1.1.4 编译器使用C语言作为目标语言有什么好处？
               For the C language there are many compilers available that compile to almost every hardware.
*** 一个编译器的结构 the structure of a compiler
**** 编译器各个步骤 phases of a compiler
                 字符流 character stream
                            v
               (词法分析器 lexical analyzer)
                    符号流 taken stream
                            v
                 语法分析 syntax analyzer
                    语法树 syntax tree
                            v
                 语义分析 semantic analyzer
                     语法树 syntax tree
                            v
          (中间代码生成器 intermediate code generator)
            中间表示形式 intermediate representation
                            v
     (机器无关代码优化器 machine-independent code optimizer)
            中间表示形式 intermediate representation
                            v
                 (代码生成器 code generator)
               目标机器语言 target-machine code
                            v
      (及其相关代码优化器 machine-dependent code optimizer)
               目标机器语言 target-machine code
**** 示例 example
     position = initial + rate * 60
**** 词法分析 lexical analysis
     <id, 1> <=> <id, 2> <+> <id, 3> <*> <60>
**** 语法分析 syntax analysis
     语法树 syntax tree
             <=>
            /   \
     <id, 1>     <+>
                /   \
         <id, 2>     <*>
                    /   \
             <id, 3>     <60>
**** 语义分析 semeantic analysis
     类型检查 type checking
     自动类型转换 coercion
     <60> -> inttofloat<60>
**** 中间代码生成 intermediate code generation
     - 三地址代码(类汇编语言) three-address code(assembly-like instructions)
       t1 = inttofloat(60)
       t2 = id3 * t1
       t3 = id2 + t2
       id1 = t3
**** 代码优化 code optimization
     - 改进中间代码
       t1 = id3 * 60.0
       id1 = id2 +t1
**** 代码生成 code generation
     - 映射机器代码 选择寄存器和内存位置
       使用寄存器R1和R2
       ————  ---  ——————————
       LDF   R2,  id3
       MULF  R2,  R2,  #60.0
       LDF   R1,  id2
       ADDF  R1,  R1,  R2
       STF   id1, R1
**** 符号表管理 symbol-table management
     - symbol table
          variable names     various attributes of name(type scope ...)
       1  position           ...
       2  initial            ...
       3  rate               ...
**** 将多个步骤组合成趟 the grouping of phases into passes
     - 每趟读入一个文件产生一个输出文件
       前端    词法分析 语法分析 语义分析 中间代码生成
       可选    代码优化
       后端    目标机器码生成
**** 编译器构造工具 compiler-construction tools
     语法分析器的生成器
     扫描器的生成器
     语法制导的翻译引擎
     代码生成器的生成器
* READING TLCL (bash & zsh)
** bash
*** shell
**** navigate
     pwd
     cd
     ls
     /
     .
     ..
     cd
     cd -
     cd ~user_name
     -a
**** file system
     ls ~ /usr
     ls -l
     ls -lt
     ls -lt --reverse
     -rw-r--r-- 1 root root 3576296 2007-04-03 11:05 Experience ubuntu.ogg
     less /etc/passwd
       list the directory contents
     file jpg
       determine its contents with file
     lrwxrwxrwx 1 root root 11 2007-08-11 07:34 libc.so.6 -> libc-2.6.so
       soft link
**** Manipulating files and directories
     : They are used for manipulating both files and directories
     cp – Copy files and directories
     mv – Move/rename files and directories
     mkdir – Create directories
     rm – Remove files and directories
     ln – Create hard and symbolic links
     : copy all the HTML files from one directory to another, but only copy files that do not exist in the destination directory
     cp -u *.html destination
     : unix glob
     - wildcards
       *                      Matches any characters
       ?                      Matches any single character
       [characters]           Matches any character that is a member of the set characters
       [!characters]          Matches any character that is not a member of the set characters
       : [[:class:]]          Matches any character that is a member of the specified class [[link]]
     - character classes <<link>> [[note]]
       [:alnum:]       Matches any alphanumeric character
       [:alpha:]       Matches any alphabetic character
       [:digit:]       Matches any numeral
       [:lower:]       Matches any lowercase letter
       [:upper:]       Matches any uppercase letter
     - wildcard examples
       *                          All files
       g*                         All file beginning with "g"
       b*.txt                     Any file beginning with "b" followed by any characters and ending with ".txt"
       Data???                    Any file beginning with "Data" followed by exactly three characters
       [abc]*                     Any file beginning with either an "a", a "b", or a "c"
       BACKUP.[0-9][0-9][0-9]     Any file beginning with "BACKUP." followed by exactly three numerals
       : [[:upper:]]*             Any file beginning with an uppercase letter
       [![:digit:]]*              Any file not beginning with a numeral
       *[[:lower:]123]            Any file ending with a lowercase letter or the numerals "1", "2", or "3"
     : NOTE
     - you should avoid using [A-Z] (or [0-9] [a-z] etc.) and use character classes instead. <<note>>
     : mkdir
     - mkdir dir1 dir2 dir3
     : cp
     - cp item... directory
     - cp options
       -a --archive      copy the files and directories and all of their attributes
       -i --ineractive   before overwriting an existing file, prompt the user for confirmation
       -r --recursive    recursively copy directories
       -u --update       only copy the file unexist in another directory
       -v --verbose      Display informative messages as the copy is performed
     - cp example
       cp file1 file2                               Copy file1 to file2. If file2 exists, it is overwritten with the contents of file1. If file2 does not exist, it is created.
       cp -i file1 file2                            Same as above, except that if file2 exists, the user is prompted before it is overwritten.
       cp file1 file2 dir1                          Copy file1 and file2 into directory dir1. dir1 must already exist.
       cp dir1/* dir2                               Using a wildcard, all the files in dir1 are copied into dir2. dir2 must already exist.
       cp -r dir1 dir2                              Copy the contents of directory dir1 to directory dir2. If directory dir2 does not exist, it is created and, after the copy, will
                                                    contain the same contents as directory dir1. If directory dir2 does exist, then directory dir1 (and its contents) will be copied dir2.
     : mv
     - file renaming
       mv item1 item2
     - file moving
       mv item... directory
     - mv options
       -i --interactive      like in cp options
       -u --update           like in cp options
       -v --verbose          like in cp options
     - mv examples
       mv file1 file2                               Move file1 to file2. If file2 exists, it is overwritten with the contents of files. If file2 does not exist, it is created. In
                                                    case, file1 ceases to exist.
       mv -i file1 file2                            Same as above, except that if file2 exists, the user is prompted before it is overwritten.
       mv file1 file2 dir1                          Move file1 and file2 into dirctory dir1. dir1 must already exist.
       mv dir1 dir2                                 if directory dir2 does not exist, create directory dir2 and move the contents of directory dir1 into dir2 and delete directory dir1.
                                                    if directory dir2 does exist, move directory dir1 (and its contents) into directory dir2.
     : rm
     - remove (delete)
       rm item...
     - rm options
       -i, --interactive                            If this option is not specified, rm will silently delete files.
       -r, --recursive                              the same as cp option
       -f, --force                                  Ignore nonexistent files and do not prompt. This overrides the --interactive option.
       -v, --verbose                                the same as cp option
     - rm example
       rm file1                          Delete file1 silently
       rm -i file1                       Same as above, except that the user is prompted for confirmation before the deletion is performed
       rm -r file1 dir1                  Delete file1 and dir1 and its contents.
       rm -rf file1 dir1                 Same as above, except that if either file1 or dir1 do not exist, rm will continue silently.
     : NOTE
     - Once you delete something with rm, it’s *gone* (can't get back)
     : TIP
     - Be particularly careful *with wildcards*, test the wildcard first with ls
       rm * .html
           ^       there is a addtion writespace
     : LN
     : LN hard link
     - create a hard link
       ln file link
     - A hard link is indistinguishable from the file itself
     - hard link example
       $ ln fun fun-hard
       $ ln fun dir1/fun-hard
       $ ln fun dir2/fun-hard
       $ ls -l
       drwxrwxr-x 2 me  me 4096 2008-01-14 16:17 dir1
       drwxrwxr-x 2 me  me 4096 2008-01-14 16:17 dir2
       -rw-r--r-- 4 me  me 1650 2008-01-10 16:33 fun
       -rw-r--r-- 4 me  me 1650 2008-01-10 16:33 fun-hard
                  ^ the number of hard link
       : TIP
       - how to confirms two files are the same.
         $ ls -li
         12353539 drwxrwxr-x 2 me  me 4096  2008-01-14  16:17  dir1
         12353540 drwxrwxr-x 2 me  me 4096  2008-01-14  16:17  dir2
         12353538 -rw-r--r-- 4 me  me 1650  2008-01-10  16:33  fun
         12353538 -rw-r--r-- 4 me  me 1650  2008-01-10  16:33  fun-hard
         ^ inode number: The system assigns a chain of disk blocks refer to the data part
           fun and fun-hard have the same inode number 12353538
           so they have the same data parts
     : NOTE
     - hard link have two important *limitations* (but symbolic link not have):
       1. A hard link cannot reference a file outside its own file system. This means a link may not reference a file that is not on the same disk partition as the link itself.
       2. A hard link may not reference a directory.
     : LN symbolic link
     - create a symbolic link
       ln -s item link          “item” is either a file or a directory
     - Symbolic links work by creating a special type of file that contains a text pointer to the referenced file or directory (like a Windows shortcut)
     - symbolic link example
       $ ln -s fun fun-sym
       $ ln -s ../fun dir1/fun-sym
       $ ls -l dir1
       -rw-r--r-- 4 me  me 1650 2008-01-10 16:33 fun-hard
       lrwxrwxrwx 1 me  me    6 2008-01-15 15:17 fun-sym -> ../fun
     : NOTE
     - if you write some something to the symbolic link, the referenced file is also written to
     - when you delete a symbolic link, only the link is deleted, not the file itself
     : RM symbol link
     : NOTE
     - most file operations are carried out on the link’s target, rm is an exception. When you delete a link, it is the link that is deleted, not the target.
**** use command
     : type
     - display the kind of command
     Where “command” is the name of the command you want to examin
     - example
       [me@linuxbox ~]$ type type
       type is a shell builtins
       [me@linuxbox ~]$ type ls
       ls is aliased to `ls --color=tty`
       [me@linuxbox ~]$ type cp
       cp is /bin/cp
     : which
     - display the position of an executable program
     - example
       [me@linuxbox ~]$ which ls
       /bin/ls
     : NOTE
     - which only works for executable programs, not builtins nor aliases that are substitutes for actual executable programs
       [me@linuxbox ~]$ which cd
       /usr/bin/which: no cd in
     : help
     - a build-in help facility for each shell builtins
     - example
       - Many executable programs support a “--help” option
         [me@linuxbox ~]$ mkdir --help
         Usage: mkdir [OPTION] DIRECTORY...
         Create ...
       - use it followed by the name of the shell builtin
         [me@linuxbox ~]$ help cd
         cd: cd [-L|-P] [dir]
         Change ...
         : NOTE
         : When square brackets appear in the description of a command’s syntax, they indicate optional items
         : A vertical bar character indicates mutually exclusive items
     : man
     - provide a formal piece of documentation called a manual or man page
     - example
       [me@linuxbox ~]$ man ls
       On most Linux systems, man uses less to display the manual page, so all of the familiar less commands work while displaying the page
     : apropos
     - It is also possible to search the list of man pages for possible matches based on a search term
     - example
       [me@linuxbox ~]$ apropos floppy
       create_floppy_devices (8)   - udev callout to create all possible
       ...
       : The first field in each line of output is the name of the man page
       : the second field shows the section
       : NOTE
       the man command with the “-k” option performs the exact same function as apropos
     : whatis
     - displays the name and a one line description of a man page matching a specified keyword
     : info
     - The GNU Project provides an alternative to man pages for their program
     : alias
     - create a command of our own using the alias command
       : NOTE
       : the alias command must be not used
       : Notice the structure of this command: alias name='string'
       [me@linuxbox ~]$ type foo
       bash: type: foo: not found
       [me@linuxbox ~]$ alias foo='cd /usr; ls; cd -'
       : to remove alias
       [me@linuxbox ~]$ unalias foo
**** redirect
     : stdout stdin stderr
     : Keeping with the Unix theme of “everything is a file"
     - stdout
       programs such as ls actually send their results to a special file called standard output
     - stderr
       their status messages to another file called standard error
     - stdin
       many programs take input from a facility called standard input
     : NOTE
     : By default, both standard output and standard error are linked to the screen, stdin attached to the keyboard

     : >
     : redirect stdout
     - To redirect standard output to another file besides the screen
       ls -l /usr/bin > ls-output.txt
     : NOTE
     : if have a error message while use stdout, it will rewrite the file and stopped
     - example
       [me@linuxbox ~]$ ls -l /bin/usr > ls-output.txt
       ls: cannot access /bin/usr: No such file or directory
       me@linuxbox ~]$ ls -l ls-output.txt
       -rw-rw-r-- 1 me   me    0 2008-02-01 15:08 ls-output.txt
     : >>
     : redirected output to a file instead of overwriting the file from beginning
     - example
       [me@linuxbox ~]$ ls -l /usr/bin >> ls-output.txt
       [me@linuxbox ~]$ ls -l /usr/bin >> ls-output.txt
       [me@linuxbox ~]$ ls -l /usr/bin >> ls-output.txt
       [me@linuxbox ~]$ ls -l ls-output.txt
       -rw-rw-r-- 1 me   me    503634 2008-02-01 15:45 ls-output.txt

     : redirect stderr
     - redirect stdout and stderr
       [me@linuxbox ~]$ ls -l /bin/usr > ls-output.txt 2>&1
       - file descriptor
         2    standard error
         1    standard output
     : NOTE
     : the order of the redirections is significant
     - standard error is directed to the screen
       2>&1 >ls-output.txt
     : TIP
     : combined redirection
     - use the single notation &> to redirect both standard output and standard error to the file ls-output.txt
       [me@linuxbox ~]$ ls -l /bin/usr &> ls-output.txt

     : /dev/null
     : This file is a system device called a bit bucket which accepts input and does nothing with it
     - To suppress error messages from a command
       [me@linuxbox ~]$ ls -l /bin/usr 2> /dev/null
     : TIP
     : /dev/null is a Unix Culture, read wiki article on "/dev/null"

     : cat
     : reads one or more files and copies them to standard output
     - display files without paging
       [me@linuxbox ~]$ cat ls-output.txt
     - join large files together
       : movie.mpeg.001 movie.mpeg.002 … movie.mpeg.099
       cat movie.mpeg.0* > movie.mpeg
     - If cat is not given any arguments, by default, attached to the keyboard
       [me@linuxbox ~]$ cat
       The quick brown fox jumped over the lazy dog.
       : Next, type a Ctrl-d to tell cat that it has reached end of file (EOF) on standard input
     - create a file called “lazy_dog.txt” containing the text
       [me@linuxbox ~]$ cat > lazy_dog.txt
       The quick brown fox jumped over the lazy dog.
     : <
     - Using the “<” redirection operator, we change the source of standard input from the keyboard to the file lazy_dog.txt
       [me@linuxbox ~]$ cat < lazy_dog.txt
       The quick brown fox jumped over the lazy dog.

     : |
     : pipe line
     - the standard output of one command can be piped into the standard input of another
       [me@linuxbox ~]$ ls /bin /usr/bin | sort | uniq | less
       : uniq
       : remove any duplicates from the output of the sort command
       - If we want to see the list of duplicates instead, we add the “-d” option
         [me@linuxbox ~]$ ls /bin /usr/bin | sort | uniq -d | less
     : wc
     : display the number of lines, words, and bytes contained in files
     - The “-l” option limits its output to only report lines
       [me@linuxbox ~]$ ls /bin /usr/bin | sort | uniq | wc -l
       2728
     : grep
     : find text patterns within files
     - find all the files in our list of programs that had the word “zip” embedded in the name
       [me@linuxbox ~]$ ls /bin /usr/bin | sort | uniq | grep zip
       bunzip2
       bzip2
       gunzip
       ...
     - “-i” which causes grep to ignore case, “-v” which tells grep to only print lines that do not match the pattern
     : head / tail
     : Print the beginning / end of the file
     - The head command prints the first ten lines of a file and the tail command prints the last ten lines
       [me@linuxbox ~]$ head -n 5 ls-output.txt
       total 343496
       ...
       [me@linuxbox ~]$ tail -n 5 ls-output.txt
       ...
       [me@linuxbox ~]$ ls /usr/bin | tail -n 5
       znew
       ...
     - “-f” option, tail continues to monitor the file and when new lines are appended
       : NOTE
       : use C-c to stop the immediately appear on the display
     : tee
     : reads standard input and copies it to both standard output and to one or more files
     - capture the entire directory listing to the file ls.txt before grep filters the pipeline’s contents
       [me@linuxbox ~]$ ls /usr/bin | tee ls.txt | grep zip
       bunzip2
       bzip2
       ....
**** expansions and quoting
     : echo
     : display a line of text
     - Any argument passed to echo gets displaye
       [me@linuxbox ~]$ echo this is a test
       this is a test
     : filepath expansions
     - the shell expands the “*” into something else (match the name of file) before echo command is executed
       [me@linuxbox ~]$ echo *
       Desktop Documents ls-output.txt Music Pictures Public Templates Videos

       [me@linuxbox ~]$ echo D*
       Desktop  Documents

       [me@linuxbox ~]$ echo *s
       Documents Pictures Templates Videos

       : [me@linuxbox ~]$ echo [[:upper:]]*
       Desktop Documents Music Pictures Public Templates Videos

       : provide a correct listing of hidden files
       ls -d .[!.]?*
       ls -A
     : the tilde character (“~”)
     - When used at the beginning of a word, it expands into the name of the home directory of the named user
       [me@linuxbox ~]$ echo ~
       /home/me

       [me@linuxbox ~]$ echo ~foo
       /home/foo
     : arithmetic expansion
     - use as a calculator
       [me@linuxbox ~]$ echo $((2 + 2))  =# $((expression))=
       4

       [me@linuxbox ~]$ echo $(((5**2) * 3))  =# nest=
       75
     - a few of the supported operators
       + - * / % **
     : brace expansion
     - comma-separated list of string
       [me@linuxbox ~]$ echo Front-{A,B,C}-Back
       Front-A-Back Front-B-Back Front-C-Back

       [me@linuxbox ~]$ echo a{A{1,2},B{3,4}}b  =# nest=
       aA1b aA2b aB3b aB4b
     - a range of integers or single characters
       [me@linuxbox ~]$ echo Number_{1..5}                =# number=
       Number_1  Number_2  Number_3  Number_4  Number_5

       [me@linuxbox ~]$ echo {Z..A}                       =# letter=
       Z Y X W V U T S R Q P O N M L K J I H G F E D C B A
     - The most common application is to make lists of files or directories to be created
       [me@linuxbox ~]$ mkdir Pics
       [me@linuxbox ~]$ cd Pics
       [me@linuxbox Pics]$ mkdir {2007..2009}-0{1..9} {2007..2009}-{10..12}
       [me@linuxbox Pics]$ ls
       2007-01 2007-07 2008-01 2008-07 2009-01 2009-07
       2007-02 2007-08 2008-02 2008-08 2009-02 2009-08
       2007-03 2007-09 2008-03 2008-09 2009-03 2009-09
       2007-04 2007-10 2008-04 2008-10 2009-04 2009-10
       2007-05 2007-11 2008-05 2008-11 2009-05 2009-11
       2007-06 2007-12 2008-06 2008-12 2009-06 2009-12
     : parameter expansion
     - Many variables are available for your examination
       [me@linuxbox ~]$ echo $USER       =# the variable named “USER” contains your user name=
       me

       [me@linuxbox ~]$ printenv | less  =# To see a list of available variables=

       [me@linuxbox ~]$ echo $SUER
       [me@linuxbox ~]$                  =# if you mistype a pattern, it will result in an empty string=
     : command substitution
     - allows us to use the output of a command as an expansion
       [me@linuxbox ~]$ echo $(ls)
       Desktop Documents ls-output.txt Music Pictures Public Templates
       Videos

       [me@linuxbox ~]$ ls -l $(which cp)                      =# getting the listing of of the cp program without having to know its full pathname=
       -rwxr-xr-x 1 root root 71516 2007-12-05 08:58 /bin/cp
       [me@linuxbox ~]$ file $(ls /usr/bin/* | grep zip)       =# the results of the pipeline became the argument list of the file command=
       /usr/bin/bunzip2:     symbolic link to `bzip2'
     - uses *back-quotes* instead of the dollar sign and parentheses
       [me@linuxbox ~]$ ls -l `which cp`
       -rwxr-xr-x 1 root root 71516 2007-12-05 08:58 /bin/cp
     : quoting
     - *word-splitting* by the shell removed extra whitespace from the echo command’s list of arguments
       [me@linuxbox ~]$ echo this is a    test
       this is a test
     - parameter expansion substituted an empty string for the value of “$1” because it was an undefined variable
       [me@linuxbox ~]$ echo The total is $100.00          =# The shell provides a mechanism called quoting to selectively suppress unwanted expansions=
       The total is 00.00
     : double quotes
     : If you place text *inside double quotes*, all the special characters used by the shell lose their special meaning and are treated as ordinary characters
     - Remember, parameter expansion, arithmetic expansion, and command substitution still take place within double quotes
       [me@linuxbox ~]$ echo "$USER $((2+2)) $(cal)"
       me 4    February 2008
       Su Mo Tu We Th Fr Sa
       ....
     - By using double quotes, we *stop the word-splitting* and get the desired result
       [me@linuxbox ~]$ ls -l two words.txt                      =#  shell will seperate file name "two words.txt" to "two" and "words.txt" #=
       ls: cannot access two: No such file or directory
       ls: cannot access words.txt: No such file or directory

       [me@linuxbox ~]$ ls -l "two words.txt"
       -rw-rw-r-- 1 me   me   18 2008-02-20 13:03 two words.txt
       [me@linuxbox ~]$ mv "two words.txt" two_words.txt         =#  rename=
     - unpuoted spaces, tabs, and newlines
       [me@linuxbox ~]$ echo this is a   test    =# by default, word-splitting look spaces,tabs, and newlines as delimiters between word. in this example, command have four argument=
       this is a test

       [me@linuxbox ~]$ echo "this is a    test"  =# include double quotes, it become part of the argument=
       this is a    test
     : single quotes
     : suppress all expansions
     - a *comparison* of unquoted, double quotes, and single quotes
       [me@linuxbox ~]$ echo text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER
       text /home/me/ls-output.txt a b foo 4 me
       [me@linuxbox ~]$ echo "text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER"
       text ~/*.txt   {a,b} foo 4 me
       [me@linuxbox ~]$ echo 'text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER'
       text ~/*.txt  {a,b} $(echo foo) $((2+2)) $USER
     : escape character
     - *prevent an expansion* by precede a character with a backslash
       [me@linuxbox ~]$ echo "The balance for user $USER is: \$5.00"
       The balance for user me is: $5.00
     - To include a special character in a filename
       [me@linuxbox ~]$ mv bad\&filename good_filename
     - backslash escape sequences
       \a
       \b
       \n
       \r
       \t
     - Adding the ‘-e’ option to echo will enable interpretation of escape sequences
       sleep 10; echo -e "Time's up\a"
       sleep 10; echo "Time's up" $'\a'
**** keyboard tricks
     : doing the most work with the fewest number of keystrokes

     : command line editing
     - the keys used to move the cursor
       C-a         beginning line
       C-e         end line
       C-f         forward character, right arrow key
       C-b         backward character, left arrow key
       M-f         forward one word
       M-b         backward word one
       C-l         clear screen
     - lists keyboard are used to edit characters on the command line
       C-d         delete character
       C-t         exchange character
       M-t         exchange word
       M-l         lowercase word
       M-u         uppercase word
     - cutting and pasting
       C-k         kill to end line
       C-u         kill to begin line
       M-d         kill to end word
       M-delete    kill to begin word
       C-y         yank kill-ring
     - completion
       M-?         Display list completions
       M-*         insert all completions
     - programmable completion
       set | less

     : history of command
     - By default, bash stores the last *five hundred* commands you have entered
     - view the contents of the history
       [me@linuxbox ~]$ history | less
     - filter history command
       [me@linuxbox ~]$ history | grep /usr/bin
     - history epansion
       !!          repeat last command
       !number     repeat item number
       !string     repeat item starting with string
       !?string    repeat last command item containing string

     : script [file]
     : be used to record an entire shell session and store it in a file
**** permission
     : id
     : display user identity
     - example
       =# When user accounts are created, users are assigned a number called a user ID or uid=0=
       =# The user is assigned a primary group ID or gid and may belong to additional groups=

       [me@linuxbox ~]$ id                       =# fedora=
       uid=500(me) gid=500(me) groups=500(me)    =# Fedora starts its numbering of regular user accounts at 500=

       [me@linuxbox ~]$ id                       =# ubuntu=
       uid=1000(me) gid=1000(me)                 =# Ubuntu starts at 1000=
       groups=4(adm),20(dialout),24(cdrom),25(floppy),29(audio),30(dip),44(v
       ideo),46(plugdev),108(lpadmin),114(admin),1000(me)    =# the Ubuntu user belongs to a lot more groups. This is Ubuntu manages privileges for system devices and services=

     : read write execute
     - *Access rights* to files and directories are defined in terms of read access, write access, and execution access
       [me@linuxbox ~]$ > foo.txt
       [me@linuxbox ~]$ ls -l foo.txt
       -rw-rw-r-- 1 me   me   0 2008-03-06 14:52 foo.txt
            ^
       : The first ten characters of the listing are the file attributes
       - file types
         -           regular file
         d           directory
         l           symbolic link
         c           character special file
         b           block special file
       : The remaining nine characters of the file attributes, called the owner, the group, and the world permissions
       - permission attributes
         Owner    Group    World
         rwx      rwx      rwx

                  file                           directory
         r        open                           list contents (the execute is also set)
         w        written or truncated           create delete rename files
         x        execute                        entered

     : chmod
     : To change the mode (permissions) of a file or directory
     - chmod supports two distinct ways of specifying mode changes
       - octal number representation
         - use *octal numbers* to set the pattern of desired permissions
           Octal Binary  File Mode
           0     000     ---
           1     001     --x
           2     010     -w-
           3     011     -wx
           4     100     r--
           5     101     r-x
           6     110     rw-
           7     111     rwx
         - By using *three octal digits*, we can set the file mode for the owner, group owner, and world
           [me@linuxbox ~]$ > foo.txt
           [me@linuxbox ~]$ ls -l foo.txt
           -rw-rw-r-- 1 me    me    0  2008-03-06 14:52 foo.txt
           [me@linuxbox ~]$ chmod 600 foo.txt
           [me@linuxbox ~]$ ls -l foo.txt
           -rw------- 1 me    me    0  2008-03-06 14:52 foo.txt
       - symbolic representation
         - is divided into three parts
           - To specify who is affected
             u         user
             g         group
             o         others
             a         all          =# if no character is specified, "all" will be assumed
           - which operation will be performed
             +         add
             -         taken away
             =         only apply
           - example
             u+x
             u-x
             +x
             o-rw
             go=rw
             u+x, go=rw

     : umask
     : set the default file permissions
     - uses octal notation to express a mask of bits to be *removed* from a *file’s mode attributes*
       [me@linuxbox ~]$ rm -f foo.txt
       [me@linuxbox ~]$ umask
       0002                         =# When we set the mask to 0000 (effectively turning it off)=
       [me@linuxbox ~]$ > foo.txt
       [me@linuxbox ~]$ ls -l foo.txt
       -rw-rw-r-- 1 me   me   0 2008-03-06 14:53 foo.txt

       Original file mode  --- rw- rw- rw-
       Mask                000 000 000 010
       Result              --- rw- rw- r--
     - in some high-security situations, you need use mask to set *some special permissions*
       - setuid
         bit octal 4000
         When applied to an executable file, it sets the effective user ID to that of the program’s owner
         : NOTE
         if the program run with privileges of the superuser, it will raises security concerns, so number of setuid must be an absolute mininum
       - setgid
         bit octal 2000
         like the setuid bit, changes the effective group ID from the real group ID of the user to that of the file owner
         This is useful in a *shared directory* when members of a common group need access to all the files in the directory, regardless of the file owner’s primary group
       - sticky
         bit octal 1000
         it prevents users from deleting or renaming files
         This is often used to control access to a shared directory
       - example
         chmod g+s dir         =# a program set setuid:  -rwsr-xr-x=
         chmod g+s dir         =# a program set setgid:  drwsrwxr-x=
         chmod +t dir          =# a program sst sticky:  drwsrwxrwx=

     : There are three ways to take on an alternate identity
     : 1. Log out and log back in as the alternate user
     : 2. su
     :    is used to start a shell as another user
     :    su [-[l]] [user]
     - starting a new interactive command by using su
       [me@linuxbox ~]$ su -       =# -l option will get a login shell for the specified user, this can load the user's config    NOTE: -l may be abbreviated -=
       Password:
       [root@linuxbox ~]#
     :    su -c 'command'
     - execute a single command
       [me@linuxbox ~]$ su -c 'ls -l /root/*'
       Password:
       -rw------- 1 root root    754 2007-08-11 03:19 /root/anaconda-ks.cfg
     : 3. sudo
     :    execute a command as another user
     - example
       [me@linuxbox ~]$ sudo backup_script
       Password:
       System Backup Starting...

       [me@linuxbox ~]$ sudo -l         =# To see what privileges are granted by sudo, use the “-l” option=
       User me may run the following commands on this host:
       (ALL) ALL

     : chown
     : chown [[owner]:[group]] file...
     : change the owner and group owner of a file or directory
     - argument example
       bob                   Changes file owner to user bob
       bob:users             Changes file owner to user bob, changes file group owner to group users.
       :admins               Changes group owner to the group admins, file owner is unchanged.
       bob:                  Change file owner to user bob and changes the group owner to the login group of user bob
     - janet changes the ownership of the copied file from janet to tony
       [janet@linuxbox ~]$ sudo cp myfile.txt ~tony
       Password:
       [janet@linuxbox ~]$ sudo ls -l ~tony/myfile.txt
       -rw-r--r-- 1 root  root 8031 2008-03-20 14:30 /home/tony/myfile.txt
       [janet@linuxbox ~]$ sudo chown tony: ~tony/myfile.txt
       [janet@linuxbox ~]$ sudo ls -l ~tony/myfile.txt
       -rw-r--r-- 1 tony  tony 8031 2008-03-20 14:30 /home/tony/myfile.txt

     : chgrp
     : change group owner of a file or directory

     : share directory usecase
     - the directory is owned by root and has 755 permissions. To make this directory sharable, bill needs to change the group ownership and the group permissions to allow writing
       [bill@linuxbox ~]$ sudo chown :music /usr/local/share/Music
       [bill@linuxbox ~]$ sudo chmod 775 /usr/local/share/Music
       [bill@linuxbox ~]$ ls -ld /usr/local/share/Music
       drwxrwxr-x 2 root music 4096 2008-03-21 18:05 /usr/local/share/Music

       [bill@linuxbox ~]$ > /usr/local/share/Music/test_file
       [bill@linuxbox ~]$ ls -l /usr/local/share/Music
       -rw-r--r-- 1 bill    bill    0 2008-03-24 20:03 test_file         =# the default umask on this system is 0022 which prevents group members from writing files belonging to other members of the group=

       [bill@linuxbox ~]$ sudo chmod g+s /usr/local/share/Music          =# This can be fixed by setting the setgid bit on the directory=
       [bill@linuxbox ~]$ ls -ld /usr/local/share/Music
       drwxrwsr-x 2 root music 4096 2008-03-24 20:03 /usr/local/share/Music

       [bill@linuxbox ~]$ umask 0002                                     =# bill sets his umask to 0002 and allow all members of the group music to create files and directories inside directory=
       [bill@linuxbox ~]$ rm /usr/local/share/Music/test_file
       [bill@linuxbox ~]$ > /usr/local/share/Music/test_file
       [bill@linuxbox ~]$ mkdir /usr/local/share/Music/test_dir
       [bill@linuxbox ~]$ ls -l /usr/local/share/Music
       drwxrwsr-x 2 bill   music 4096 2008-03-24 20:24 test_dir
       -rw-rw-r-- 1 bill   music 0 2008-03-24 20:22 test_file

     : passwd
     : passwd [user]
     : setting passwords for yourself (and for other users if you have access to superuser privileges.)
     - example
       [me@linuxbox ~]$ passwd
       (current) UNIX password:
       New UNIX password:
**** processe
     : In this chapter, we will look at some of the tools available at the command line that let us examine what programs are doing,
     :   and how to terminate processes that are misbehaving

     : ps
     : Report a snapshot of current processes
     [me@linuxbox ~]$ ps
     PID TTY           TIME CMD        =# TTY is short for “Teletype,” and refers to the controlling terminal for the process=
     5198 pts/1    00:00:00 bash
     10129 pts/1   00:00:00 ps

     [me@linuxbox ~]$ ps x             =# Adding the “x” option tells ps to show all of our processes regardless of what terminal (if any) they are controlled by=
     PID TTY   STAT   TIME COMMAND     =# The presence of a “? ” in the TTY column indicates no controlling terminal=
     2799 ?    Ssl    0:00 /usr/libexec/bonobo-activation-server –ac
     2820 ?    Sl     0:01 /usr/libexec/evolution-data-server-1.10 --

     : STAT
     - Process States
       R   running
       S   sleep
       T   stop
       Z   zombie process
       <   high priority
       N   low priority

     : BSD style
     [me@linuxbox ~]$ ps aux
     =# user ID : cpu usage : memory usage : virtual memory : resident set size : time when the process started=
     USER   PID  %CPU  %MEM     VSZ    RSS  TTY   STAT   START   TIME  COMMAND
     root     1   0.0   0.0    2136    644  ?     Ss     Mar05   0:31  init
     root     2   0.0   0.0       0      0  ?     S&lt;     Mar05   0:00  [kt]

     : top
     : Display tasks

     : C-c
     : aske the program to terminate

     : &
     : To launch a program so that it is immediately placed in the background
     [me@linuxbox ~]$ xlogo &
     [1] 28236
     : jos
     : see the background program list
     [me@linuxbox ~]$ jobs
     [1]+ Running            xlogo &
     : NOTE
     : A process in the background is immune from keyboard input, including any attempt interrupt it with a Ctrl-c

     : fg
     : To return a process to the foreground
     [me@linuxbox ~]$ jobs
     [1]+ Running        xlogo &
     [me@linuxbox ~]$ fg %1
     xlogo

     : kill
     : to “kill” programs
     [me@linuxbox ~]$ xlogo &
     [1] 13546
     [me@linuxbox ~]$ kill -1 13546  =# kill [-signal] PID...=
     [1]+ Hangup         xlogo
     - common signals
       1  HUP  Hangup
       2  INT  interrupt
       9  KILL kill
       15 TERM terminate
       18 CONT continue
       19 STOP stop
*** configuration file and shell environment
**** shell environment
     : printenv
     : Print part or all of the environment
     - see a list of environment variables
       [me@linuxbox ~]$ printenv | less
       KDE_MULTIHEAD=false
       SSH_AGENT_PID=6666
       HOSTNAME=linuxbox
       GPG_AGENT_INFO=/tmp/gpg-PdOt7g/S.gpg-agent:6689:1
       SHELL=/bin/bash
       ...
     - specify environment variables
       [me@linuxbox ~]$ printenv USER
       me
     : set
     : Set shell options
     [me@linuxbox ~]$ set | less  =# display both the shell and environment variables, as well as any defined shell functions=
     : export
     : Export environment to subsequently executed programs
     : alias
     : Create an alias for a command
     - One element of the environment that neither set nor printenv displays is aliases
       [me@linuxbox ~]$ alias
       alias l.='ls -d .* --color=tty'
       alias ll='ls -l --color=tty'
       alias ls='ls --color=tty'
       alias vi='vim'
       alias which='alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde'
     : how to create shell environment
     - Startup Files For Login Shell Session
       /etc/profile                             A global configuration script that applies to all users
       ~/.bash_profile                          A user's personal startup file. Can be used to extend or override settings in the global configuration script.
       ~/.bash_login                           If ~/.bash_profile is not found, bash attempts to read this script.
       ~/.profile                              If neither ~/.bash_profile nor ~/.bash_login is found, bash attempts to read this file. This is the default in Debian-based
                                               distributions, such as Ubuntu.
     - Startup Files For Non-Login Shell Sessions
       /etc/bash.bashrc                      A global configuration script that applies to all users.
       ~/.bashrc                             A user's personal startup file. Can be used to extend or override settings in the global configuration script.
     - PATH variable
       PATH=$PATH:$HOME/bin  =# PATH is modified to add the directory $HOME/bin to the end of the list=
       export PATH  =# The export command tells the shell to make the contents of PATH available to child processes of this shell=
**** vi
     : common operator
     [me@linuxbox ~]$ vi  =# start=
     :q   =# exit=
     :q!  =# force exit=
     :w   =# written to hard drave=
     : cursor movement
     C-f  =# down one page=
     C-b  =# up one page=
     : text deletion
     3x   =# current charaacter and the next two characters=
     : join line together
     J
     : search
     f    =# search within a line=
     /    =# search entire file, type n and the cursor will move to match=
     : replace
     :%s/Line/line/g
      %   =# specifies the range of lines=
                   g   =# global=
* READING unix环境高级编程 advanced programming in the unix environment
** question record
*** include apue.h header
    cp ./apue.3e/include/apue.h /usr/local/include =# NOTE: not directory copy to /usr/include=
** unix基础知识 unix system overview
*** 引言 introduction
    本书集中阐述不同unix操作系统所提供的服务
    The focus of this text is to describe the services provided by various versions of the UNIX operating system
*** 体系结构 architecture
    - 内核 kernel
      an operating system can be defined as the software, we call this software the kernel
    - 系统调用 system call
      The interface to the kernel is a layer of software called the system calls
    - 公用函数库 libraries of common functions
      Libraries of common functions are built on top of the system call
    - 外壳 shell
      The shell is a special application that provides an interface for running other applications.
    - 应用程序 system utilities
      In a broad sense, an operating system consists of the kernel and all the other software that makes a computer useful and gives the computer its personality

[P] architecture of the unix operating system
*** 登陆 logging in
**** 登陆名 login name
     - 口令文件 password file
       When we log in to a UNIX system, we enter our login name, followed by our password
       The system then looks up our login name in its password file, usually the file /etc/passwd
       If we look at our entry in the password file, we see that *it’s composed of seven colon-separated fields*:
       =the login name | encrypted password | numeric user ID (205) | numeric group ID (105) | a comment field | home directory (/home/sar) | and shell program (/bin/ksh)=
             =1                   2                     3                        4                   5                      6                             7=
       =sar:x:205:105:Stephen Rago:/home/sar:/bin/ksh=
        =1  2  3   4       5           6        7=
**** shells
     - shell是一个命令行解析器
       Once we log in and then we can type commands to the shell program
       A shell is a command-line interpreter that reads user input and executes commands
       The user input to a shell is normally from the *terminal* (an interactive shell) or sometimes from a file (called a *shell script*).

       [T] conmmon shells used on unix systems
     - shell版本历史
*** 文件和目录 files and directories
**** 文件系统 file system
     - 根目录 root directory
       The UNIX file system is a hierarchical arrangement of directories and files. Everything starts in the directory called root, whose name is the single character /
     - 目录 directory
       A directory is a file that contains directory entries
       each directory entry containing a filename along with a structure of information describing the attributes of the file.
       The attributes of a file are the size of the file,
                                    the owner of the file,
                                    permissions for the file (whether other users may access this file),
                                    and when the file was last modified
**** 文件名 filename
     - 组成文件名的字符 recommends restricting filenames to consist of the following characters
       a~z A~Z      letter
       0~9          number
       .            period
       -            dash
       _            underscore
       .            current directory
       ..           parent directory
     - 当前目录和父目录 current directory and parent directory
       Two filenames are *automatically created* whenever a new directory is created: . (called dot) and .. (called dot-dot)
     : NOTE
     - 斜线和空字符 slash and the null character
       The only two characters that *cannot appear in a filename* are the slash character (/) and the null character
       The slash separates the filenames that form a pathname
       and the null character terminates a pathname
**** 路径名 pathname                                                            :ATTACH:
     :PROPERTIES:
     :Attachments: ls.c
     :ID:       6D8E6404-F5DF-470A-ACAC-3410675D63FF
     :END:
     - 路径名 pathname
       A sequence of one or more filenames, separated by slashes and optionally starting with a slash, forms a pathname
     - 绝对路径 absolute pathname
       A pathname that *begins with a slash* is called an absolute pathname
     - 相对路径 relative pathname
       Relative pathnames refer to files *relative to the current directory*

     - ls command [C]
       - 联机手册 manuals online
         man l ls
         man -sl ls
       - 编译c源文件 If the source file is named myls.c, we compile it into the default a.out by running
         $ cc myls.c
         $ ./a.out /dev
         : NOTE
         the C compiler is gcc. Here, cc is usually linked to gcc
**** 工作目录 working directory
     当前目录
**** 起始目录 home directory
     When we log in, the working directory is set to our home directory
*** 输入和输出 input and output
**** 文件描述符 file descriptors
     - 标识特定进程正在访问的文件
       File descriptors are normally small non-negative integers that the kernel uses to *identify the files accessed by a process*
**** 标准输入 标准输出和标准错误 Standard Input, Standard Output, and Standard Error
     - 每当运行一个新程序 所有的shell都为其打开标题所提到的3个描述符
       By convention, all shells open three descriptors whenever a new program is run: standard input, standard output, and standard error
     - 3个描述符默认都链接向终端
       If nothing special is done, as in the simple command
         ls
       then all three are connected to the terminal
     - 能重定向到某个文件
       executes the ls command with its standard output redirected to the file named file.list.
         ls > file.list
**** 不带缓冲的I/O unbuffered I/O                                               :ATTACH:
     :PROPERTIES:
     :Attachments: stdin_stdout.c
     :ID:       8FD4B5A3-5CCF-4FA3-8FFE-36FEED41CFB7
     :END:
     : Unbuffered I/O is provided by the functions *open, read, write, lseek, and close*
     : These functions all work with file descriptors
     - copies any regular file on a UNIX system
       - Copy standard input to standard output [C]
       - compile the program into the standard name (a.out) and execute it to the file data
         : standard input is the terminal, standard output is redirected to the file data, and standard error is also the terminal
         : If this output file doesn’t exist, the shell creates it by default
         : can use the end-of-file character (usually Control-D) to stop it
         ./a.out > data
       - the file named infile will be copied to the file named outfile
         ./a.out < infile > outfile
**** 标准I/O standard I/O
     : The standard I/O functions provide a buffered interface to the unbuffered I/O functions
     : The most common standard I/O function is *printf*
     - copies any regular file on a UNIX system
       - Copy standard input to standard output, using standard I/O [C]
         =/* apue.h include <stdio.h> */=
         =/* <stdio.h> contains the function prototypes for all the standard I/O functions */=
         =/* <stdio.h> defined the standard I/O constants stdin, stdout and EOF */=
         #include "apue.h"
         int
         main(void)
         {
             int c;  =// Using standard I/O relieves us from having to choose optimal buffer sizes, such as the BUFFSIZE constant=

             while ((c = getc(stdin)) != EOF)  =// if the last byte of input has been read, getc return the constant EOF=
                 if (putc(c, stdout) == EOF)   =// The function getc reads one character at a time, and this character is written by putc=
                     err_sys("output error");
             if (ferror(stdin))
                 err_sys("input error");
             exit(0);
         }
*** 程序和进程 programs and processes
**** 程序 program
     - 磁盘上某个目录中的可执行文件
       A program is an executable file residing on disk in a directory
     - 通过exec函数将程序读入内存 并执行程序
       A program is read into memory and is executed by the kernel as a result of one of the seven exec functions
**** 进程和进程ID processes and process ID                                      :ATTACH:
     :PROPERTIES:
     :Attachments: getpid.c
     :ID:       59C71267-CEE7-4929-8063-59E1164445B1
     :END:
     - 进程  程序的执行实例
       An executing instance of a program is called a process
       Some operating systems use the term task to refer to a program that is being executed
     - 进程ID  唯一的数字标识符
       The UNIX System guarantees that every process has a unique numeric identifier called the process ID.
       The process ID is always a non-negative integer
       - Print the process ID [C]
       - compile this program into the file a.out and execute it
         $ ./a.out
         hello world from process ID 851
         $ ./a.out
         hello world from process ID 854
**** 进程控制 process control                                                   :ATTACH:
     :PROPERTIES:
     :Attachments: execute_cmd.c
     :ID:       45DA3B6C-8423-4038-AC69-F4866B56ED83
     :END:
     : There are three primary functions for process control: fork, exec, and waitpid
     - Read commands from standard input and execute them [C]
     - run the program, use % refer to execute line
       $ ./a.out
       % date
       Sat Jan 21 19:42:07 EST 2012 % who
       sar console Jan 1 14:59 sar ttys000 Jan 1 14:59 sar ttys001 Jan 15 15:28 % pwd
       /home/sar/bk/apue/3e
       % ls
       Makefile
       a.out
       shell1.c
       % ˆD
       $
**** 线程和线程ID threads and thread IDs
     - 线程 某一时刻执行一组机器指令
       Usually, a process has only one thread of control—one set of machine instructions executing at a time
       Some problems are easier to solve when more than one thread of control can operate on different parts of the problem
     - 进程内所有线程共享进程属性
       All threads within a process share the same address space, file descriptors, stacks, and process-related attributes
       Because they can access the same memory, the threads need to *synchronize access* to shared data among themselves to avoid inconsistencies
     - 线程ID只在所属的进程内起作用
       Thread IDs, however, are local to a process. A thread ID from one process has no meaning in another process
*** 出错处理 error handling
    - 出错返回负值
      When an error occurs in one of the UNIX System functions, a negative value is often returned
    - errno显示错误信息
      the integer errno is usually set to a value that tells why the error happened
      - The file <errno.h> defines the symbol errno and constants for each value that errno can assume
        For example, if errno is equal to the constant EACCES, this indicates a permission problem
      - 局部errno
        - each thread needs its own local copy of errno to prevent one thread from interfering with another [C]
          extern int *__errno_location(void);
          #define errno (*__errno_location())
      : NOTE
      - There are *two rules* to be aware of with respect to errno
        First, its value is *never cleared by a routine if an error does not occur*
          Therefore, we should examine its value only when the return value from a function indicates that an error occurred
        Second, the value of errno is *never set to 0* by any of the functions, and none of the constants defined in <errno.h> has a value of 0
    - 出错函数
      - *strerror* function
        #include <string.h>
        char *strerror(int errnum);  =// This function maps errnum, which is typically the errno value, into an error message string and returns a pointer to the string=
      - *perror* function
        #include <stdio.h>
        void perror(const char *msg);  =// The perror function produces an error message on the standard error, based on the current value of errno, and returns=
      - Demonstrate strerror and perror [C]
        #include "apue.h"
        #include <errno.h>

        int
        main(int argc, char *argv[])
        {
            fprintf(stderr, "EACCES: %s\n", strerror(EACCES));
            errno = ENOENT;
            perror(argv[0]);  =// argv[0], whose value is ./a.out, as the argument to perror. this program is executed as part of a pipeline[fn:pipeline]
            exit(0);
        }
      - compile the code
        $ ./a.out
        EACCES: Permission denied
        ./a.out: No such file or directory
    - 出错恢复 error recovery
      The typical recovery action for a resource-related nonfatal error is to delay and retry later

[fn:pipeline] prog1 < inputfile | prog2 | prog3 > outputfile  =//we are able to tell which of the three programs generated a particular error message=
*** 用户标识 user identification
    - 用户ID
      识别不同用户
      不能更改
      - 超级用户
        We call the user whose user ID is 0 either root or the superuser.
        The entry in the password file normally has a login name of root, and we refer to the special privileges of this user as superuser privileges
    - 组ID
      系统分配
      - 共享资源
        Groups are normally used to collect users together into projects or departments.
        This allows the sharing of resources, such as files, among members of the same group.
        we can set the permissions on a file so that all members of a group can access the file, whereas others outside the group cannot.
    - [C]打印用户ID和组ID
      #include "apue.h"
      int
      main(void)
      {
           printf("uid = %d, gid = %d\n", getuid(), getgid());
           exit(0);
      }

      $ ./a.out
      uid = 205, gid = 105
*** 信号 singnals
    - 发送信号处理进程
      Many conditions generate signals. Two terminal keys,
        called the interrupt key— often the DELETE key or Control-C—and the quit key—often Control-backslash—are used to interrupt the currently running process.
        Another way to generate a signal is by calling the kill function
    - singnal函数
      - [C]read commands from standard input and execute them [En 53]
*** 时间值 time values
    - 进程时间 process time
      - clock time
        The clock time, sometimes called wall clock time, is the amount of time the process takes to run,
          and its value depends on the number of other processes being run on the system
      - user cpu time
        The user CPU time is the CPU time attributed to user instructions
      - system cpu time
        - measure
          $ cd /usr/include
          $ time -p grep _POSIX_SOURCE */*.h > /dev/null
*** 系统调用和库函数 system calls and library functions
    - 系统调用
      - c语言最小接口 内核入口
        All operating systems provide service points through which programs request services from the kernel.
        All implementations of the UNIX System provide a well-defined, limited number of entry points directly into the kernel called /system calls/
    - 库函数
      - c语言复杂接口 调用1或多个内核调用
        Section 3 of the UNIX Programmer’s Manual defines the general-purpose library functions available to programmers.
        These functions aren’t entry points into the kernel, although they may invoke one or more of the kernel’s system calls
** unix标准及实现 UNIX Standardization and Implementations
*** unix标准化 unix standardization
**** ISO C
     - 跨平台C标准
       the ISO C standard is to provide portability of conforming C programs to a wide variety of operating systems, not only the UNIX System
     [T] Headers defined by the ISO C standard En 61
**** IEEE POSIX
     - 可移植操作系统借口
       POSIX standard specifies an interface and not an implementation
       no distinction is made between system calls and library functions.
       All the routines in the standard are called functions
       Standards are continually evolving
     [T] Required headers defined by the POSIX standard (En 63)
     [T] XSI option headers defined by the POSIX standard (En 64)
**** Single UNIX Specification
** 文件I/O file I/O
   - 不带缓冲的I/O
     The term unbuffered I/O means that each read or write invokes a system call in the kernel
*** 文件描述符 file descriptors
    - 引用文件
      A file descriptor is a non-negative integer
      When we open an existing file or create a new file, the kernel returns a file descriptor to the process
      When we want to read or write a file, we identify the file with the file descriptor that was returned by open or creat as an argument to either read or write
    - 幻数
      the magic numbers 0, 1, and 2
        should be replaced in POSIX-compliant applications with the symbolic constants STDIN_FILENO, STDOUT_FILENO, and STDERR_FILENO to improve readability.
      These constants are defined in the <unistd.h> header
    - 允许每个进程打开文件数
      the limit is essentially infinite,
        bounded by the amount of memory on the system, the size of an integer, and any hard and soft limits configured by the system administrator
** 文件和目录 files and directories
*** 函数stat、fstat、fstatat和lstat  stat, fstat, fstatat, and lstat Functions  :ATTACH:
    :PROPERTIES:
    :Attachments: stat_fstat_fstatat_lstat.c
    :ID:       D2719384-B3C3-4F31-BADD-D4BCFC84EEA4
    :END:
    - 提供路径 显示文件信息
      that most members of the stat structure are specified by a primitive system data type
      The biggest user of the stat functions is probably the ls -l command, to learn all the information about a file
** 标准I/O库 standard I/O library
   标准I/O库处理细节
*** 流和file对象 streams and file objects
    - file对象指针引用流
      When a file is opened, a file descriptor is returned, and that descriptor is then used for all subsequent I/O operations
      With the standard I/O library, the discussion centers on streams
      When we open or create a file with the standard I/O library, we say that we have associated a stream with the file

      With the ASCII character set, a single character is represented by a single byte. With international character sets, a character can be represented by more than one byte
      Standard I/O file streams can be used with both single-byte and multibyte (‘‘wide’’) character sets

      fwide function can be used to set a stream's orientation [C]
* WAITING c程序设计语言 The C Programming Language
  CLOSED: [2017-04-16 日 14:10]
** 基础 basic
*** 编译 加载 运行 compile load run
    *.c
    cc *.c
    *.out
*** 转义序列 escape sequence
    \n  newline
    \t  tab
    \b  backspace
    \"  double quote
    \\  backslash
*** 注释 comment
    /* ...
       ... */
*** 变量 variable
    int     16位   －32768～32767
    float   32位    10^-38~10^38
    char    single byte
    short   short integer
    long    long integer
    double  double-precision floating
*** 公式 formula
    5*18/9 = 10
    5/9*10 = 0     5/9 = 0
*** 格式化输出 format output
    printf("%3d %6d\n", number, string);   打印区域内右对齐
    %d     print as decimal integer
    %6d    ... at least 6 characters wide
    %f     print as floating point
    %6f    ... at least 6characters wide
    %.2f   ... 2 characters after decimal point
    %6.2f  ... 6 wide and 2 after deciaml point
*** for语句 the for statement
    for (  fahr = 0;      fahr <= 300;     fahr = fahr + 20  )
        initialization    control loop      increment step
*** 符号常量 symbolic constants
    #define name replacementlist

    #define LOWER 0
    #define UPPER 300
    #define STEP  20
    ...
    for( fahr = LOWER; fahr <= UPPER; fahr =fahr + STEP)
    ...
*** 字符输入／输出 character input and output
    getchar();
    putchar();
*** 文件复制 file copying
    : /* copy input to output */
    int c;
    while((c = getchar()) != EOF)
      putchar(c);
*** 字符计数 character counting
    : /* count characters in input */
    : /* while version */
    long nc;
    nc = 0;
    while(getchar() != EOF)
      ++nc;
      printf("%ld\n", nc); // ld
    : /* for version */
    double nc;
    for(nc = 0; getchar( != EOF; ++nc))
      ;
    printf("%.0f\n", nc); // .0
*** 行计数 line counting
    : /* count lines in input */
    int c, nl;
    nl = 0;
    while((c = getchar()) != EOF)
      if (c == '\n') // == '\n' ascii 10
         ++nl; // ++
    printf("%d\n", nl);
*** 单词计数 word counting
    #define IN  1 // inside a word
    #define OUT 0 // outside a word
    ...
    : /* count lines, words, and characters in input */
    int c, nl, nw, nc, state;
    state = OUT;
    nl = nw = nc = 0; // nl = (nw = (nc = 0))
    while ((c = getchar()) != EOF){
      ++nc;
      if (c == '\n')
        ++nl;
      if (c == ' ' || c == '\n' || c = '\t') // && precedence is just higher than ||
        state = OUT;
      else if (state == OUT){ // else if
        state = IN;
        ++nw;
      }
    }
*** 数组 arrays
    : /* count digits, white space, others */
    : int ndigit[10]; // array subscripts always start at 0 in c
    if (c >= '0' && c <= '9')
      ++ndigit[c - '0']; // c - '0'  the numeric value of that digitis
*** 函数 functions
    int power(int m, int n);
    : /* test power function */
    main(){
      ...
      return 0;
    }
    : /* power  base^n */
    int power(int base, int n)
    {
      int i, p;
      p = 1;
      for (i = 1; i <= n; ++i)
        p = p * base;
      return p;
    }
*** 参数-传值调用 arguments-call by value
    : /* power  pass the n value */
    int power(int base, int n)
    {
      int p;
      for (p = 1; n > 0; --n)
        p = p * base;
      return p;
    }
*** 字符数组 character arrays
    #define MAXLINE 1000  =// maximum input line length=
    : /* print the longest input line */
    int getline(char line[], int maxline);
    void copy(char to[], char from[]);  =// void  return nothing=
    - main()
      {
        int len;  =// current line length=
        int max;  =// maximum length seen so far=
        char line[MAXLINE];     =// current input line=
        char longest[MAXLINE];  =// longest line saved here=

        max = 0;
        while ((len = getline(line, MAXLINE)) > 0)
           if (len > max){
              max = len;
              copy (longest, line);
           }
        if (max > 0)
           printf("%s", longest);
        return 0;
      }
    : /* getline:  read a line into s, return length */
    - int getline(char s[], int lim)  =// s[]  its size is set in main.getline=
      {
        int c, i;
        for (i = 0; i < lim-1 && (c=getchar()!=EOF) && c!='\n'; ++i)
            s[i] = c;
        if (c == '\n') {
           s[i] = c;
           ++i;
        }
        s[i] = '\0';  =// '\0' null character, mark the end of the string of characters=
        return i;
      }
    : /* copy:  copy 'from' into 'to'; assume to is big enough */
    - void copy(char to[], char from[])
      {
        int i;
        i = 0;
        while ((to[i] = from[i]) != '\0')
          ++i;
      }
*** 外部变量与作用域 external variables and scope
    : <<header>>
    #include <stdio.h>

    #define MAXLINE 1000    =/* maximum input line size */=

    : <<external variable>>  are globally accessible, can be used to to communicate data between functions
    : NOTE
    : external variables can be changed in unexpected and even inadvertent ways, and the program is hard to modify
    int max;                =/* maximum length seen so far */=
    char line[MAXLINE];     =/* current input line */=
    char longest[MAXLINE];  =/* longest line saved here */=

    int getline(void);
    void copy(void);

    =/* print longest input line; specialized version */=
    - main()
      {
          : <<automatic variable>> (or call local variable)  come and go with function invocation
          :                                              they do not retain their values from one call to the next and must be explicitly set upon each entry
          int len;
          max = 0;

          : <<extern>>  the keyword define the variable refer to the [[external variable]]
          : NOTE
          : the extern declaration can be omitted
          : if the definition of the [[external variable]] occurs in the source file before its use in a particular function
          : or to collect extern declarations of variables and functions in a separate file, called a [[header]], that is included by #include at the front of each source file.
          extern int max;
          extern char longest[];

          while ((len = getline()) > 0)
              if (len > max) {
                  max = len;
                  copy();
              }
          if (max > 0) =/* there was a line */=
              printf("%s", longest);
          return 0;
      }
    =/* getline:  specialized version */=
    - int getline(void)
      {
          : [[automatic variable]]
          int c, i;

          : [[extern]]
          extern char line[];
          for (i = 0; i < MAXLINE - 1
              && (c=getchar)) != EOF && c != '\n'; ++i)
                 line[i] = c;
          if (c == '\n') {
             line[i] = c;
             ++i;
          }
          line[i] = '\0';
          return i;
      }
    =/* copy: specialized version */=
    - void copy(void)
      {
          : [[automatic variable]]
          int i;

          : [[extern]]
          extern char line[], longest[];

          i = 0;
          while ((longest[i] = line[i]) != '\0')
             ++i;
      }
** 类型 运算符 与表达式 types, operators and expressions
*** 变量名 variable names
    - 变量名
      the names of variables are made up of letters and digits; the first character must be a letter; The underscore '_' counts as a letter;
      Don't begin variable names with underscore, since library routines often use such names
      since library routines often use such names
      Upper and lower case letters are distinct, so x and X are two different names.
    - 常量名
      symbolic constants must be all upper case
    - 关键字
      Keywords like if, else, int, float, etc., are reserved: you can't use them as variable names. They must be in lower case
*** 数据类型及长度 data types and sizes
    - 字符型
      char      a single byte, capable of holding one character in the local character set
    - 整型
      int       an integer, typically reflecting the natural size of integers on the host machine
    - 单精度浮点型
      float     single-precision floating point
    - 双精度浮点型
      double    double-precision floating point
    - 限定符
      short     16 bit int or float or others (depends implementing on machine)
      long      32 bit int or float or others (depends implementing on machine)
      unsigned  always positive or zero (8 bit  between 0~255)
      signed    positive and negtive (8 bit  between -127~128)
*** 常量 constants
    - 整型常量
      1234 is an int, *A long constant* is written with a terminal l (ell) or L, as in 123456789L
      *Unsigned constants* are written with a terminal u or U, and the suffix ul or UL indicates unsigned long
      A leading 0 (zero) on an integer constant means *octal* (037 equal 31 decimal)
      a leading 0x or 0X means *hexadecimal* (0xFUL equal 15 decimal)
    - 浮点数常量
      contain a decimal point (123.4) or an exponent (1e-2) or both
      The suffixes f or F indicate a float constant; l or L indicate along double
    - 字符常量
      A character constant is an integer, written as one character within single quotes, such as 'x'
      in the *ASCII character* set the character constant '0' has the value 48, which is unrelated to the numeric value 0
      Character constants participate in *numeric operations* just as any other integers, although they are most often used in *comparisons with other characters*
      - The complete set of *escape sequences* is
        \0    octal digits (like '\013')
        \x    hexadecimal (like '\xb')
        \a    alert(bell) character
        \b    backspace
        \f    formfeed
        \r    carriage return
        \t    horizontal tab
        \v    vertical tab
        \\    backslash
        \?    question mark
        \'    single quote
        \"    double quote
        \0    null character
    - 常量表达式
      A constant expression is an expression that involves only constants
      Such expressions may be evaluated at during compilation rather than run-time, and accordingly may be used in any place that a constant can occur
          #define MAXLINE 1000
          char line[MAXLINE+1];
    - 字符串常量
      A string constant, or string literal, is a sequence of zero or more characters surrounded by double quotes
          "I am a string"
          "" =/* the empty string */=
      The quotes are not part of the string
      The same escape sequences used in character constants apply in strings; \" represents the double-quote character
      String constants can be *concatenated* at compile time:
          "hello, " "world"
          "hello, world"
      - The standard library function *strlen(s)*
        : strlen and other string functions are declared in the standard header <string.h>
        #include <string.h>
        =/* strlen:  return length of s */=
        int strlen(char s[])
        {
            int i;
            : returns the length of its character string argument s, excluding the terminal '\0'
            while (s[i] != '\0')
                   ++i;
            return i;
        }
      : NOTE
      'x' is not the same as "x"
    - 枚举常量
      the enumeration constant. An enumeration is a list of constant integer values
      The first name in an enum has value 0, the next 1, and so on
          enum months { JAN = 1, FEB, MAR, APR, MAY, JUN,
                 JUL, AUG, SEP, OCT, NOV, DEC };
                       // FEB = 2, MAR = 3, etc.
      : NOTE
      Names in different enumerations must be distinct. Values need not be distinct in the same enumeration
      : TIP
      an alternative to #define with the advantage that *the values can be generated* for you
      enumeration variables *offer the chance of checking* and so are often better than #defines
* WAITING go语言圣经 the go programming language
  CLOSED: [2017-04-16 日 14:10]
** 入门 tutorial
*** hello world
    go run helloworld.go
      execute program one time
    go build helloworld.go
      create an executable binary file
*** 命令行参数 8 command-line arguments 34
    - os package
      dealing with the operating system in a platform-independent fashion
    - os.arg
      get arguments of os package
    - s[m:n]
      a slice of strings, return value of subsequence m to n-1
      a = [1, 2, 3]
      a[0, 2] = [1, 2]
      s[1:] = s[0:len(s)]
    : implementation of the unix echo command
    gopl.io/ch1/echo1
    // Echo1 prints its command-line arguments
    - package main
      import (
          "fmt"
          "os"
      )
    - func main() {
          var s, sep string  // the var declaration declares two variables s and sep, of type string
          // for loop   := give i appropriate types based on the initializer values
          for i :=1 i < len(os.Args); i++ {  // j = i++  or ++i --i is illegal
              s += sep + os.Args[i]  // the + operator concatenates the values of strings
              sep = " "
              fmt.Println(s)
          }
      }
    : second version of echo command (over a range of value from a string or a slice)
    ...
    - func main() {
          s, sep := "". ""  // [[declare and initialize]]
          for _, arg := range os.Args[1:]{  // _ blank identifier  used whenever syntaax requires a variable name but program logic does not
                           // os.Args[1:]  indexing over os.Args is implicit, not explicit
              s += sep + arg  // [[a simpler and more efficient solution to use involved large amount of data]]
              sep = " "
          }
          fmt.PrintIn(s)
      }
    ...
    : <<declare and initialize>>
    there are several ways to declare a string variable, these are all equivalent:
      s := ""             // with implicit to specified variable type: used only witin a function, not for package-level variables
      var s string        // with explicit to specified variable type
      var s = ""          // in practice, you should not use this form: implicit inialization to say that the initial value doesn't matter
      var s string = ""   // in practice, you should not use this form: explicit inialization to say that the initial value doesn't matter
    : <<a simpler and more efficient solution to use involved large amount of data>>
    fmt.PrintIn(strings.Join(os.Args[1:], " "))
    : one of for loop statement forms
    for initialization; condition; post {
        // zero or more statements
    }
    : a traditional "while" loop
    for condition {
        // ...
    }
    : atraditional infinite loop
    for {
        // ...
    }
    : 
*** 查找重复的行 finding duplicate lines
    : Dup1 prints the text of each line that appears more than
    : once in the standard input, preceded by its count.
    gopl.io/ch1/dup1
    - package main
      import (
          "bufio"
          "fmt"
          "os"
      )
    - func main() {
         counts := make(map[string]int)  =// the build-in function make create a new empty [[map]]=
         =// <<map>>  holds a set of key/value pairs and provides constant-time operations to store=
         =//          the default value of key is 0=
         input := bufio.NewScanner(os.Stdin)  =// bufio Scanner: read input and breaks it into lines or words=
         for input.Scan() {  =// each call to input.Scan() reads the next line and removes the newline character from the end=
             counts[input.Text()]++  =// equivalent to line :=input.Text()=   =counts[line] = count[line] + 1=
         }
         // NOTE: ignoring potential errors from input.Err()
         for line, n := range counts {  =// range loop: the order of map iteration is random=
             if n > 1 {
                 fmt.Printf("%d\t%s\n", n, line)  =// fmt.Printf like printf in C and have over a dozen such conversions call [[verbs]]=
         }
       }
    : Dup2 prints the count and text of lines that appear more than once
    : in the input.  It reads from stdin or from a list of named files.
    gopl.io/ch1/dup2
    - package main
      import (
          "bufio"
          "fmt"
          "os"
      )
    - func main() {
          counts := make(map[string]int)
          files := os.Args[1:]
          if len(files) == 0 {             =// a map type counts is passed to a function, the function receives a copy of the reference (like C pointer)=
             countLines(os.Stdin, counts)  =// so any changes the called function makes to the underlying data structure will be visible through the caller's map reference=
          } else {
              for _, arg := range files {
                  f, err := os.Open(arg)  =// os.Open: return two values  an open file (*os.file) read by Scanner  build-in error type=
                  =// if the returned error type is nil, the file was opened successfully=
                  =// else using Fprintf and the verb %v to format error stream, and dup then carries on with the next file=
                  if err != nil {
                      fmt.Fprintf(os.Stderr, "dup2: %v\n", err)
                      continue
                  }
                  countLines(f, counts)  =// call countLines precedes its declaration, functions and other package-level entities may be declared in any order=
                  f.Close()
              }
          }
          for line, n := range counts {
              if n > 1 {
                  fmt.Printf("%d\t%s\n", n, line)
              }
          }
      }
    - func countLines(f *os.File, counts map[string]int) {
          input := bufio.NewScanner(f)
          for input.Scan() {
              counts[input.Text()]++
          }
         // NOTE: ignoring potential errors from input.Err()
      }
    : Dup3 it only reads named files, not the standard input
    : moved the counting of the lines into main, since it is nedded in only one place
    gopl.io/ch1/dup3
    - package main
      import (
          "fmt"
          "io/ioutil"
          "os"
          "strings"
      )
    - func main() {
          counts := make(map[string]int)
          for _, filename := range os.Args[1:] {
              data, err := ioutil.ReadFile(filename)  =// ReadFile returns a byte slice that must be converted into a string so it can be split by [[strings.Split]]=
              if err != nil {
                  fmt.Fprintf(os.Stderr, "dup3: %v\n", err)
                  continue
              }
              for _, line := range strings.Split(string(data), "\n") { =// <<strings.Split>>=
                  counts[line]++
              }
          }
          for line, n := range counts {
              if n > 1 {
                  fmt.Printf("%d\t%s\n", n, line)
              }
          }
      }
    : <<verbs>>
    - many of the features
      %d              decimal integer
      %x, %o, %b      integer in hexadecimal, octal, binary
      %f, %g, %e      floating-point number: 3.141593 3.141592653589793 3.141593e+00
      %t              boolean: true or false
      %c              rune (Unicode code point)
      %s              string
      %q              quoted string "abc" or rune 'c'
      %v              any value in a natural format
      %T              type of any value
      %%              literal percent sign (no operand)
* WAITING ruby编程语言 ruby programming language
  CLOSED: [2017-03-30 四 17:22]
** 导言 introduction
*** 漫游ruby a tour of ruby
**** ruby是完全的面向对象的 ruby is completely object-oriented
**** 代码块和迭代器 18 blocks and iterators 17
     : method known as an iterator, and they behave like loops
     : the code within curly braces known as a block

     : the integer's iterator method
     - times & upto
       3.times { print "Ruby! " }  # Prints "Ruby! Ruby! Ruby! "
       1.upto(9) {|x| print x }    # Prints "123456789"
     : the array's iterator method
     - each map inject select
       a = [3, 2, 1]    =# This is an array literal=
       a[3] = a[2] - 1  =# Use square brackets to query and set array elements=
       a.each do |elt|  =# each is an iterator. The block has a parameter elt=
         print elt+1    =# Prints 4321=
       end              =# This block was delimited with do/end instead of {}=
       a = [1,2,3,4]               =# Start with an array=
       b = a.map {|x| x*x }        =# Square elements: b is [1,4,9,16]=
       c = a.select {|x| x%2==0 }  =# Select even elements: c is [2,4]=
       a.inject do |sum,x|         =# Compute the sum of the elements => 10=
         sum + x
       end
     : the hash 's iterator method
     - each
       h ={                         # A hash that maps number names to digits
         :one => 1,                 # The "arrows" show mappings  key=>value
         :two => 2                  # The colons indicate Symbol literals
       }
       h[:one]                      # => 1. Access a value by key
       h[:three] = 3                # Add a new key/value pair to the hash
       h.each do |key,value|        # Iterate through the key/value pairs
         print "#{value}:#{key}; "  # Note variables substituted into string
       end                          # Prints "1:one; 2:two; 3:three; "
     : associate a block of code with amethod invocation
     - File.open & readline  Thread.new & File.read
       File.open("data.txt") do |f|   # Open named file and pass stream to block
         line = f.readline            # Use the stream to read from the file
       end                            # Stream automatically closed at block end

       t = Thread.new do           # Run this block in a new thread
         File.read("data.txt")     # Read a file in the background
       end                         # File contents available as thread value
**** 表达式和操作符 expressions and operators
     : ruby's expressions
     : control structures such as if that would be called expressions in ruby
     minimum = if x < y then x else y end
     : ruby's operator
     - some unusual ruby oerators
       1 + 2                     # => 3: addition
       1 * 2                     # => 2: multiplication
       1 + 2 == 3                # ==> true: == tests equality
       2 ** 1024                 # 2 to the power 1024: Ruby has arbitrary size ints
       "Ruby" + " rocks!"        # => "Ruby rocks!": string concatenation
       "Ruby! " * 3              # => "Ruby! Ruby! Ruby! ": string repetition
       "%d %s" % [3, "rubies"]   # => "3 Rubies": Python-style, printf formatting
       max = x > y ? x : y       # The conditional operator
     : array's [] operator
     - slice
**** 方法 methods
     : the key feature of ruby
     : classes and modules are "open" and can be modified and extended by method at runtime

     : methods
     - use def keyword to define methods
       def square(x)  # Define a method named square with one parameter x
         x*x          # Return x squared
       end            # End of the method
     : global function
     - define on individual objects by prefixing the name  of the method, which are known as singleton
       def Math.square(x)     # Define a class method of the Math module
         x*x`
       end
**** 赋值 assignment
     : = operator in ruby assigns a value to avariable
     x = 1
     : assignment can be combined with other operators
     - combine with + or -
       x += 1       # Increment x
       y -= 1       # Decrement y
       # NOTE: ruby have no ++ and -- operator
     : parallel assignment
     - allowing more than one value and more than one variable in assignment expressions
       x, y = 1, 2       # Same as x = 1; y = 2
       a, b = b, a       # Swap the value of two variables
       x,y,z = [1,2,3]   # Array elements automatically assigned to variables
     - use parallel assignment with method return more than one value
       # Define a method to convert Cartesian (x,y) coordinates to Polar
       def polar(x,y)
         theta = Math.atan2(y,x)  # Compute the angle
         r = Math.hypot(x,y)      # Compute the distance
         [r, theta]               # The last expression is the return value
       end
       # Here's how we use this method with parallel assignment
       distance, angle = polar(2,2)
     : method end with an equals sign(=)
     - ruby allows them to be invoked using asignment syntax, below two line are the same
       o.x=(1)    # Normal method invocation syntax
       o.x = 1    # Method invocation through assignment
**** 作为前缀和后缀的标点符号 punctuation suffixes and prefixes
     : punctuation characters at the end of method names
     - method end with a question mark
       A question mark is used to mark predicates—methods that *return a Boolean value*
       For example, the Array and Hash classes both define methods named *empty?* that test whether the data structure has any elements.
     - An exclamation mark at the end of a method name
       the method without the exclamation mark returns a modified copy of the object it is invoked on
       and the one with the exclamation mark is a mutator method that alters the object in place
       The Array class, for example, defines methods sort and sort!
     : punctuation characters at the start of variable names
     - global variables are prefixed with $
     - instance variables are prefixed with @
     - class variables are prefixed with @@
**** regexp and rangee
     : regexp
     - regular expression
       : /[Rr]uby/   # Matches "Ruby" or "ruby"
       : /\d{5}/     # Matches 5 consecutive digits
     : range
     - represents the values (usually integers) between two endpoints
       1..3          # All x where 1<=x<=3
       1...3         # All x where 1<=x<3
     : case statement
     - matches its expression against each of the possible cases (like the switch statement of C or Java)
       a example of case statement [En 22]
**** 类和模块 classes and modules
     : ruby核心类都是开放的 任何程序都可以为它们添加方法
     - defines an example class named Sequence and demonstrates how to write iterator methods and define operators [En 22]
**** ruby意外之处 ruby surprises
     : NOTE
     - 字符串可变的
       The []= operator allows you to alter the characters of a string or to insert, delete, and replace substrings.
       The << operator allows you to append to a string
       Because strings are mu- table, string literals in a program are not unique objects. If you include a string literal within a loop,
         it evaluates to a new object on each iteration of the loop.
         call the freeze method on a string (or on any object) to prevent any future modifications to that object.
     - nil值被当成false处理 任何其他的值都和true一样处理
*** 体验ruby try ruby
    : irb ri gem
**** ruby解释器 the ruby interpreter
     : 执行ruby
     - 命令行
       $ ruby -e 'puts "hello world!"'
     - 调用文件
       $ ruby hello.rb
**** 显示输出 displaying output
     - put print 方法
       - count.rb
         9.downto(1) {|n| print n} # No new line between numbers
         puts " blastoff!"       # End with a newline
       $ ruby count.rb
       - output
         987654321 blastoff!
**** 使用irb与ruby进行交互 interative ruby with irb
     : ruby shell
     - Type any Ruby expression at its prompt and it will evaluate it and display its value for you
       an example irb session [En 28]
**** 使用ri查看ruby文档 viewing ruby documentation with ri
     : 内置文档查看
     - display class module method documentation
       (use # refer to the isntance method, use :: to refer to the class method)
       ri Array
       ri Array.sort
       ri Hash#each
       ri Math::sqrt
**** 使用gem进行ruby包管理 ruby package management with gem
     : 模块管理
     - like (elisp elpa : java maven : osx brew : ubuntu apt)
** ruby程序的结构和运行 the structure and execution of ruby programs
*** 词法结构 lexical structure
**** 注释 comments
     - Comments in Ruby begin with a # character and continue to the end of the line
       # This entire line is a comment
       x = "#This is a string"              # And this is a comment
       y = /#This is a regular expression/    # Here's another comment
     - multiline comments
       #
       # This class represents a Complex number
       # Despite its name, it is not complex at all.
       #
     : NOTE
     - newline
       The Ruby interpreter ignores the # character and any text that follows it
       but does not ignore the newline character, which is meaningful whitespace and may serve as a statement terminator
     - regular expression
       If a # character appears within a string or regular expression literal (see Chapter 3)
**** 嵌入式文档 embedded documents
     : another style of multiline comment
     - These start on a line that begins *=begin* and continue until (and include) a line that begins *=end*
       =begin Someone needs to fix the broken code below!
         Any code here is commented out
       =end
     : As their name implies, embedded documents can be used to include long blocks of documentation within a program,
     : or to embed source code of another language (such as HTML or SQL) within a Ruby program
     : NOTE
     - embedded documents only work if the = signs are the first characters of each line:
       # =begin This used to begin a comment. Now it is itself commented out!
         The code that goes here is no longer commented out
       # =end
     : 文档化的注释 documentation comments
     - Ruby programs can include embedded *API documentation* as specially formatted comments that precede method, class, and module definitions.
       The following example comment demonstrates the most important formatting ele- ments of the markup grammar used in Ruby’s documentation comments [En 41]
     - they can also be written as embedded documents that start =begin rdoc. (The rdoc tool will not process these comments if you leave out the “rdoc”.)
**** 字面量 literals
     : Literals are values that appear directly in Ruby source code
     - They include numbers, strings of text, and regular expressions
       1        # An integer literal
       1.0      # A floating-point literal
       'one'    # A string literal
       "two"    # Another string literal /three/ # A regular expression literal
**** 标点符号 punctuation
**** 标识符 identifiers
     : identifiers to name variables, methods, classes, and so forth
     - consist of letters, numbers, and underscore characters
     : NOTE
     - may not begin with a number
     - Class and module names must begin with initial capital letters
     - 大小写敏感 case sensitiity
     - unicode characters in identifiers
     : 标识符里的标点符号 punctuation in identifiers
     - Punctuation characters may appear at the start and end of Ruby identifiers. They have the following meanings:
       $ Global variables are prefixed with a dollar sign.
       @ Instance variables are prefixed with a single at sign, and class variables are prefixed with two at signs.
       ? As a helpful convention, methods that return Boolean values often have names that end with a question mark.
       ! Method names may end with an exclamation point to indicate that they should be used cautiously.
       = Methods whose names end with an equals sign can be invoked by placing the method name, without the equals sign, on the left side of an assignment operator.
     - Here are some example identifiers that contain leading or trailing punctuation characters:
       $files        # A global variable
       @data         # An instance variable
       @@counter     # A class variable
       empty?        # A Boolean-valued method or predicate
       sort!         # An in-place alternative to the regular sort method
       timeout=      # A method invoked by assignment
**** 关键字 keyword
     - The keywords have special meaning in Ruby [En 44]
     - there are three keywords are treated specially by the Ruby parser when they appear at the beginning of a line
       =begin =end __END__
         =begin and =end at the beginning of a line delimit multiline comments
         __END__ marks the end of the program (and the beginning of a data section) if it appears on a line by itself with no leading or trailing whitespace
     - some identifiers appear in Kernel, Module, Class and Object are treated as keyword(reserved word) [En 45]
**** 空白符 whitespace
     - 用于分割不同的标记 以免这些标记合并成一个标记
***** 作为语句终结符的换行符 newlines as statement terminators
      - 不是每个语句都要以分号结尾
        this is only required semicolons to terminate statements if you put *more than one statement* on the same line.
        In addition, the semicolons should be *omitted*
      - 下列情形 你可以放心插入一个换行符而不必担心你的语句提前结束
        - after an operator
          puts x +
               y
        - after a *period* (fuent APIs)
          animals = Array.new
            .push("dog")  # Does not work in Ruby 1.8
            .push("cow")
            .push("cat")
            .sort
        - comma in a method invocation, array literal, or hash literal
          [1,2,3]        [1,
                          2,
                          3]
          {x=>1,y=>1}    {x<=1,
                          y<=1}
        - escape a line break *with a backslash*
          var total = first_long_variable_name + second_long_variable_name \
            + third_long_variable_name # Note no statement terminator above
***** 空格符与方法调用 spaces and method invocations
      - 避免空白符在函数方法中的二义性
        - Never put a space between a method name and the opening parenthesis
          f(3+2)+1
          f (3+2)+1
        - If the first argument to a method begins with an open parenthesis, always use parentheses in the method invocation
          f((3+2)+1)
        - Always run the Ruby interpreter with the *-w option* so it will warn you if you forget either of the rules above

*** 句法结构 syntactic structure
    - 初级表达式 primary expressions
      primary expressions represent values directly, or other keyword(like true false nil self)
    - 复合表达式 compound expressions
      [1,2,3]                # An Array literal
      {1=>"one",2=>"two"}    # A Hash literal
      1..3                   # A Range literal
**** ruby当中的块结构 block structure in ruby
     : 两种块结构
     - 与迭代器相关联的代码
       These blocks are the chunks of code associated with or passed to iterator methods
       - Formal blocks of this kind may be delimited with *curly braces*, or they may be delimited with the keywords *do* and *end*
         3.times { print "Ruby! " }

         1.upto(10) do |x| print x
         end
     - 语句列表  a list of statements
       while
       when
       if
       else
*** 文件结构 file structure
    - ruby程序结构规则
      : shebang comment and coding comment must at top line of file
      : if they are both exist, shebang comment should be above of coding comment
      #!/usr/bin/ruby -w        shebang comment
      # -*- coding: utf-8 -*-   coding comment
      require 'socket'          load networking library

        ...                     program code goes here

      __END__                   mark end of code
        ...                     program data goes here
*** 程序的编码 program encoding
**** 指定程序所使用的编码 specifying program encoding
     - 通过编码方式
       : NOTE
       : encoding names are not case-sensitive
       # coding: utf-8
**** 源编码和默认外部编码 source encoding and default external encoding
     - 源编码
       it tells the Ruby interpreter how to read characters in a script
     - 默认外部编码
       this is the encoding that Ruby uses by default when reading from files and streams
       : TIP
       - set the default external encoding of the process and then uses that encoding as the default source encoding
         ruby -E utf-8 # Encoding name follows -E
         ruby -Eutf-8 # The space is optional
         ruby --encoding utf-8 # Encoding following --encoding with a space
         ruby --encoding=utf-8 # Or use an equals sign with --encoding
*** ruby程序的运行 program execution
    - 脚本语言
      Ruby programs are simply lists, or scripts, of statements to be executed
      By default, these statements are executed sequentially, in the order they appear
      : NOTE
      There is no special *main method* in Ruby
      : the difference from ruby to compiler language
      In compiled languages, these are syntactic structures that are processed by the compiler
      When the Ruby interpreter encounters a class definition, it executes it, causing a new class to come into existence
** 数据类型和对象 datatyoes and objects
*** 数字 numbers
    - 数值类继承关系
      - integer
        fixnum       If an integer value fits within 31 bits, it is an instance of Fixnum
        bignum       Otherwise, it is a Bignum. Bignum objects represent integers of arbitrary size
      numeric class hierarchy [P En 56]
**** 蒸熟字面量 integer literals
     - 千分符 thousands separator
       1_000_000_000      # One billion (or 1,000 million in the UK)
     - 进制数
       0377           # Octal representation of 255
       0b1111_1111    # Binary representation of 255
       0xFF           # Hexadecimal representation of 255
**** 浮点数字面量 floating-point literals
     - example
       : NOTE
       : only express floating-point values in base 10
       0.0
       -3.14
       : the e can be replace by E
       6.02e23         # This means 6.02 × 1023
       1_000_000.01    # One million and a little bit more
**** ruby中的算术操作 arithmetic in ruby
     - 截断型整数除法 truncatig-integer division
       x= 5/2     # result is 2
       y= 5.0/2   # result is 2.5
       z= 5/2.0   # result is 2.5
     - 取模 (%)
       x= 5%2     # result is 1
       : NOTE
       : The % operator can also be used with Float operands
       x= 1.5%0.4     # result is 0.3
     - 指数操作 (**)
       x**4           # This is the same thing as x*x*x*x
       x**-1          # The same thing as 1/x
       x**(1/3.0)     # The cube root of x
       x**(1/4)       # Oops! Integer division means this is x**0, which is always 1
       x**(1.0/4.0)   # This is the fourth-root of x
       : NOTE
       : When multiple exponentiations are combined into a single expression, they are eval- uated from right to left
       : Thus, 4**3**2 is the same as 4**9, not 64**2
**** 浮点数的二进制表示和圆整错误 binary floating-point and rounding errors
     - 二进制与十进制之间的误差
       Forhardware efficiency, most floating-point representations are *binary representations*
         which can exactly represent fractions like 1/2, 1/4, and 1/1024
       Unfortunately, the fractions we use most commonly (especially when performing financial calculations) are 1/10, 1/100, 1/1000, and so on
         Binary floating-point representations cannot exactly represent numbers as simple as 0.1
*** 文本 text
**** 字符串字面量 string literals
***** 由单引号引用的字符串字面量 single-quoted string literals
      - 转义字符
        'This string literal ends with a single backslash: \\'
        'This is a backslash-quote: \\\''
        'Two backslashes: \\\\'
        : a backslash is not special if the character that follows it is anything other than a quote or a backslash
        'a\b' == 'a\\b'
        - multiple line
          - break it into multiple adjacent string literals
            : you must escape the newlines between the literals so that Ruby does not interpret the newline as a statement terminator
            message =
            'These three literals are '\
            'concatenated into one by the interpreter. '\
            'The resulting string contains no newlines.'
          - [NOTE] It is not possible to escape the newlines with a backslash
            'This is a long string literal \
            that includes a backslash and a newline'
***** 由双引号引用的字符串字面量 double-quoted string literals
      - 转义序列
        "\t\"This quote begins with a tab and ends with a newline\"\n"
        "\\" # A single backslash

        the \u escape embeds arbitrary *Unicode characters*
      - 包含任意的ruby表达式
        : expressions within double-quoted strings begin with the # character and are enclosed within curly braces
        "360 degrees=#{2*Math::PI} radians" # "360 degrees=6.28318530717959 radians"
        - the curly braces may be *omitted* in these situation
          $salutation = 'hello'   # Define a global variable (or class)
          "#$salutation world"    # Use it in a double-quoted string
        - Use a backslash to escape the # character
          "My phone #: 555-1234"  # No escape needed if the character after # is {, $, or @
          "Use\#{tointerpolateexpressions" #Escape#{withbackslash
      - 字符串内插 [C sprintf]
        sprintf("pi is about %.4f", Math::PI) # Returns "pi is about 3.1416"
        "pi is about %.4f" % Math::PI         # Same as example above
        "%s:%f"%["pi",Math::PI]               # Array on right hand side for multiple args
      - 跨越多行
        - Double-quoted string literals may span multiple lines, and line terminators become part of the string literal, *unless escaped with a backslash*
          "This string literal
          has two lines \
          but is written on three"
        - adjacent string literals are automatically concatenated, but if they are written on separate lines, the *newline between them must be escaped*
          "This string has three lines.\r\n" \
          "It is written as three adjacent literals\r\n" \
          "separated by escaped newlines\r\n"
      - 双引号内的转义序列索引 [T En 63]
***** Unicode转义序列 Unicode escape
      - \u之后加上4个十六进制数字
        - which represent a Unicode codepoint between 0000 and FFFF
          "\u00D7" # => "×": leading zeros cannot be dropped
          "\u20ac" # => "¤": lowercase letters are okay
      - \u之后加上一个{符号 然后接1到6个十六进制数字
        The digits between the braces can represent any Unicode codepoint between 0 and 10FFFF, and leading zeros can be dropped in this form
        "\u{A5}" # => "¥": same as "\u00A5"
        "\u{3C0}" # Greek lowercase pi: same as "\u03C0"
        "\u{10ffff}" #ThelargestUnicodecodepoint
      - \u{}同时嵌入多组序列
        - separated by a single space or tab character
          money="\u{20AC A3 A5}"        # => "¤£¥"
          money="\u{20AC 20 A3 20 A5}"  # => "¤ £ ¥"
      - [NOTE] 只适用于UTF-8或ASCII中
***** 字符串字面量的分界符 arbitrary delimiters for string literals
      - 使用%q表示单引号字符串  %Q(或%)表示双引号表示双引号字符串
        - If the opening delimiter is (, [, {, or <, then the matching delimiter is ), ], }, or >
          %q(Don't worry about escaping ' characters!)
          %Q|"How are you?", he said|
          %-Thisstringliteralendswithanewline\n- #Qomittedinthisone
        - you can use a backslash (even in the stricter %q form) or just choose a different delimiter
          %q_This string literal contains \_underscores\__
          %Q!Just use a _different_ delimiter\!!
        - If you use paired delimiters, you don’t need to escape those delimiters in your literals
          %<<book><title>Ruby in a Nut shell</title></book>>   # This works
***** here document
      - 输出多行字符串
        def hello
          puts <<~HEREDOC
            I know I know
            You will like it.
          HEREDOC
        end
        hello

        output:
        >> I know I know
        >> You will like it.
***** 反引号所引用的命令的执行 backtick command execution
      - 执行shell命令 或作为双引号字面量处理
        - like a double- quoted literal, which means that arbitrary Ruby expressions can be interpolated into the string
          if
            windows listcmd = 'dir'
          else
            listcmd = 'ls'
          end
          listing = `#{listcmd}`    equal    listing = Kernel.`(listcmd)
        - this method executes the text as an operating system shell command and returns the command’s output as a string
          `ls`  equal   %x[ls]
***** 字符串字面量和可变性 string literals and mutability
      - 无法用一个对象表达两个相同的字符串
        - If you include a literal within the body of a loop, Ruby will create a new object for each iteration
          10.times { puts "test".object_id }
***** string.new 方法
      - 创建新字符串
        With no arguments, this method returns a newly created string with no characters
        With a single string argument, it creates and returns a new String object
**** 字符字面量 character literals
     - 字符前加问好 构成字面量
       - Single characters can be included literally in a Ruby program by preceding the character with a question mark
         ?A    =# equal the ASCII value of "A", character literal is 65=
     - 进行转义
       - 结合转义序列
         ?\u20AC == ?Ω    =# true: Ruby 1.9 only=
         ?Ω == "\u20AC"   =# true=
       - 结合转义字符
         ?\t     =# Character literal for the TAB character=
         ?\C-x   =# Character literal for Ctrl-X=
         ?\111   =# Literal for character whose encoding is 0111 (octal)=
**** 字符串操作符 string operators
     - 连接字符串
       - + operator
         : concatenates two strings and returns the result as a new String object
         planet = "Earth"
         "Hello" + " " + planet  =# Produces "Hello Earth".=
         : NOTE
         : the + operator does not convert its righthand operand to a string
         "Hello planet #" + planet_number.to_s  =# to_s converts to a string=
         : TIP
         : a simple way to auto convert to string
         "Hello planet ##{planet_number}"
       - << operator
         : it alters the lefthand operand rather than creating and returning a new object
         greeting = "Hello"
         greeting << " " << "World"
         puts greeting  =# Outputs "HelloWorld".=
         : NOTE
         : If the righthand operand is an integer, it is taken to be a character code
         alphabet = "A"
         alphabet << ?B  =# Alphabet is now "AB".=
         alphabet << 67  =# Andnowit is "ABC".=
       - * operator
         : It returns a String that repeats the text specified on the lefthand side, the number of times specified by the righthand side
         ellipsis = '.'*3 # Evaluates to '...'
         : NOTE
         : any interpolation is performed just once before the repetition is done
         a=0;
         "#{a=a+1}"*3 #Returns"111",not"123"
**** 访问字符和子字符串 accessing characters and substrings
     - 提取或改变字符串某些部分
       - single character
         : NOTE
         : if you try to access a character beyond the end of the string; it simply returns nil instead
         s='hello';
         s[0]            =# first character h=
         s[s.length-1]   =# last character o=
         s[-1]           =# another way of last character=
         s[-2]           =# second-to-last character=
         s[-s.length]    =# another way of first character=
         s[s.length]     =# nil: no character=

         : use character literals
         s[0] = ?H
         s[-1] = ?O

         : The righthand side of an assignment statement may be any string, including a multicharacter string or the empty string
         s = "hello"
         s[-1] = ""      =# hell=
         s[-1] = "p!"    =# help!=
       - substring
         : specified number of characters
         s = "hello"
         s[0,2]          =# he=
         s[-1,1]         =# "o": returns a string, not the character code ?o=
         s[0,0]          =# "": a zero-length substring is always empty=
         s[0,10]         =# "hello": returns all the characters that are available=
         s[s.length,1]   =# "": there is an empty string immediately beyond the end=
         s[s.length+1,1] =# nil: it is an error to read past that=
         s[0,-1]         =# nil: negative lengths don't make any sense=

         : delete insert
         s = "hello"
         s[0,1] = "H"    =# Replace first letter with a capital letter=
         s[s.length,0]="world" =# Append by assigning beyond the end of the string=
         s[5,0] = ","    =# Insert a comma, without deleting anything=
         s[5,6] = ""     =# Delete with no insertion s ="Hellod".=

         : range
         s = "hello"
         s[2..3]         =# ll=
         s[-3..-1]       =# llo=
         s[0..0]         =# h=
         s[0...0]        =# "": empty=
         s[2..1]         =# "": empty=
         s[7..10]        =# nil: range is outside=
         s[-2..-1] = "p!"     =# help!=
         s[0...0] = "Please " =# Please help!=
         s[6..10] = ""        =# please!=
**** 对字符串进行迭代 literating strings
     - 字符串迭代器
       - each_byte
         iterates sequentially through the individual bytes that comprise a string
       - each_char
         iterates the characters
         - it may be *more efficient* to use each_char than to use the [] operator and character indexes
           s = "¥1000"
           s.each_char {|x| print "#{x} " }        =# Prints "¥ 1 0 0 0". Ruby 1.9 0.=
           upto(s.size-1) {|i| print "#{s[i]}"}    =# Inefficient with multibyte chars=
       - each_line
         iterates the line
**** 字符串编码和多字节字符 string encodings and mutibyte characters
***** ruby1.9里的多字节字符 multibyte characters in ruby 1.9
      - 编码名称
        : ASCII-8BIT and BINARY encoding
        - You can specify this ASCII encoding as “ASCII-8BIT” or by its alias “BINARY”, one byte always equals one character
        : US-ASCII
        - 7-bit ASCII. it differs from ASCII-8BIT in that it does not allow any bytes with their 8th bit set
        : NOTE
        : if a string literal contains only 7-bit ASCII characters, then its encoding method will return ASCII, even if the source encoding is UTF-8
        : if a string literal contains \u escapes, then its encoding will be UTF-8
      - 编码方法
        : size length bytesize
        : the length and size methods return the number of characters in a string
        : the new bytesize method returns the number of bytes
        - example
          # -*- coding: utf-8 -*-       # Specify Unicode UTF-8 characters
          # This is a string literal containing a multibyte multiplication character
          s = "2×2=4"
          # The string contains 6 bytes which encode 5 characters
          s.length         =# -> 5: Characters:  '2'  '×'   '2' '=' '4' .=
          s.bytesize       =# -> 6: Bytes (hex): 32  c3 97  32  3d  34  .=
        : encoding
        : Ruby 1.9 String class defines an encoding method that returns the encoding of a string (the return value is an Encoding object
        - example
          # -*- coding: utf-8 -*-
          s = "2×2=4"   =# Note multibyte multiplication character=
          s.encoding    =# -> <Encoding: UTF-8>=
          t = "2+2=4"   =# All characters are in the ASCII subset of UTF-8=
          t.encoding    =# -> <Encoding: ASCII-8BIT>=
        : force_encoding
        : You can explicitly set the encoding of a string with force_encoding
        : the *underlying bytes of the string are not changed*, only Ruby’s interpretation of them is changed
        - example
          text = stream.readline.force_encoding("utf-8")
          bytes=text.dup.force_encoding(nil)    =# nil encoding means binary=
        : valid_encoding
        - Use valid_encoding? to perform validation
          s = "\xa4".force_encoding("utf-8")   =# This is not a valid UTF-8 string=
          s.valid_encoding?                    =# -> false=
        : encode
        : It returns a string that represents the same sequence of characters as its receiver, but using a different encoding
        : the encode method must *alter the underlying bytes that make up the string*
        - example
          # -*- coding: utf-8 -*-
          euro1 = "\u20AC"          =# unicode=
          puts euro1
          euro1.encoding            =# <Encoding:UTF-8>=
          euro1.bytesize            =# 3=

          euro2 = euro1.encode("iso-8859-15")    =# transcode=
          puts euro2.inspect                     =# print "\xA4" .=
          euro2.encoding
          euro2.bytesize                         =# 1=

          # Interpret a byte as an iso-8859-15 codepoint, and transcode to UTF-8
          byte = "\xA4"
          char = byte.encode("utf-8", "iso-8859-15")

          # the following two lines of code have the same effect
          text = bytes.encode(to, from)
          text = bytes.dup.force_encoding(from).encode(to)
        : NOTE
        : Character encodings differ not only in their mapping from bytes to characters, but in the set of characters that they can represent
        : Unicode (also known as Universal Character Set) tries to allow all characters, but character encodings not based on Unicode can only represent a subset of characters
        : therefore, Unicode characters that are neither Latin nor Japanese cannot be translated
***** encoding类 the encoding class
      - 方法
        : name
        returns the name of an encoding
        : to_s
        the same as name
        : inspect
        converts an Encoding object to a string
        : find
        - If you have an encoding name as a string and want to obtain the corresponding Encoding object, use the *Encoding.find* factory method
          encoding = Encoding.find("utf-8")
        : list
        If you want a list of available encodings, call *Encoding.list*, which returns an array of Encoding objects
        : default_external
        Use *Encoding.default_external* to obtain the Encoding object that represents the default external encoding
        : locale_charmap
        To obtain the encoding for the current locale, call *Encoding.locale_charmap* and pass the resulting string to Encoding.find.
        : TIP
        : Most methods that expect an Encoding object will also accept nil as a synonym for Encoding::BINARY (i.e., unencoded bytes)
        : You may pass Encoding objects to the encode method, but when working with encodings that are not supported by the Encoding class, you will have to specify the encoding name as a string
      - 常量
        : built-in encodings
        Encoding::ASCII_8BIT    =# Also ::BINARY=
        Encoding::UTF_8
        : dynamically loaded as needed
        US-ASCII
        ISO-8859-1 to ISO-8859-15    =# the European encodings=
        UTF-16                       =# big-endian UTF-8=
        UTF-32                       =# little-endian UFT-8=
* READING ruby on rails
** create a new rails project
*** create a template project
    $ rails new blog
    $ cd blog
    - the blog directory
      app/       controller model view helper mailer application
      bin/       rails script startup update deploy application
      config/    routes database and more
      config.ru  rack configuration
      db/        database schema migrations
      Gemfile    gem dependencies used by bundler gem
      Gemfile.lock
      lib/       extended moduel
      log/       log file
      public/    world can see static files compile assert
      Rakefile   locate and load tasks
      README.md
      test/      unit test fixture and other test apparatus
      tmp/       cache and pid files
      vendor/    third-party code
*** network
    $ bin/rails server
    http://localhost:3000
*** controllers and views
    =# create a controller with an action called index= =and create a [[route file]] [1]=
    $ bin/rails generate controller Welcome index
    =# Open the app/views/welcome/index.html.erb file, replace below code=
    <h1>Hello, Rails!</h1>
*** routes
    - edit config/routes.rb [2]
      Rails.application.routes.draw do
        get 'welcome/index'        =# get welcome/index to http://localhost:3000/welcome/index    <<route file>> [1]=
        root 'welcome#index'       =# map your request to root of welcome#index [2]=
      end
    stop and launch web server again (bin/rails server)
*** the REST CRUD operations
    : add a restfull resource
    =# You can create, read, update and destroy items for a resource and these operations are referred to as CRUD operations=
    =# Rails provides a resources method which can be used to declare a standard REST resource=
    - add the article resource to the config/routes.rb
      Rails.application.routes.draw do
        resources :articles
        root 'welcome#index'
      end
    - if you run bin/rails routes, you'll see that it has defined routes for all the standard RESTful actions
      $ bin/rails routes
            Prefix Verb   URI Pattern                  Controller#Action
          articles GET    /articles(.:format)          articles#index
                   POST   /articles(.:format)          articles#create
       new_article GET    /articles/new(.:format)      articles#new
      edit_article GET    /articles/:id/edit(.:format) articles#edit
           article GET    /articles/:id(.:format)      articles#show
                   PATCH  /articles/:id(.:format)      articles#update
                   PUT    /articles/:id(.:format)      articles#update
                   DELETE /articles/:id(.:format)      articles#destroy
              root GET    /                            welcome#index
    : error: Routing Error
    : create controller and method for the resource
    =# the route needs to have a controller defined in order to serve the request=
    - create a controller called ArticlesController
      $ bin/rails generate controller Articles
    : error: Unknown action
    =# when controllers are generated in Rails they are empty by default, unless you tell it your desired actions=
    - To manually define an action inside a controller
      class ArticlesController < ApplicationController
        def new
        end
      end
    : error: ActionController::UnknownFormat in ArticlesController#new
    =# The first part identifies which template is missing. In this case, it's the articles/new template=
    =# The next part of the message contains request.formats which specifies the format of template to be served in response (it is set html template)=
    =# The simplest template that would work in this case would be one located at app/views/articles/new.html.erb=
    =#   The extension of this file name is important:
          the first extension is the format of the template, and the second extension is the handler that will be used to render the template=
    - create a new file at app/views/articles/new.html.erb and write this content in it
      <h1>New Article</h1>
    =# then refresh http://localhost:3000/articles/new, you'll see it in the page=
*** workflow
    : 1. view
    : create form use form builder
    <%= form_for :article, url: articles_path do |f| %>  =# the articles_path helper is passed to the :url option=
      <p>
        <%= f.label :title %><br>
        <%= f.text_field :title %>
      </p>
      <p>
        <%= f.label :text %><br>
        <%= f.text_area :text %>
      </p>
      <p>
        <%= f.submit %>
      </p>
    <% end %>
    : error Unknown action
    The action 'create' could not be found for ArticlesController  =# need to create the create action within the ArticlesController for this to work=

    : 2. contriller
    : create action
    =# define a action in app/controllers/articles_controller.rb=
    class ArticlesController < ApplicationController
      def new
      end
      def create
      end
    end
    =# if you re-submit now, you may not see any change=
    =# because rails by default return s 204 No Content response for an action if you don't specify what the response should be=
    : add response by using params method
    def create
      render plain: params[:article].inspect =// [[params method]]=
    end
    =# This action is now displaying the parameters for the article that are coming in from the form=
    <ActionController::Parameters {"title"=>"First Article!", "text"=>"This is my first article."} permitted: false>
    - a example of <<params method>>
      http://www.example.com/?username=dhh&email=dhh@email.com
                                   v
                     params[:username] equal "dhh"
                                                    v
                                    params[:email] equal "dhh@email.com"

    : 3. model
    : To create the new model
    $ bin/rails generate model Article title:string text:text
    =# With that command we told Rails that we want an Article model, together with a title attribute of type string, and a text attribute of type text=

* READING programming ruby
** running ruby
*** interactive ruby
    % ruby
    puts "Hello, world!"
    ^D  =# an end of file character=
    Hello, world!

    irb
*** ruby programs
    % ruby myprog.rb

    #!/usr/local/bin/ruby -w  =# Unix shebang notation=
    puts "Hello, World!"
    % ./myprog.rb
    Hello, World!
*** ruby.new
    : Ruby Is an Object-Oriented Language
    song1 = Song.new("Ruby Tuesday")
    song2 = Song.new("Enveloped in Python")
    # and so on
    : Ruby is a genuine OO language
    "gin joint".length      » 9
    "Rick".index("c")       » 2
    -1942.abs               » 1942
    sam.play(aSong)         » "duh dum, da dum de dum ..."
    number = Math.abs(number)     // Java code
    number = number.abs           // ruby code
    strlen(name)                  // C code
    : a simple ruby function
    def sayGoodnight(name)
      result = "Goodnight, " + name  =// You don't need semicolons at the ends of statements as long as you put each statement on a separate line=
      return result
    end  =// finish the body with the keyword end=
    # Time for bed...      Ruby comments start with a # character and run to the end of the line
    puts sayGoodnight("John-Boy")
    puts sayGoodnight("Mary-Ellen")
    : specify precedence rules
    =// precedence rules can make it difficult to know which argument goes with which method invocation, so we recommend using parentheses in all but the simplest cases=
    puts sayGoodnight "John-Boy"
    puts sayGoodnight("John-Boy")
    puts(sayGoodnight "John-Boy")
    puts(sayGoodnight("John-Boy"))
    : escape
    puts "And Goodnight,\nGrandma"  =// When a string containing a newline is output, the ``\n'' forces a line break=
    produces:
    And Goodnight,
    Grandma
    : expression interpolation
    def sayGoodnight(name)
      result = "Goodnight, #{name}"  =// the sequence #{ expression } is replaced by the value of expression=
      return result
    end
    : the last expression evaluated
    def sayGoodnight(name)
      "Goodnight, #{name}"  =// The value returned by a Ruby method is the value of the last expression evaluated, so we can get rid of the return statement altogether=
    end
    : identifier
    local variables           start with lowerccase letter or with an underscore
    method parameters
    method names
    global variables          prefixed wirh $
    instance variables        begin with @
    class variables           start with @@
    class names               start with an uppercase letter
    module names
    constants
* READING java编程思想 thinking in java
** 对象入门 introduction to object
*** 抽象的进步 the progress of abstraction
    一切皆为对象
    everything is an object
    程序是一大堆对象的组合 通过消息传递 各对象指导自己该做些什么
    a program is a bunch of objects telling each other what to do by sending messages
    每个对象都有自己的存储空间
    each object has its own memory made up of other objects
    每个对象都有一种类型
    every object has a type
    同一类所有对象都能接收相同的消息
    all objects of a particular type can receive the same messages
*** 对象的接口 an object has an interface
    我们向对象发出的请求是通过它的'接口'定义的 对象的类型或类则规定了它的接口形式
    the requests you can make of an object are defined by its interface, and the type is what determines the interface
    - 以灯泡为例
      type name        light
      interface        on()  off() brighten() dim()
      light it = new light();
      it.on();
*** an object provides services
    : it helps to improve the cohesiveness of the object
    : it mean the various aspects of a software componet "fit together" well
    some of these objects always exist and for the ones that don't, what would they look like?
    what services would those objects provide and what objects would they need to fulfill their obligations?
*** 实现方案的隐藏 the hidden implementation
    强制客户端程序员遵守任何约束
    to enforce rules for client programmer
    防止程序员接触他们不该接触的东西
    to keep client programmers' hands off protions they shouldn't touch
    允许库设计人员修改内部结构 不用担心他会对客户程序员造成什么影响
    to allow the library designer to change the internal workings of the class without worrying about how it will affect the client programmer
    - java uses three explicit keywords to set the boundaries in a class
      public         element is available to everyone
      private        no one can access that element except you
      protected      an inheriting class has access to protexted members, but not private members
    - java also has a "default" access if you don't use one of the specifiers
      package access       classes can access the members of other classes in the same package (library component)
*** 方案的重复使用 reusing the implementation
    : 为重复使用一个类 直接使用那个类的对象 或由任意数量和类型的其他对象构成新类
    : the simplest way to reuse a class is to just use an object of that class directly
    : or the new class made up of any number and type of other objects
    : 新建类的时候 首先应考虑‘组织’对象 一辆车包含乐一个变速箱
    : you should first look to composition when creating new classes
*** 继承: 重新使用接口 inheritance
**** 重新使用接口 reuse base-class method
     - 使用继承时 相当于创建了一个新类 包含了类的所有成员(private成员被隐藏) 复制了基础类的接口
       when you inherit from an existing type, you create a new type.
       this new type contains not only all the members of the existing type(although the private ones are hidden away and inaccessible),
       but more important it duplicates the interface of the base class
     - 可向基础类的对象发送的所有消息亦可发给衍生类的对象
       all the messages you can send to objects of the base class you can also send to objects of the derived class
     - 继承过程中 原始类发生了变化 继承类也会反映出这种变化
     - 为衍生类添加新函数
       simply add brand new methods to the derived class
**** 改善基础类 overrideing the base-class method
     尽管使用的函数接口未变 但它的新版本具有不同的表现
     I'm using the same interface method here, but I want it to do something different for my new type
*** 多形对象互换使用 interchangeable objects with polymorphism
    - 代码示例
      =// Shape class have erase() and draw() method=
      void doSomething(Shape shape) {
        : interface for <<abstract object>>  just define the abstract name of method, there is no need to implement it
        shape.erase();
        // ...
        shape.draw();
      }
      : <<upcasting>>
      =// Circle Triangle Line is heritanced Shape=
      =// any message that doSomething() can send to a Shape, a Circle can accept=
      =// We call this process of treating a derived type as though it were its base type *upcasting*=
      Circle circle = new Circle();
      Triangle triangle = new Triangle();
      Line line= new Line();
      : <<polymorphism>>
      =// when the Java compiler is compiling the code for doSomething( ), it cannot know exactly what types it is dealing with=
      =// you’d expect it to end up calling the version of erase() and draw() for the base class Shape, and not for the specific Circle, Square, or Line. And yet the right thing happens because of polymorphism=
      doSomething(circle);
      doSomething(triangle);
      doSomething(line);
**** 上溯造型 The singly rooted hierarchy
     - [[upcasting]]
**** 动态绑定(多形性) polymorphism
     - [[polymorphism]]
**** 抽象基础类和接口 containers
     - 使用抽象类 使用抽象方法
       抽象类(基础类)不能创建对象 只为自己的衍生类提供一个接口(抽象方法)
       继承一个抽象类后抽象方法必须实现 否则继承的类也会变成抽象类
       this [[abstract object]], generally called a container, will expand itself whenever necessary to accommodate everything you place inside it.
       So you don’t need to know how many objects you’re going to hold in a container. Just create a container object and let it take care of the details.
*** 对象的创建和存在时间 object creation & lifetime
*** 违例控制: 解决错误 exception handling: dealing with errors
    - 违例控制模块是封装好的 只需编写代码调用
      Java’s exception handling stands out among programming languages, because in Java, exception handling was wired in from the beginning and you’re forced to use it
      single acceptable way to report errors. If you don’t write your code to properly handle exceptions, you’ll get a compile-time error message.
*** 多线程 concurrent programming
    java多线程机制已内建到语言中
    - 资源锁定方案
      使用synchronized 同一时间只能有一个线程使用特定的内存空间
*** java和因特网 java and the internet
    - 服务器
      Taken together, the information repository, the software that distributes the information,
        and the machine(s) where the information and software reside are called *“the server”*
    - 客户端
      The software that resides on the consumer machine, communicates with the server,
        fetches the information, processes it, and then displays it on the consumer machine is called *the client*
    - 中间件
      To minimize latency, programmers work hard to offload processing tasks,
        often to the client machine, but sometimes to other machines at the server site,
        using so-called middleware. (Middleware is also used to improve maintainability.)
    - 通用网关接口 CGI
      This submission passes through the Common Gateway Interface (CGI) provided on all Web servers
      a cgi programs can be written in most languages.
      Perl has been a common choice because it is designed for text manipulation and is interpreted.
      However, Python (www.Python.org) has been making inroads because of its greater power and simplicity.
    - 插件 plug-ins
      This is a way for a programmer to add new functionality to the browser by downloading a piece of code that plugs itself into the appropriate spot in the browser.
    - 脚本编制语言
      Plug-ins resulted in the development of browser scripting languages
      With a scripting language, you embed the source code for your client-side program directly into the HTML page,
        and the plug-in that interprets that language is automatically activated while the HTML page is being displayed
      One scripting language that you can expect a Web browser to support without a plug-in is *JavaScript*
      - 创建更丰富 更具有互动能力的图形界面
      - 能快速的解决80%的问题
        However, a scripting language might solve 80 percent of the problems encountered in client-side programming.
        Your problems might very well fit completely within that 80 percent, and since scripting languages can allow easier and faster development,
          you should probably consider a scripting language before looking at a more involved solution such as Java programming
    - java
      - 解决剩下的20%的问题
        Java is a popular solution for this.
        Not only is it a powerful programming language built to be secure, cross-platform, and international,
          but Java is being continually extended to provide language features and libraries that elegantly handle problems that are difficult in traditional programming languages,
          such as concurrency, database access, network programming, and distributed computing. Java allows client-side programming via the *applet* and with Java Web Start
      - 程序片 applet
        - 客户端程序管理
          An applet is a mini-program that will run only under a Web browser.
          When the applet is activated, it executes a program.
          This is part of its beauty—it provides you with a way to automatically distribute the client software from the server at the time the user needs the client software, and no sooner.
        - 编译形式
          Since Java is a full-fledged programming language, you can do as much work as possible on the client before and after making requests of the server
            For example, you won’t need to send a request form across the Internet to discover that you’ve gotten a date or some other parameter wrong,
            and your client computer can quickly do the work of plotting data instead of waiting for the server to make a plot and ship a graphic image back to you
          Not only do you get the immediate win of speed and responsiveness,
            but the general network traffic and load on servers can be reduced, preventing the entire Internet from slowing down
    - 服务器端编程
      - 数据库编程
        事务处理
      - 小服务程序 servlet
    - 应用程序
    - 因特网和内联网
** 一切都是对象 everything is an object
   - Although it is based on C++, Java is more of a “pure” object-oriented language
     Both C++ and Java are hybrid languages, but java is easier by shift your mindset into an object-oriented world
*** 用句柄操纵对象 you manipulate objets with references
    - 对象引用
      You treat everything as an object, using a single consistent syntax.
      Although you treat everything as an object, the identifier you manipulate is actually a “reference” to an object
      You might imagine a television (the object) and a remote control (the reference)
      - a example of String obejct reference [C]
        =// So if you want to hold a word or sentence, create a String reference=
        String s;
        =// But here you’ve created only the reference, not an object, a safer practice is always to initialize a reference when you create it=
        String s = "asdf";
*** 所有对象都必须创建 you must create all the objects
    - 创建句柄 同新对象连接
      When you create a reference, you want to connect it with a new object
      =// The keyword new says, “Make me a new one of these objects.”=
      String s = new String("asdf");
      : TIP
      What’s more important is that you can create your own types
** 操作符 operators
   at the lowest level, data in java is manipulated using operators
*** simpler print statements                                                    :ATTACH:
    :PROPERTIES:
    :Attachments: Print.java
    :ID:       7021B646-1487-4415-B4B2-975DEC1AA0AA
    :END:
    static import new library, simplify writing print statements
*** 使用Java运算符 using Java operators
**** 优先级 precedence
     
** 执行控制 controlling execution
   like a sentient creature, a program must manipulate its world and make choices during execution
*** true and false
** 初始化和清除 initialization & cleanup
   - as the computer revolution progresses, "unsafe" programming has become one of the major culprits that makes programming expensive
     two of these safety issures are initialization and cleanup
*** 用构建起自动初始化 guaranteed initialization with the constructor           :ATTACH:
    :PROPERTIES:
    :Attachments: SimpleConstructor.java SimpleConstructor2.java
    :ID:       3A94608B-89F0-4223-89CA-6C9505B84B40
    :END:
    - 创建对象时 自动调用的方法
      - simple constructor [C]
        SimpleConstructor.java
      - simple constructor with argument [C]
        SimpleConstructor2.java
      : NOTE
      - the constructor has no return value
        but you still have theoption to make it return something else
      the name of the constructor must math the name of the class exactly
*** 方法过载 method overloading                                                 :ATTACH:
    :PROPERTIES:
    :Attachments: Overloading.java
    :ID:       7121ABC5-24AF-43D3-B279-A095A25C1CCD
    :END:
    - 同名方法 不同参数
      - here's an example that shows both overloaded constructors and overloaded methods [C]
        Overloading.java
**** 区分过载方法 distinguishing overloaded methods
** 隐藏实施过程 access control
   access control (or implementation hiding) is about "not getting it right the first time"
*** 包: 库单元 package: the library unit
** 类再生 reusing classes
   one of the most compelling features about java is code reuse
*** 合成的语法 composition syntax
** 多形性 polymorphism
   polymorphism is the essential feature of an object-oriented after data abstraction and inheritance
*** 上溯造型 upcasting revisited
** 接口 interfaces
   interface and abstract classes provide more structured way to separate interface from implementation
*** 抽象类和方法 abstract classes and methods
**  内部类 inner classes
    it's possible to place a class definition within another class definition. This is called an inner class
*** creating inner classes
** 对象的容纳 holding your objects
   - it's a fairly simple program that only has a fixed quantity of objects with known lifetimes
     because your programs will always be ccreating new objects based on some criteria that will be known only at run time
     to solve the general programming problem, you need to create any number of objects, anytime, anywhere
     : TIP
     the java.util library has a reasonably complete set of container classes to solve this problem
     the basic types of which are *List, Set, Queue, and Map*
*** generics and type-safe containers
** 违例差错控制 error handling with exceptions
   the basic philosophy of java is that "badly formed code will not be run"
* WAITING javascript高级程序设计 javascript for web developers
  CLOSED: [2017-04-11 二 20:49]
** javascript简介 20 what is javascript 44
*** javasctipt简史 a short history
*** javascript实现 javascript implementations
**** 内核 ECMAScript
***** the core
      syntax
      type
      statements
      keywords
      reserved words
      operators
      objects
***** 版本 edition
***** 兼容性 comformance
**** 文档对象模型 DOM(the document object)
***** XML extened to HTML api
***** DHTML(Dynamic HTML)
***** W3C(World Wide Web Consortium)
      DOM1
        DOM Core    map XML-based document structure
        DOM HTML    add HTML-specific objectsand method
      DOM2
        DOM Views     keep track of various views (before and after CSS)
        DOM Events    interface for events and event handling
        DOM Style     deal with CSS-based styling of element
        DOM Traversal and Range
      DOM3
        DOM Load and Save
      XML DOM
        SVG
        MathML
        SMIL
**** 浏览器对象模型 BOM (the browser object)
***** interact with the browser outside of the context of its display page
      pop up new browser windows
      move resize close browser windows
      navigator (information)
      location (page loaded)
      screen (resolution)
      cookies
      XMLHttpRequest ActiveXObject
** 在HTML中使用javascript javascript in HTML
*** <script>元素 the <script> element
**** 加载<script> load <script>
     : script attributes
     - there are six attrubutes for the <script> element
       async
       src        indicates an external file that contains code to be executed
       type       default set is 'text/javascript'
     : NOTE: the <script> elements are interpreted in the order in which they appear in the page so long as the defer and async attributes are not present

     : two ways to use the <script> element
     - to include inline javascript code
       <script type=”text/javascript”>
           function sayHi(){
               alert(“Hi!”);
           }
       </script>
     - to include javascript from an external file
       <script type=”text/javascript” src=”example.js”></script>     =HTML=
       <script type=”text/javascript” src=”example.js” />            =XHTML=
     : the <script> element is its ability ti include javascript files from outside domains
     - make sure you are the domain owner or the domain is owned by a trusted source
       <script type=”text/javascript” src=”http://www.somewhere.com/afile.js”></script>
     : NOTE: a <script> element using the src attribute should not include additional javascrit code between the <script> tags
     :       if both are provided, the inline code is ignored
**** 标签的位置 tag placement
     : traditionally, all <script> elements were placed within the <head> element on a page
     : but for pages that require a lot of javascript code, this can cause a noticeable delay in page rendering, during which time the browser will be completely blank
     : for this reason, modern web applications typically include all javascript references in the <body> element
     <!DOCTYPE html>
     <html>
       <head>
         <title>Example HTML Page</title>
         =<script type=”text/javascript”= =src=”example1.js”></script>=
         =<script type=”text/javascript”= =src=”example2.js”></script>=
       </head>
       <body>
         <!-- content here -->
         *<script type=”text/javascript” src=”example1.js”></script>*
         *<script type=”text/javascript” src=”example2.js”></script>*
       </body>
     </html>
**** 延迟脚本 deferred scripts
     : You can defer a script’s execution until after the document has rendered by using the *defer* attribute
     - setting /defer/ element in <script> signals to the browser that download should begin immediately but execution should be deferred
       ...
         <script type=”text/javascript” defer src=”example1.js”></script>            =HTML=
         <script type=”text/javascript” defer="defer" src=”example1.js”></script>    =XHTML=
       ...
     : NOTE: the defer attribute is supported only for external script files, this was a clarificaton made in HTML5
     :       not all browser support defer attribute (except IE firefox safari chrome)
     :       it's best to put deferred script at the bottom of the page
**** 异步脚本 asynchronous scripts
     : HTML5 introduces the async attribute for <script> elements
     : You can indicate that a script need not wait for other scripts and also not block the document rendering by using the *async* attribute.
     - for example
       ...
         <script type=”text/javascript” async src=”example1.js”></script>          =HTML=
         <script type=”text/javascript” async="async" src=”example1.js”></script>  =XHTML=
       ...
     : NOTE: it's important that there are no dependencies between two async script files
     :       it's recommended that asynchronous scripts not modify the DOM as they are loading
     :       only firefox safari and chrome support asyc script
*** 嵌入代码与外部文件 inline code versus external files
    : Although it’s possible to embed JavaScript in HTML files directly,
    : it’s generally considered a best practice to include as much JavaScript as possible using external files.
    - the arguments for using external files are as follows:
      maintainability
        for all javascript files to have a directory, so developers can edit javascript code independent without HTML markup
      caching
        if two pages are using the same file, the file is downloaded onlu once
*** 文档模式 document modes
    : the concept of document modes through the use of doctype switching
    - standards mode
      <!-- HTML 4.01 Strict -->
      <!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01//EN” “http://www.w3.org/TR/html4/strict.dtd”>

      <!-- XHTML 1.0 Strict -->
      <!DOCTYPE html PUBLIC
      “-//W3C//DTD XHTML 1.0 Strict//EN” “http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd”>

      <!-- HTML5 --> <!DOCTYPE html>
*** <noscript>元素 the <noscript> element
    : the <noscript> element was created to provide alternate content for browsers without JavaScript.
    - a simple example
      <!DOCTYPE html>
      <html>
        <head>
          <title>Example HTML Page</title>
          <script type=”text/javascript” defer=”defer” src=”example1.js”></script> <script type=”text/javascript” defer=”defer” src=”example2.js”></script>
        </head>
        <body>
          *<noscript>*
            *<p>This page requires a JavaScript-enabled browser.</p>*
          *</noscript>*
        </body>
      </html>
    : NOTE: the content inside the <noscript> element will be rendered only if either of these conditions is met
    :       > the browser doesn't support scripting
    :       > the browser's scripting support is turned off.
** 基本概念 language basic
*** 语法 syntax
**** 区分大小写 case-sensitivity
     typeof 是函数名
     typeOf 可以是一个有效的函数名
**** 标识符 identifiers
     - 标识符
       An identifier is the name of a variable, function, property, or function argument
       The first character must be a letter, an underscore (_), or a dollar sign *($)*
       : NOTE
       Keywords, reserved words, true, false, and null cannot be used as identifiers
**** 注释 comments
     - 单行注释
       //single line comment
     - 多行注释
       : Note that even though the second and third lines contain an asterisk, these are not necessary and are added purely for readability
       /*
        * This is a multi-line * Comment
        */
**** 严格模式 strict mode
     - 概念
       Strict mode is a different parsing and execution model for JavaScript
       where some of the erratic behavior of ECMAScript 3 is addressed and errors are thrown for unsafe activities
       - To enable strict mode for an entire script, give this to the top of script
         “use strict”;
       - specify just a function to execute in strict mode by including the pragma at the top of the function body
         function doSomething(){
           “use strict”;
           //function body
         }
**** 语句 statement
     - 推荐语句结构
       var sum = a + b //valid even without a semicolon - not recommended
       var diff = a - b; //valid - preferred

       if (test)
         alert(test);    //valid, but error-prone and should be avoided

       if (test){        //preferred
         alert(test);
       }
**** 关键字和保留字 keywords and presrved words
     [En 70]
* READING You Don't Know JS
** Up & Going
*** forward
    Up & Going is the start of our path to understanding programming. Enjoy the lightbulb moments!
*** preface
    JavaScript is awesome. It's easy to learn partially, and much harder to learn completely (or even sufficiently)
    This You Don't Know JavaScript book series offers a contrary challenge: learn and deeply understand all of JavaScript, even and especially "The Tough Parts"
*** into programming
    : introduced the basic building blocks of programming
    looking to these books to help get you started along a path to understanding programming through the lens of JavaScript
**** code
     A program, often referred to as source code or just code, is a set of special instructions to tell the computer what tasks to perform
***** statements
      - a = b * 2;
       : expressions
       2 =is a literal value expression=
       b =is a variable expression, which means to retrieve its current value=
       b * 2 =is an arithmetic expression, which means to do the multiplication=
       a = b * 2 =is an assignment expression, which means to assign the result of the b * 2 expression to the variable a (more on assignments later)=
       alert( a ); =expression statement, as the entire statement is the function call expression itself=
**** console
     - output
      console.log( b );
      alert( b );
     - input
      age = prompt( "Please tell me your age:" );
      console.log( age );
     - operator
       : You need operators to perform actions on values
       - Compound Assignment
        +=, -=, *=, and /=
       - Increment/Decrement
        ++ , --
       - Equality
        == (loose-equals), === (strict-equals), != (loose not-equals), !== (strict not-equals)
       - Logical
        && (and), || (or)
**** values & types
     : You need values and types to perform different kinds of actions like math on numbers or output with strings
     - When you need to print a value on the screen, you need a string (one or more characters, words, sentences)
       "I am a string";
       'I am also a string';
     - When you need to do math, you want a number
       42;
     - When you need to make a decision in your program, you need a boolean (true or false).
       true;
       false;
**** Converting Between Types
     var a = "42";
     var b = Number( a );
     console.log( a );       // "42"
     console.log( b );       // 42
     : NOTE
     "99.99" == 99.99
**** Code Comments
     - Comments should explain why, not what. They can optionally explain how if that's particularly confusing
       // This is a single-line comment

       /* But this is
          a multiline
          comment. */

       : var a = /* multiline commen can be anywhere */ 42;
**** variable
     : You need variables to store data (aka state) during your program's execution
     const TAX_RATE = 0.08;  =// as of ES6: If you tried to assign any different value to TAX_RATE after that first declaration, your program would reject the change=
     var amount = 99.99;
**** Conditionals
     : You need conditionals like if statements to make decisions
     // can we afford the extra purchase?
     if ( amount < bank_balance ) {
             console.log( "I'll take the accessory!" );
             amount = amount + ACCESSORY_PRICE;
     }
     // otherwise:
     else {
             console.log( "No, thanks." );
     }

     for (var i = 0; i <= 9; i = i + 1) {
             console.log( i );
     }
     // 0 1 2 3 4 5 6 7 8 9
**** loops
     : You need loops to repeat tasks until a condition stops being true
     while (numOfCustomers > 0) {
             console.log( "How may I help you?" );
             // help the customer...
             numOfCustomers = numOfCustomers - 1;
     }
     // versus:
     do {
             console.log( "How may I help you?" );
             // help the customer...
             numOfCustomers = numOfCustomers - 1;
     } while (numOfCustomers > 0);
**** function
     : You need functions to organize your code into logical and reusable chunks
     function printAmount() {
        console.log( amount.toFixed( 2 ) );
     }
     var amount = 99.99;
     printAmount(); // "99.99"

     function printAmount(amt) {
             console.log( amt.toFixed( 2 ) );
     }
     var amount = 99.99;
     printAmount( amount * 2 );              // "199.98"
*** into javascript
    : want to focus specifically on things you need to know about JavaScript to get up and going as a JS developer
    - Your journey to deeply learn JavaScript starts here
      : NOTE
      If you happen to be using an older, pre-ES6 browser, the code may not work
**** Values & Types
     : JavaScript provides a typeof operator that can examine a value and tell you what type it is
     - string
       a = "hello world";
       typeof a;                               // "string"
     - number
       a = 42;
       typeof a;                               // "number"
     - boolean
       a = true;
       typeof a;                               // "boolean"
     - null and undefined
       a = null;
       typeof a;                               // "object" -- weird, bug   NOTE: This is a long-standing bug in JS, but one that is likely never going to be fixed

       var a;
       typeof a;                               // "undefined"

       a = undefined;
       typeof a;                               // "undefined"  explicitly setting a to the undefined value
     - object
       a = { b: "c" };
       typeof a;                               // "object"
     - symbol (new to ES6)
**** Objects
     : a compound value where you can set properties (named locations) that each hold their own values of any type
     var obj = {
             a: "hello world",
             b: 42,
             c: true
     };
     : Properties can either be accessed with dot notation or bracket notation
     - dot notation
       obj.a;          // "hello world"
       obj.b;          // 42
       obj.c;          // true
     - Bracket notation
       : Bracket notation is useful if you have a property name that has special characters in it, like obj["hello world!"]
       obj["a"];       // "hello world"
       obj["b"];       // 42
       obj["c"];       // true
       : it is also useful if you want to access a property/key but the name is stored in another variable
       var b = "a";
       obj[b];                 // "hello world"
       obj["b"];               // 42
**** arrays
     : An array is an object that holds values (of any type) not particularly in named properties/keys, but rather in numerically indexed positions
     var arr = [
             "hello world",
             42,
             true
     ];
     : use 0 as the index of the first element in the array
     arr[0];                 // "hello world"
     arr[1];                 // 42
     arr[2];                 // true
     arr.length;             // 3
     : Because arrays are special objects, they can also have properties, including the automatically updated length property
     typeof arr;             // "object"
     : NOTE
     The best and most natural approach is to use arrays for numerically positioned values and use objects for named properties
**** functions
     : functions are a subtype of objects
     function foo() {
        return 42;
     }
     : only use function object properties (like foo.bar) in limited cases
     foo.bar = "hello world";
     typeof foo.bar;         // "string"
     : typeof returns "function", which implies that a function is a main type
     typeof foo;             // "function"
     typeof foo();           // "number"
     : TODO
     see the first two chapters of the Types & Grammar title for more imformation
**** build-in type method
     : JS automatically "boxes" the value to its object wrapper counterpart (hidden under the covers)
     : A string value can be wrapped by a String object
     var a = "hello world";
     a.toUpperCase();                // "HELLO WORLD"
     a.length;                               // 11
     : a number can be wrapped by a Number object
     var b = 3.14159;
     b.toFixed(4);                   // "3.1416"
     : a boolean can be wrapped by a Boolean object
     : TODO
     For more information on JS natives and "boxing," see Chapter 3 of the Types & Grammar title of this series
**** Comparing Values
     : There are two main types of value comparison that you will need to make in your JS programsy: equality and inequalit
     The result of any comparison is a strictly boolean value (true or false), regardless of what value types are compared
**** Coercion
     : Coercion comes in two forms in JavaScript: explicit and implicit
     - Explicit coercion
       : Explicit coercion is simply that you can see obviously from the code that a conversion from one type to another will occur
       var a = "42";
       var b = Number( a );
       a;                              // "42"
       b;                              // 42 -- the number!
     - Implicit coercion
       : implicit coercion is when the type conversion can happen as more of a non-obvious side effect of some other operation.
       var a = "42";
       var b = a * 1;  // "42" implicitly coerced to 42 here
       a;                              // "42"
       b;                              // 42 -- the number!
       : TODO
       Chapter 4 of the Types & Grammar title of this series covers all sides
**** Truthy & Falsy
     : when a non-boolean value is coerced to a boolean, it become truthy or falsy
     - list of falsy
       "" (empty string)
       0, -0, NaN (invalid number)
       null, undefined
       false
     - Any value that's not on this falsy list is truthy
       "hello"
       42
       true
       [ ], [ 1, "2", 3 ] (arrays)
       { }, { a: 42 } (objects)
       function foo() { .. } (functions)
**** Equality
     var a = "42";
     var b = 42;
     : == checks for value equality with coercion allowed
     : "42" becomes 42, to make the comparison 42 == 42
     a == b;                 // true
     :  === (often called "strict eauality") checks for value equality without allowing coercion
     a === b;                // false
     : You should take special note of the == and === comparison rules if you're comparing two non-primitive values, like objects
     : Because those values are actually held by reference, For example, arrays are by default coerced to strings
     var a = [1,2,3];
     var b = [1,2,3];
     var c = "1,2,3";
     a == c;         // true
     b == c;         // true
     a == b;         // false

     : TIP
     - the rule to use == and ===
       If you can be certain about it is a comparison of variable values, and == is safe
       If you can't be certain about it, use ===
     : TODO
     Chapter 4 of the Types & Grammar title
**** inequality
     - The <, >, <=, and >= operators are used for inequality, referred to in the specification as "relational comparison."
       var a = 41;
       var b = "42";
       var c = "43";
       a < b;          // true
       b < c;          // true

       var a = 42;
       var b = "foo";
       a < b;          // false
       a > b;          // false
       a == b;         // false
     : TODO
     consult Chapter 4 of the Types & Grammar title
**** variables
     An identifier must start with a-z, A-Z, $, or _. It can then contain any of those characters plus the numerals 0-9
     certain words cannot be used as variables, These words are called "reserved words," and include the JS keywords (for, in, if, etc.) as well as null, true, and false
     : TODO
     Appendix A of the Types & Grammar title
**** Function Scopes
     : You use the var keyword to declare a variable that will belong to the current function scope, or the global scope if at the top level outside of any function
     - this behavior is called hoisting, when a var declaration is conceptually "moved" to the top of its enclosing scope
       var a = 2;
       foo();
       function foo() {
       a = 3;
       console.log( a );       // 3
         var a;
       }
       console.log( a );       // 2
       : WARM
       Avoiding it, it can be quite confusing
**** Nested Scopes
     - When you declare a variable, it is available anywhere in that scope, as well as any lower/inner scopes
       : NOTE
       : Notice that c is not available inside of bar(), because it's declared only inside the inner baz() scope, and that b is not available to foo() for the same reason
       function foo() {
               var a = 1;

               function bar() {
                       var b = 2;

                       function baz() {
                               var c = 3;

                               console.log( a, b, c ); // 1 2 3
                       }

                       baz();
                       console.log( a, b );            // 1 2
               }

               bar();
               console.log( a );                               // 1
       }
     - it will auto change to global variable, if you not formally declare variable
       : This is a very bad practice. Don't do it! Always formally declare your variables
       function foo() {
         a = 1;  // `a` not formally declared
       }

       foo();
       a;                      // 1 -- oops, auto global variable :(
     - ES6 lets you declare variables to belong to individual block
       : Because of using let instead of var, b will belong only to the if statement and thus not to the whole foo() function's scope. Similarly, c belongs only to the while loop
       function foo() {
               var a = 1;

               if (a >= 1) {
                       let b = 2;

                       while (b < 5) {
                               let c = b * 2;
                               b++;

                               console.log( a + c );
                       }
               }
       }

       foo();
       // 5 7 9
     : TODO
     ES6 & Beyond title of this series
**** Conditionals
     - JavaScript provides a few other conditionals mechanisms that we should take a look at
       : a series of if..else..if statements
       if (a == 2) {
               // do something
       }
       else if (a == 10) {
               // do another thing
       }
       else if (a == 42) {
               // do yet another thing
       }
       else {
               // fallback to here
       }
       : the switch statement, a better statement because you don't need to specify the a test for each case
       switch (a) {
               case 2:
                       // do something
                       break;
               case 10:
                       // do another thing
                       break;
               case 42:
                       // do yet another thing
                       break;
               default:
                       // fallback to here
       }
       : Here, if a is either 2 or 10, it will execute the "some cool stuff" code statements
       switch (a) {
               case 2:
               case 10:
                       // some cool stuff
                       break;
               case 42:
                       // other stuff
                       break;
               default:
                       // fallback
       }
       : conditional operator
       var a = 42;

       var b = (a > 41) ? "hello" : "world";

       // similar to:

       // if (a > 41) {
       //    b = "hello";
       // }
       // else {
       //    b = "world";
       // }
     : TODO
     Types & Grammar title
**** Strict Mode
     : strict mode will keeping the code safer and more optimaizable by the engine
     - You can opt in to strict mode for an individual function, or an entire file
       : for an individual function
       function foo() {
               "use strict";

               // this code is strict mode

               function bar() {
                       // this code is strict mode
               }
       }

       // this code is not strict mode

       : for an entire file
       Compare that to:

       "use strict";

       function foo() {
               // this code is strict mode

               function bar() {
                       // this code is strict mode
               }
       }

       // this code is strict mode
     - strict mode is disallowing the implicit auto-global variable declaration from omitting the var
       function foo() {
               "use strict";   // turn on strict mode
               a = 1;                  // `var` missing, ReferenceError
       }

       foo();
     : TODO
     the Chapter 5 of the Types & Grammar title
**** Functions As Values
     : Not only can you pass a value (argument) to a function, but a function itself can be a value that's assigned to variables, or passed to or returned from other functions
     - As such, a function value should be thought of as an expression, much like any other value or expression
       : The first function expression assigned to the foo variable is called anonymous because it has no name
       var foo = function() {
               // ..
       };
       : The second function expression is named (bar), even as a reference to it is also assigned to the x variable
       var x = function bar(){
               // ..
       };
       : TODO
       Scope & Closures title
**** Immediately Invoked Function Expressions (IIFEs)
     - a way to execute a funtion expression immediately, which is typically referred to as an immediately invoked function expression (<<IIFE>>)
       : listing the (function IIFE(){ .. }) before its executing ()
       // `IIFE` function expression,
       // then `()` executes it
       (function IIFE(){ .. })();
       : including foo before its executing ()
       function foo() { .. }
       // `foo` function reference expression,
       // then `()` executes it
       foo();
       : As you can see, in both cases, the function reference is executed with () immediately after it

       : variable scope
       var a = 42;
       (function IIFE(){
               var a = 10;
               console.log( a );       // 10
       })();
       console.log( a );               // 42

       : return values
       var x = (function IIFE(){
        return 42;
       })();
       x;      // 42
**** Closure
     : It will be one of the most important techniques in your JS skillset
     - You can think of closure as a way to "remember" and continue to access a function's scope (its variables) even the function has finished running
       function makeAdder(x) {
               // parameter `x` is an inner variable

               // inner function `add()` uses `x`, so
               // it has a "closure" over it
               function add(y) {
                       return y + x;
               };

               return add;
       }
       : The reference to the inner add(..) function that gets returned with each call to the outer makeAdder(..) is able to remember whatever x value was passed in to makeAdder(..)
       // When we call makeAdder(1), we get back a reference to its inner add(..) that remembers x as 1. We call this function reference plusOne(..)
       var plusOne = makeAdder( 1 );

       // When we call makeAdder(10), we get back another reference to its inner add(..) that remembers x as 10. We call this function reference plusTen(..)
       var plusTen = makeAdder( 10 );

       // When we call plusOne(3), it adds 3 (its inner y) to the 1 (remembered by x), and we get 4 as the result
       plusOne( 3 );           // 4  <-- 1 + 3
       plusOne( 41 );          // 42 <-- 1 + 41

       // When we call plusTen(13), it adds 13 (its inner y) to the 10 (remembered by x), and we get 23 as the result
       plusTen( 13 );          // 23 <-- 10 + 13
**** modules
     : Modules let you define private implementation details (variables, functions) that are hidden from the outside world, as well as a public API that is accessible from the outside
     - The User() function holds the variables username and password, as well as the inner doLogin() function; these are all private that cannot be accessed from the outside world
       function User(){
               var username, password;
               =// doLogin()=
               =// 1. The inner doLogin() function has a closure over username and password, meaning it will retain them even after the User() function finishes running=
               function doLogin(user,pw) {
                       username = user;
                       password = pw;

                       // do the rest of the login work
               }
               =// publicAPI=
               =// 1. publicAPI is an object with one property/method on it=
               =// 2. When we return publicAPI from User(), it becomes the instance we call fred=
               var publicAPI = {
                       =// login=
                       =// login which is a reference to the inner doLogin() function    <<why>>=
                       login: doLogin
               };

               return publicAPI;
       }

       // create a `User` module instance
       =// User()=
       =// 1. NOTE: We are not calling new User() here, User() is just a function, not a class to be instantiated=
       =// 2. Executing User() creates an instance of the User module--a whole new scope instance is created we assign to fred=
       =//    If we run User() again, we'd get a new instance entirely separate from fred=
       var fred = User();

       =// fred.login=
       =// That's [[why]] we can call fred.login(..) -- the same as calling the inner doLogin(..)=
       fred.login( "fred", "12Battery34!" );
       =// At this point, you'd think the inner variables like username and password have gone away=
       =// But here they have not, because there's a closure in the login() function keeping them alive=
     : TODO
     the Scope & Closures title of this serie
**** this identiier
     - If a function has a *this* reference inside it, that this reference usually points to an object
       function foo() {
               console.log( this.bar );
       }
       var bar = "global";

       var obj1 = {
               bar: "obj1",  =// <<obj1.bar>>=
               foo: foo
       };

       var obj2 = {
               bar: "obj2"   =// <<obj2.bar>>=
       };

       // --------
       =// to understand what this points to=

       =// 1. *this* will get the global object in non-strict mode=
       =//    in strict mode, this would be undefined and you'd get an error=
       =// 2. set *this* to reference obj1 object's bar([[obj1.bar]])=
       =// 3. set *this* to reference obj2 object's bar([[obj2.bar]])=
       =// 4. set *this* to a brand new empty object=
       foo();                          // 1. "global"
       obj1.foo();                     // 2. "obj1"
       foo.call( obj2 );               // 3. "obj2"
       new foo();                      // 4. undefined
     : TODO
     in the this & Object Prototypes title
**** Prototypes
     : The most common way this feature is used to try to emulate/fake a "class" mechanism with "inheritance"
     : But a more natural way of applying prototypes is a pattern called "behavior delegation", where you intentionally design your linked objects delegate from one to the other
     - When you reference a property on an object, if that property doesn't exist, JavaScript will automatically use that object's internal prototype reference to find another object to look for the property on
       var foo = {
               a: 42
       };

       // create `bar` and link it to `foo` =use build-in utility called Object.create(..)=
       var bar = Object.create( foo );

       bar.b = "hello world";

       =// The a property doesn't actually exist on the bar object, but because bar is prototype-linked to foo, JavaScript automatically falls back to looking for a on the foo object, where it's found=
       bar.b;          // "hello world"
       bar.a;          // 42 <-- delegated to `foo`
     : TODO
     see Chapters 4-6 of the this & Object Prototypes title
**** Old & New
     In fact, some of the newest features in the specification aren't even implemented in any stable browsers yet
     : There are two main techniques you can use to "bring" the newer JavaScript stuff to the older browsers: polyfilling and transpiling
**** Polyfilling
     The word "polyfill" is an invented term used to refer to taking the new feature and producing a piece of code that's equivalent to the behavior is able to run in older JS environments
**** Transpiling
     the better option is to use a tool that converts your newer code into older code equivalents
     This process is commonly called "transpiling," a term for transforming + compiling
     - There are quite a few great transpilers for you to choose from
       * Babel (https://babeljs.io) (formerly 6to5): Transpiles ES6+ into ES5
       * Traceur (https://github.com/google/traceur-compiler): Transpiles ES6, ES7, and beyond into ES5
**** Non-JavaScript
     : The reality is that most JS is written to run in and interact with environments like browsers
     A good chunk of the stuff that you write in your code is, strictly speaking, not directly controlled by JavaScript
     - The most common non-JavaScript JavaScript you'll encounter is the DOM API
       =// Moreover, the getElementById(..) method on document looks like a normal JS function,
          but it's just a thinly exposed interface to a built-in method provided by the DOM from your browser=
       var el = document.getElementById( "foo" );
     - Another example is with input/output (I/O)
       alert(..) is provided to your JS program by the browser, not by the JS engine itself
       The call you make sends the message to the browser internals and it handles drawing and displaying the message box
*** into YDKJS
    : I'm going to use this final chapter to briefly summarize what to expect from the rest of the books in the series
    : and how to most effectively go about building a foundation of JS learning on top of YDKJS
**** Scope & Closures
     : The JS engine compiles your code right before (and sometimes during!) execution. So we use some deeper understanding of the compiler's approach to our code
     :   to understand how it finds and deals with variable and function declarations

     : This critical understanding of "lexical scope" is what we then base our exploration of closure on for the last chapter of the book

     : The module pattern is perhaps the most prevalent code organization pattern in all of JavaScript
     : deep understanding of it should be one of your highest priorities
**** this & Object Prototypes
     : The this keyword is dynamically bound based on how the function in question is executed

     : it's more appropriate to learn prototype system, which is more appropriately named "behavior delegation"
     : Delegation is an entirely different, and more powerful, design pattern, one that replaces the need to design with classes and inheritance
**** Types & Grammar
     : this series primarily focuses on tackling yet another highly controversial topic: type coercion

     : By far, the conventional wisdom is that implicit coercion is a "bad part" of the language and should be avoided at all costs
     : I say no. After having built up an understanding of how types and values really work,
     :   I'm asserting that coercion is an incredibly useful and totally underestimated tool that you should be using in your code
**** Async & Performance
     : the title branches out slightly to cover patterns on top of the language mechanics for managing asynchronous programming

     : we move into examining callbacks as the primary method of enabling asynchrony
     : But we quickly see that the callback alone is insufficient for the modern demands of asynchronous programming with two reason:
     :    3. Inversion of Control (IoC) trust loss and 4. lack of linear reason-ability
     : To address these, ES6 introduces two new mechanisms: 1. promises and 2. generators
     : 1. Promises are a time-independent wrapper around a "future value,"
     :    which lets you reason about and compose them regardless of if the value is ready or not yet. Moreover,
     :    they effectively solve the 3. IoC trust issues by routing callbacks through a trustable and composable promise mechanism
     : 2. Generators introduce a new mode of execution for JS functions, whereby the generator can be paused at yield points and be resumed asynchronously later.
     :    The pause-and-resume capability enables synchronous, sequential looking code in the generator to be processed asynchronously behind the scenes.
     :    By doing so, we address the 4. non-linear, non-local-jump confusions of callbacks and thereby make our asynchronous code sync-looking so as to be more reason-able.

     : the combination of 1. promises and 2. generators that "yields" our most effective asynchronous coding pattern to date in JavaScript
     : much of the future sophistication of asynchrony coming in ES7 and later will certainly be built on this foundation.

     : Chapter 5 delves into topics like program parallelism with Web Workers and data parallelism with SIMD, as well as low-level optimization techniques like ASM.js

     : Chapter 6 takes a look at performance optimization from the perspective of proper benchmarking techniques,
     :    including what kinds of performance to worry about and what to ignore.
**** ES6 & Beyond
     : This title is dedicated to both the short- and mid-term visions of where the language is headed, not just the known stuff like ES6 but the likely stuff beyond.

     : we'll never fully know every part of JS, because as soon as you master it all, there's going to be new stuff coming down the line that you'll need to learn
** Types & Grammar
*** foreword
    Types and Grammar, the third installment of the series, is an excellent look at the core JavaScript fundamentals
     Coercion and its pitfalls, natives as constructors, and the whole gamut of JavaScript basics
*** Types
    - what the ES5.1 specificatio the type
       Types are further sub classified into ECMAScript language types and specification types
       The ECMAScript language types are Undefined, Null, Boolean, String, Number, and Object
    - what the author specification the type
      : a type is an intrinsic, built-in set of characteristics that uniquely identifies the behavior of a particular value
      : and distinguishes it from other values,
      : both to the engine and to the developer
**** A Type By Any Other Name...
     there are many different ways that such coercion can happen
     Some of these ways are explicit, easy to reason about, and reliable
     But if you're not careful, coercion can happen in very strange and surprising ways
**** Built-in Types
     - JavaScript defines seven built-in types
       - object
         typeof { life: 42 }  === "object";    // true
         - null
           : null is the only primitive value that is "falsy" (aka false-like; see Chapter 4) but that also returns "object" from the typeof check
           typeof null === "object"; // true
         - function
           : a function is referred to an object type that has an internal property that allows it to be invoked
           typeof function a(){ /* .. */ } === "function"; // true
           function a(b,c) {
                   /* .. */
           }
           a.length; // 2
         - array
           : It's a "subtype" of objectand maintaining an automatically updated .length property
           typeof [1,2,3] === "object"; // true
       - undefined
         typeof undefined     === "undefined"; // true
       - boolean
         typeof true          === "boolean";   // true
       - number
         typeof 42            === "number";    // true
       - string
         typeof "42"          === "string";    // true
       - symbol -- added in ES6!
         // added in ES6!
         typeof Symbol()      === "symbol";    // true
**** Values as Types
     : JS doesn't have "type enforcement"
     Variables don't have types, but the values in them do
     These types define intrinsic behavior of the values

     : engine doesn't insist that a variable always holds values of the same initial type
     : A variable can, in one assignment statement, hold a string, and in the next hold a number, and so on
     - "42" with the string type, can be created from the number value 42 through a process called coercion
       var a = 42;
       typeof a;            // "number"
       a = true;
       typeof a;            // "boolean"
       typeof typeof 42;    // "string"    =(The first typeof 42 returns "number", and typeof "number" is "string")=
**** undefined vs "undeclared"
     : Many developers will assume 1. "undefined" and 2. "undeclared" are roughly the same thing, but in JavaScript, they're quite different
     - 1. undefined is a value that a declared variable can hold
       : An "undefined" variable is one that has been declared in the accessible scope but at the moment has no other value in it
       typeof a;    // "undefined"
       var b = 42;
       var c;
       b = c;
       typeof b;    // "undefined"
       typeof c;    // "undefined"
     - 2. undeclared means a variable has never been declared
       : an "undeclared" variable is one that has not been formally declared in the accessible scope
       var a;
       a; // undefined
       b; // undeciared  =ReferenceError: b is not defined=
       typeof b; // "undefined"  =This is a special [[safety guard]] in the behavior of typeof=
**** typeof Undeclared
     - the <<safety guard>> (preventing an error) on typeof when used against an undeclared variable can be helpful in certain cases
       - it is useful if you're not dealing with user-defined variables (like debug)
         : imagine having a "debug mode" in your program that is controlled by a global variable (flag) called 1. DEBUG
         : the declaration of global var 1. DEBUG would only be included in a "debug.js" file,
         :   which you only load into the browser when you're in development/testing, but not in production
         // oops, this would throw an error!
         if (DEBUG) {
                 console.log( "Debugging is starting" );
         }

         // this is a safe existence check   =<<debug-enable>>=
         if (typeof DEBUG !== "undefined") {
                 console.log( "Debugging is starting" );
         }
       - doing a feature check
         : Imagine a utility function that you want others to copy-and-paste into their programs or modules
         :   in which you want to check to see if the including program has defined a certain variable (so that you can use it) or not:
         if (typeof atob === "undefined") {  =<<feature-check>>=
                 atob = function() { /*..*/ };
         }

         =// global function variable=
         =// doSomethingCool() tests for a variable called FeatureXYZ, and if found, uses it, but if not, uses its own.=
         =// if someone includes this utility in their module/program, it safely checks if they've defined FeatureXYZ or not=
         function doSomethingCool() {
                 var helper =
                         (typeof FeatureXYZ !== "undefined") ?
                         FeatureXYZ :
                         function() { /*.. default feature ..*/ };
                 var val = helper();
                 // ..
         }

         =// an [[IIFE]] ("Immediately Invoked Function Expressions")=
         =// Here, FeatureXYZ is not at all a global variable, but we're still using the safety guard of typeof to make it safe to check for=
         =// And importantly, here we can't use the object (like we did for global variables with window.___) to make the check, so typeof is quite helpful=
         (function(){
                 function FeatureXYZ() { /*.. my XYZ feature ..*/ }
                 // include `doSomethingCool(..)`
                 function doSomethingCool() {
                         var helper =
                                 (typeof FeatureXYZ !== "undefined") ?
                                 FeatureXYZ :
                                 function() { /*.. default feature ..*/ };
                         var val = helper();
                         // ..
                 }
                 doSomethingCool();
         })();

         =// dependency injection=
         =// doSomethingCool() inspecting implicitly for FeatureXYZ is to be defined outside/around it, it would need to have the dependency explicitly passed in=
         function doSomethingCool(FeatureXYZ) {
                 var helper = FeatureXYZ ||
                         function() { /*.. default feature ..*/ };
                 var val = helper();
                 // ..
         }
     - Another way of using global variable instead the safety guard
       : observe that all global variables are also properties of the global object, which in the browser is basically the window object
       : NOTE
       : manually referencing the global variable with a window reference is something some developers prefer to avoid
       :   especially if your code needs to run in multiple JS environments (not just browsers, but server-side node.js) where the global variable may not always be called window
       if (window.DEBUG) {  =// [[debug-enable]]=
               // ..
       }

       if (!window.atob) {  =// [[feature-check]]=
               // ..
       }
*** values
    : Let's look at several of the built-in value types in JS, and explore how we can more fully understand and correctly leverage their behaviors
**** Arrays
     : As compared to other type-enforced languages, JavaScript arrays are just containers for any type of value,
     :   from string to number to object to even another array (which is how you get multidimensional arrays)
     var a = [ 1, "2", [3] ];
     a.length;               // 3
     a[0] === 1;             // true
     a[2][0] === 3;  // true
     : You don't need to presize your arrays (see "Arrays" in Chapter 3), you can just declare them and add values as you see fit
     var a = [ ];
     a.length;       // 0
     a[0] = 1;
     a[1] = "2";
     a[2] = [ 3 ];
     a.length;       // 3
     : NOTE
     : Using delete on an array value will remove that slot from the array,
     :   but even if you remove the final element, it does not update the length property, so be careful
     : Be careful about creating "sparse" arrays (leaving or creating empty/missing slots)
     a[0] = 1;
     // no `a[1]` slot set here
     a[2] = [ 3 ];
     a[1];           // undefined  =TODO  it will not behave the same as if the slot is explicitly set (a[1] = undefined). See "Arrays" in Chapter 3 for more information=
     a.length;       // 3

     : you can have string keys/properties added to array (but which don't count toward the length of the array)
     var a = [ ];
     a[0] = 1;
     a["foobar"] = 2;
     a.length;               // 1
     a["foobar"];    // 2
     a.foobar;               // 2
     : if a string value intended as a key can be coerced to a standard base-10 number, then it is assumed that you wanted to use it as a number index rather than as a string key
     var a = [ ];
     a["13"] = 42;
     a.length; // 14
     : NOTE
     : Generally, it's not a great idea to add string keys/properties to arrays
     :   Use objects for holding values in keys/properties, and save arrays for strictly numerically indexed values
**** Array-Like
     : There will be occasions where you need to convert an array-like value (a numerically indexed collection of values) into a true array,
     :   usually so you can call array utilities (like indexOf(..), concat(..), forEach(..), etc.) against the collection of values
     function foo() {
             var arr = Array.prototype.slice.call( arguments );  =// If slice() is called without any other parameters, the default values is duplicating the array (or, in this case, array-like)=
          =// var arr = Array.from( arguments );  As of ES6, there's also a built-in utility called Array.from(..) that can do the same task  TODO: in detail in the ES6 & Beyond title of this series=
             arr.push( "bam" );
             console.log( arr );
     }
     foo( "bar", "baz" ); // ["bar","baz","bam"]
**** Strings
     : strings are somewhat "array-like"
     var a = "foo";           // string
     var b = ["f","o","o"];   // array
     : both they having a length property, an indexOf() method and a concat() method
     a.length;                // 3
     b.length;                // 3
     a.indexOf( "o" );        // 1
     b.indexOf( "o" );        // 1
     var c = a.concat( "bar" );              // "foobar"
     var d = b.concat( ["b","a","r"] );      // ["f","o","o","b","a","r"]
     a === c;                 // false
     b === d;                 // false
     a;                       // "foo"
     b;                       // ["f","o","o"]
     a[1] = "O";    =// NOTE: the string a[1] character position access form was not always widely valid JavaScript, Instead, the correct approach has been a.charAt(1)=
     b[1] = "O";
     a; // "foo"
     b; // ["f","O","o"]

     : JavaScript strings are immutable, while arrays are quite mutable
     : A further consequence of immutable strings is that none of the string methods that alter its contents can modify in-place, but rather must create and return new strings
     c = a.toUpperCase();
     a === c;        // false
     a;                      // "foo"
     c;                      // "FOO"
     b.push( "!" );
     b;                      // ["f","O","o","!"]
     : many of the array methods that could be helpful when dealing with strings are not actually available for them
     a.join;                 // undefined
     a.map;                  // undefined
     var c = Array.prototype.join.call( a, "-" );
     var d = Array.prototype.map.call( a, function(v){
             return v.toUpperCase() + ".";
     } ).join( "" );
     c;                              // "f-o-o"
     d;                              // "F.O.O."

     : arrays have a reverse() in-place mutator method, but strings do not
     a.reverse;      // undefined
     b.reverse();    // ["!","o","O","f"]
     b;              // ["!","o","O","f"]
     Array.prototype.reverse.call( a );
     // still returns a String object wrapper (see Chapter 3)
     // for "foo" :(
     : TIP
     : another workaround is to convert the string into an array, perform the desired operation, then convert it back to a string
     =// Warning: This approach doesn't work for strings with complex (unicode) characters in them (astral symbols, multibyte characters, etc.)=
     var c = a
             // split `a` into an array of characters
             .split( "" )
             // reverse the array of characters
             .reverse()
             // join the array of characters back to a string
             .join( "" );
     c; // "oof"

     : TIP
     : if you are more commonly doing tasks on your "strings" that treat them as basically arrays of characters,
     :   perhaps it's better to just actually store them as arrays rather than as strings
     : You can always call join("") on the array of characters whenever you actually need the string representation
**** Numbers
     JavaScript has just one numeric type: number. This type includes both "integer" values and fractional decimal numbers
     : NOTE
     in JS, an "integer" is just a value that has no fractional decimal value. That is, 42.0 is as much an "integer" as 42
**** Numeric Syntax
     : Number literals are expressed in JavaScript generally as base-10 decimal literals
     var a = 42;
     var b = 42.3;
     : The leading decimal value of 0 is optional
     var a = 0.42;
     var b = .42;
     : most numbers will be output as base-10 decimals
     var a = 42.300;
     var b = 42.0;
     a; // 42.3
     b; // 42
     : output in exponent form
     var a = 5E10;
     a;                                      // 50000000000
     a.toExponential();      // "5e+10"
     var b = a * a;
     b;                                      // 2.5e+21
     var c = 1 / a;
     c;                                      // 2e-11
     : use build-in Number.prototype
     : toFIxed()
     =// the toFixed(..) method allows you to specify how many fractional decimal places you'd like the value to be represented with=
     a.toFixed( 0 ); // "43"  =NOTE: output is a string=
     a.toFixed( 1 ); // "42.6"
     a.toFixed( 2 ); // "42.59"
     a.toFixed( 3 ); // "42.590"
     : toPrecision()
     =// specifies how many significant digits should be used to represent the value=
     a.toPrecision( 1 ); // "4e+1"  =NOTE: output is a string=
     a.toPrecision( 2 ); // "43"
     a.toPrecision( 3 ); // "42.6"
     a.toPrecision( 4 ); // "42.59"
     a.toPrecision( 5 ); // "42.590"
     a.toPrecision( 6 ); // "42.5900"
     : NOTE
     42.toFixed( 3 );        // SyntaxError
     (42).toFixed( 3 );      // "42.000"
     42..toFixed( 3 );       // "42.000"
     42 .toFixed(3); // "42.000"
     : exponent form
     var onethousand = 1E3;                                          // means 1 * 10^3
     var onemilliononehundredthousand = 1.1E6;       // means 1.1 * 10^6
     : hexadecimal
     0xf3; // hexadecimal for: 243
     0Xf3; // ditto
     : octal
     0363; // octal for: 243
     0o363;          // octal for: 243
     0O363;          // ditto
     : binary
     0b11110011;     // binary for: 243
     0B11110011; // ditto
     : the representations in binary floating-point
     =// the representations for 0.1 and 0.2 in binary floating-point are not exact, so when they are added, the result is not exactly 0.3=
     0.1 + 0.2 === 0.3; // false
     : Number.EPSILON
     =// As of ES6, Number.EPSILON is predefined with this tolerance value=
     =// Number.EPSILON = Math.pow(2,-52);=
     function numbersCloseEnoughToEqual(n1,n2) {
             return Math.abs( n1 - n2 ) < Number.EPSILON;
     }
     var a = 0.1 + 0.2;
     var b = 0.3;
     numbersCloseEnoughToEqual( a, b );                                      // true
     numbersCloseEnoughToEqual( 0.0000001, 0.0000002 );      // false
**** Safe Integer Ranges
     : Number.MAX_VALUE
     2^53 - 1
     9007199254740991
     : in ES6
     : Number.MAX_SAFE_INTEGER
     : Number.MIN_SAFE_INTEGER
     -9007199254740991
**** Testing for Integers
     : Number.isInteger(..)
     Number.isInteger( 42 );         // true
     Number.isInteger( 42.000 );     // true
     Number.isInteger( 42.3 );       // false
     if (!Number.isInteger) {        =// polyfill Number.isInteger(..) for pre-ES6=
             Number.isInteger = function(num) {
                     return typeof num == "number" && num % 1 == 0;
             };
     }
     : Number.isSafeInteger(..)
     Number.isSafeInteger( Number.MAX_SAFE_INTEGER );      // true
     Number.isSafeInteger( Math.pow( 2, 53 ) );            // false =[[32-bit safe range]]=
     Number.isSafeInteger( Math.pow( 2, 53 ) - 1 );        // true
     if (!Number.isSafeInteger) {                          =// polyfill Number.isSafeInteger(..) in pre-ES6 browsers=
             Number.isSafeInteger = function(num) {
                     return Number.isInteger( num ) &&
                             Math.abs( num ) <= Number.MAX_SAFE_INTEGER;
             };
     }
**** 32-bit (Signed) Integers
     : While integers can range up to roughly 9 quadrillion safely (53 bits),
     :   that are only defined for 32-bit numbers, so the "safe range" for numbers used in that way must be much smaller`
     : The range then is Math.pow(-2,31) (-2147483648, about -2.1 billion) up to Math.pow(2,31)-1 (2147483647, about +2.1 billion) <<32-bit safe range>>
**** Special Values
**** The Non-value Values
     : For the undefined type, there is one and only one value: undefined    (undefined hasn't had a value yet)
     : For the null type, there is one and only one value: null              (null had a value and doesn't anymore)
**** undefined
     : In non-strict mode, it's actually possible (though incredibly ill-advised!) to assign a value to the globally provided undefined identifier
     function foo() {
             undefined = 2; // really bad idea!
     }
     foo();

     function foo() {
             "use strict";
             undefined = 2; // TypeError!
     }
     foo();
     : however, you can create a local variable of the name undefined. But again, this is a terrible idea!
     function foo() {
             "use strict";
             var undefined = 2;
             console.log( undefined ); // 2
     }
     foo();
     : TIP
     Friends don't let friends override undefined. Ever
**** void Operator
     : void operator is another way to hold the undefined value
     var a = 42;
     console.log( void a, a );  =// There's no practical difference between void 0, void 1, and undefined=
     -> undefined 42
     : void operator can be useful if you need to ensure that an expression has no result value
     function doSomething() {
             // note: `APP.ready` is provided by our application
             if (!APP.ready) {
                     // try again later
                     return void setTimeout( doSomething, 100 );
                     =// which works the same as above but doesn't use the void operator=
                     =setTimeout( doSomething, 100 );=
                     =return;=
             }
             var result;
             // do some other stuff
             return result;
     }
     // were we able to do it right away?
     if (doSomething()) {
             // handle next tasks right away
     }
**** Special Numbers
     : The Not Number, Number
     var a = 2 / "foo";      // NaN
     typeof a === "number";  // true
     var b = "foo";
     window.isNaN( b ); // true -- bug
     : this is a bug has been in JS, as of ES6, you can use Number.isNaN instead
     if (!Number.isNaN) {
             Number.isNaN = function(n) {
                     return (
                             typeof n === "number" &&
                             window.isNaN( n )
                     );
             };
     }
     var a = 2 / "foo";
     var b = "foo";
     Number.isNaN( a ); // true
     Number.isNaN( b ); // false -- phew!
**** Infinities
     : this operation is well-defined and results in the value Infinity
     var a = 1 / 0;  // Infinity
     var b = -1 / 0; // -Infinity
     : it is possible to overflow even with an operation like addition or subtraction, in which case you'd get Infinity or -Infinity
     var a = Number.MAX_VALUE;       // 1.7976931348623157e+308
     a + a;                          // Infinity
     a + Math.pow( 2, 970 );         // Infinity
     a + Math.pow( 2, 969 );         // 1.7976931348623157e+308
     : Infinity / Infinity is results in NaN
**** Zeros
     : negative zero also results from certain mathematic operations
     var a = 0 / -3; // -0
     var b = 0 * -3; // -0
     : if a negative zero value is stringify, sometimes it will be as "0"
     var a = 0 / -3;
     a;                      // -0
     a.toString();           // "0"
     a + "";                 // "0"
     String( a );            // "0"
     // strangely, even JSON gets in on the deception
     JSON.stringify( a );            // "0"
     : Another possibility
     +"-0";                  // -0
     Number( "-0" );         // -0
     JSON.parse( "-0" );     // -0
     : the comparison operators are also strange
     var a = 0;
     var b = 0 / -3;
     a == b;         // true
     -0 == 0;        // true
     a === b;        // true
     -0 === 0;       // true
     0 > -0;         // false
     a > b;          // false
     : a clever way to distinguish 0 and -0
     function isNegZero(n) {
             n = Number( n );
             return (n === 0) && (1 / n === -Infinity);
     }
     isNegZero( -0 );                // true
     isNegZero( 0 / -3 );    // true
     isNegZero( 0 );                 // false
     : TIP
     : why do we need a negative zero
     : There are certain applications where developers use the magnitude of a value to represent one piece of information (like speed of movement per animation frame)
     :   and the sign of that number to represent another piece of information (like the direction of that movement)
**** Special Equality
     : test two values for special types
     var a = 2 / "foo";
     var b = -3 * 0;
     Object.is( a, NaN );    // true
     Object.is( b, -0 );     // true
     Object.is( b, 0 );      // false
     : the function's core
     if (!Object.is) {
             Object.is = function(v1, v2) {
                     // test for `-0`
                     if (v1 === 0 && v2 === 0) {
                             return 1 / v1 === 1 / v2;
                     }
                     // test for `NaN`
                     if (v1 !== v1) {
                             return v2 !== v2;
                     }
                     // everything else
                     return v1 === v2;
             };
     }
**** Value vs. Reference
     : value-copy
     =// Simple values (aka scalar primitives) are always assigned/passed by value-copy=
     var a = 2;
     var b = a; // `b` is always a copy of the value in `a`
     b++;
     a; // 2
     b; // 3
     : reference-copy
     =// Compound values -- objects (including arrays, and all boxed object wrappers) and functions -- always create a copy of the reference on assignment or passing=
     var c = [1,2,3];
     var d = c; // `d` is a reference to the shared `[1,2,3]` value
     d.push( 4 );
     c; // [1,2,3,4]
     d; // [1,2,3,4]
     =// Since references point to the values themselves and not to the variables, you cannot use one reference to change where another reference is pointed=
     var a = [1,2,3];
     var b = a;      =// b is not a pointer to a=
     a; // [1,2,3]
     b; // [1,2,3]
     // later
     b = [4,5,6];    =// a is still referencing [1,2,3]=
     a; // [1,2,3]
     b; // [4,5,6]
     : function
     =// separate references=
     function foo(x) {     =// argument pass: x -> a=
             x.push( 4 );  =// reference change: x  -> [1,2,3,4] <- a=
             x; // [1,2,3,4]
             // later
             x = [4,5,6];  =// assignment: x -> [4,5,6]  a-> [1,2,3,4]=
             x.push( 7 );
             x; // [4,5,6,7]
     }
     var a = [1,2,3];
     foo( a );
     a; // [1,2,3,4]  not  [4,5,6,7]
     =// shared reference=
     function foo(x) {     =// argument pass: x -> a=
             x.push( 4 );  =// reference change: x -> [1,2,3,4] <- a=
             x; // [1,2,3,4]
             // later
             x.length = 0; // empty existing array in-place
             x.push( 4, 5, 6, 7 );  =// reference change: x -> [4,5,6,7] <- a=
             x; // [4,5,6,7]
     }
     var a = [1,2,3];
     foo( a );
     a; // [4,5,6,7]  not  [1,2,3,4]
     =// NOTE: slice(..) with no parameters by default makes an entirely new (shallow) copy of the array=
        =foo( a.slice() ); // foo(..) cannot affect the contents of a=
        =a; // [1,2,3]=
     : wrapper reference
     function foo(wrapper) {
             wrapper.a = 42;
     }
     var obj = {
             a: 2
     };
     foo( obj );  =// access the shared object, and update it property=
     obj.a; // 42
     : mutable scalar primitive
     function foo(x) {
             x = x + 1;
             x; // 3
     }
     var a = 2;
     var b = new Number( a ); // or equivalently `Object(a)`
     foo( b ); =// If a Number object holds the scalar primitive value 2, that exact Number object can never be changed to hold another value=
     console.log( b ); // 2, not 3
*** Natives
    - object wrapper
      var a = new String( "abc" ); =// The result of the constructor form of value creation (new String("abc")) is an object wrapper around the primitive ("abc") value=
      typeof a; // "object" ... not "String"
**** Internal [class]
     - build-in native constructor
       Object.prototype.toString.call( [1,2,3] );                      // "[object Array]"
       Object.prototype.toString.call( /regex-literal/i );     // "[object RegExp]"
       Object.prototype.toString.call( null );                 // "[object Null]"
       Object.prototype.toString.call( undefined );    // "[object Undefined]"
       Object.prototype.toString.call( "abc" );        // "[object String]"
       Object.prototype.toString.call( 42 );           // "[object Number]"
       Object.prototype.toString.call( true );         // "[object Boolean]"
     : TODO
     those details in the ES6 & Beyond title of this series
**** Boxing Wrappers
     - automatically box the primitive value with object wrapper
       var a = "abc";  =// Primitive values don't have properties or methods=
       =// so to access .length or .toString() you need an object wrapper around the value=
       a.length; // 3
       a.toUpperCase(); // "ABC"
       : NOTE
       String("abc")   =// there's basically no reason to use the object form directly, it will slower you program=
       new Number(42)
       abc  =// It's better to just let the boxing happen implicitly where necessary=
       42
**** Object Wrapper Gotchas
     - manually box a primitive value may cause some problems
       =// using the boxed object wrapper directly (like b and c above) is usually discouraged, but there may be some rare occasions you'll run into where they may be useful=
       var a = "abc";
       var b = new String( a );
       var c = Object( a );
       typeof a; // "string"
       typeof b; // "object"
       typeof c; // "object"
       b instanceof String; // true
       c instanceof String; // true
       Object.prototype.toString.call( b ); // "[object String]"
       Object.prototype.toString.call( c ); // "[object String]"
**** Unboxing
     - object wrapper change automatically
       var a = new String( "abc" );
       var b = a + ""; // `b` has the unboxed primitive value "abc"
       typeof a; // "object"
       typeof b; // "string"
     - use the valueOf() method get the underlying primitive value
       var a = new String( "abc" );
       var b = new Number( 42 );
       var c = new Boolean( true );
       a.valueOf(); // "abc"
       b.valueOf(); // 42
       c.valueOf(); // true
**** Natives as Constructors
     constructor forms should generally be avoided, unless you really know you need them, mostly because they introduce exceptions and gotchas
**** Array
     - the notice of array
       var a = new Array( 1, 2, 3 ); =// Array(1,2,3) is the same outcome as new Array(1,2,3)=
       a; // [1, 2, 3]
       var b = [1, 2, 3];
       b; // [1, 2, 3]
       =// if only one number argument pass to the array constructor, it will as a length to presize the array=
       var a = new Array( 3 );
       a.length; // 3
       a; =// but more importantly, there is no such thing to presizing=
          =// chrome report [undefined, undefined,undefined]=
          =// firefox report [, , ,]=
**** Object(..), Function(..), and RegExp(..)
     - The Object(..)/Function(..)/RegExp(..) constructors
       var c = new Object();
       c.foo = "bar";
       c; // { foo: "bar" }
       var d = { foo: "bar" };
       d; // { foo: "bar" }
       var e = new Function( "a", "return a * 2;" );
       var f = function(a) { return a * 2; };
       function g(a) { return a * 2; }
       var h = new RegExp( "^a*b+", "g" );
       var i = /^a*b+/g;
       
**** Date(..) and Error(..)
     - The Date(..) and Error(..) native constructors are much more useful than the other natives, because there is no literal form for either
       if (!Date.now) {
               Date.now = function(){
                       return (new Date()).getTime();
               };
       }
       // call Date() without new, you'll get back a string representation of the date/time at that moment

       function foo(x) {
               if (!x) {
                       throw new Error( "x wasn't provided" );
               }
               // ..
       }
       // there are several other specific-error-type natives: EvalError(..), RangeError(..), ReferenceError(..), SyntaxError (..), TypeError(..), and URIError(..)
       // But it's very rare to manually use these specific error natives
       // they are automatically used if your program actually suffers from a real exception (such as referencing an undeclared variable and getting a ReferenceError error)
**** Symbol
     - custom property names on object
       =// There are several predefined symbols in ES6, like Symbol.create, Symbol.iterator, etc=
       obj[Symbol.iterator] = function(){ /*..*/ }; =// To use predefined symbols=

       =// To define your own custom symbols, use the Symbol(..) native=
       var mysym = Symbol( "my own symbol" );
       mysym;                          // Symbol(my own symbol)
       mysym.toString();       // "Symbol(my own symbol)"
       typeof mysym;           // "symbol"
       var a = { };
       a[mysym] = "foobar";
       Object.getOwnPropertySymbols( a );
       // [ Symbol(my own symbol) ]
       : TIP
       symbols are not actually private on object
       using them for private or special properties is likely their primary use-case
       most developers take the place of property names with _ underscore prefixes, show this is a private/special/internal property
**** Native Prototypes
     - build-in .prototype object
       - convention
         String.prototype.XYZ is shortened to String#XYZ
         - example
           String#indexOf(..)     find the position in the string of another substring
           String#charAt(..)      access the character at a position in the string
           String#substr(..)      String#substring(..), and String#slice(..): extract a portion of the string as a new string
           String#toUpperCase()   and String#toLowerCase(): create a new string that's converted to either uppercase or lowercase
           String#trim()          create a new string that's stripped of any trailing or leading whitespace
         : any string value can access these methods
         - example
           var a = " abc ";
           a.indexOf( "c" ); // 3
           a.toUpperCase(); // " ABC "
           a.trim(); // "abc"
       : Function.prototype being an empty function
       typeof Function.prototype;                      // "function"
       Function.prototype();                           // it's an empty function!
       : RegExp.prototype is a regular expression
       RegExp.prototype.toString();            // "/(?:)/" -- empty regex
       "abc".match( RegExp.prototype );        // [""]
       : Array.prototype is an array
       Array.isArray( Array.prototype );       // true
       Array.prototype.push( 1, 2, 3 );        // 3
       Array.prototype;                                        // [1,2,3]
**** Prototypes As Defaults
     - make .prototypes as a "default" variable type
       function isThisCool(vals,fn,rx) {
               vals = vals || Array.prototype;  =// if you make in-place changes to vals, you would actually be modifying Array.prototype itself.  [[notice of Array.prototypes]]=
               fn = fn || Function.prototype;   =// TODO: we don't need to use the vals = vals || .. default value syntax trick (see Chapter 4) anymore=
               rx = rx || RegExp.prototype;     =//       because default values can be set for parameters via native syntax in the function declaration (see Chapter 5)=
               return rx.test(
                       vals.map( fn ).join( "" )
               );
       }
       isThisCool();           // true
       isThisCool(
               ["a","b","c"],
               function(v){ return v.toUpperCase(); },
               /D/
       );                                      // false
       : NOTE
       be very careful not to use Array.prototype as a default value that will subsequently be modified  <<notice of Array.prototypes>>
       : TODO
       be cautious of relying on them and even more wary of modifying them in any way. See Appendix A "Native Prototypes" for more discussion
*** Coercion
    Our goal is to fully explore the pros and cons
**** Converting Values
     - implicit coercion and explicit coerction
       var a = 42;
       var b = a + "";         // implicit coercion
       var c = String( a );    // explicit coercion
       : TIP
       "explicit" vs. "implicit" based on the likely opinions of an average, reasonably informed, but not expert or JS specification devotee develope
     : NOTE
     There is no coercion that results in a complex value like object or function
**** Abstract Value Operations
     learn how values become either a string, number, or boolean
**** ToString
     : toString() can either be called explicitly, or it will automatically be called if a non-string is used in a string context
     // multiplying `1.07` by `1000`, seven times over
     var a = 1.07 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000;
     // seven times three digits => 21 digits
     a.toString(); // "1.07e21"
     var a = [1,2,3];
     a.toString(); // "1,2,3"
**** JSON Stringification
     : JSON.stringify() utility is the same as toString() to serialize a value to a JSON-compatible string value
     JSON.stringify( 42 );   // "42"
     JSON.stringify( "42" ); // ""42"" (a string with a quoted string value in it)
     JSON.stringify( null ); // "null"
     JSON.stringify( true ); // "true"
     : except it will automatically omit JSON-unsafe object
     JSON.stringify( undefined );                                    // undefined
     JSON.stringify( function(){} );                                 // undefined
     JSON.stringify( [1,undefined,function(){},4] ); // "[1,null,null,4]"
     JSON.stringify( { a:2, b:function(){} } );              // "{"a":2}"

     : define a toJSON() method for a JSON-safe value suitable for stringification
     var o = { };
     var a = {
             b: 42,
             c: o,
             d: function(){}
     };
     // create a circular reference inside `a`
     o.e = a;
     // would throw an error on the circular reference
     // JSON.stringify( a );
     // define a custom JSON value serialization
     a.toJSON = function() {
             // only include the `b` property for serialization
             return { b: this.b };
     };
     JSON.stringify( a ); // "{"b":42}"

     =// stringified the returned string=
     var b = {
             val: [1,2,3],
             // probably incorrect!
             toJSON: function(){
                     return "[" +
                             this.val.slice( 1 ).join() +
                     "]";
             }
     };
     JSON.stringify( b ); // ""[2,3]""

     =// stringified the array itself=
     var b = {
             val: [1,2,3],
             // probably incorrect!
             toJSON: function(){
                     return "[" +
                             this.val.slice( 1 ).join() +
                     "]";
             }
     };
     JSON.stringify( a ); // "[2,3]"

     =// An optional second argument can be passed to JSON.stringify(..) that is called replacer=
     var a = {
             b: 42,
             c: "42",
             d: [1,2,3]
     };
     JSON.stringify( a, ["b","c"] ); // "{"b":42,"c":"42"}"  =if /replacer/ is an array, the string of array should be included in serialization of the object and omit otherwise=
     JSON.stringify( a, function(k,v){
             if (k !== "c") return v;
     } );
     // "{"b":42,"d":[1,2,3]}"  =if /replacer/ is a funtion, it will call once for property in the object=

     =// A third optional argument can also be passed to JSON.stringify(..), called space=
     var a = {
             b: 42,
             c: "42",
             d: [1,2,3]
     };
     JSON.stringify( a, null, 3 );  =// three space indentation=
     // "{
     //    "b": 42,
     //    "c": "42",
     //    "d": [
     //       1,
     //       2,
     //       3
     //    ]
     // }"
     JSON.stringify( a, null, "-----" );  =// four '-' indentation=
     // "{
     // -----"b": 42,
     // -----"c": "42",
     // -----"d": [
     // ----------1,
     // ----------2,
     // ----------3
     // -----]
     // }"
**** ToNumber

** This & Object Prototypes
*** this or that?
*** Why this?
    : the this mechanism provides a more elegant way of implicitly "passing along" an object reference, leading to cleaner API design and easier re-use
    =// This allows the identify() and speak() functions to be re-used by passing multiple context (me and you) objects implicitly=
    function identify() {
            return this.name.toUpperCase();
    }
    function speak() {
            var greeting = "Hello, I'm " + identify.call( this );
            console.log( greeting );
    }
    =// the ugly version by passing multiple context objects=
    =// function identify(context) {=
            =// return context.name.toUpperCase();=
    =// }=
    =// function speak(context) {=
            =// var greeting = "Hello, I'm " + identify( context );=
            =// console.log( greeting );=
    =// }=
    var me = {
            name: "Kyle"
    };
    var you = {
            name: "Reader"
    };
    identify.call( me ); // KYLE
    identify.call( you ); // READER
    speak.call( me ); // Hello, I'm KYLE
    speak.call( you ); // Hello, I'm READER
*** Confusions
** Scope & Closures
*** What is Scope?
    we call the set of rules for storing variables in some location, and for finding those variables at a later time, which is: Scope
*** Compiler Theory
    In traditional compiled-language process, a chunk of source code, your program, will undergo typically three steps before it is executed, roughly called "compilation"
    1. Tokens
       the program: var a = 2;
       broken up into the following tokens: var, a, =, 2, and ;. Whitespace may or may not be persisted as a token
    2. Parsing
       var a = 2;
         might start with a top-level node called VariableDeclaration, with a child node called Identifier (whose value is a),
         and another child called AssignmentExpression which itself has a child called NumericLiteral (whose value is 2).
    3. Code-Generation
       the process of taking an AST((Abstract Syntax Tree) and turning it into executable code. (depending on platform)
*** Understanding Scope
*** The Cast
    for fully understand how javascript works, let's make a conversations
    1. Engine    responsible for start-to-finish compilation and execution of our JavaScript program.
    2. Compiler  one of Engine's friends; handles all the dirty work of parsing and code-generation
    3. Scope     another friend of Engine; collects and maintains a look-up list of all the declared identifiers (variables), and enforces a strict set of rules as to how these are
                 accessible to currently executing code.
*** Back & Forth
** Async & Performance
*** Asynchrony: Now & Later
    we're going to have to understand much more deeply what asynchrony is and how it operates in JS
**** A Program in Chunks                                                        :ATTACH:
     :PROPERTIES:
     :Attachments: asynchrony_ajax.js
     :ID:       67C1C145-DCFC-4561-8B91-45B0B56D92A8
     :END:
     your program is almost certainly comprised of several chunks, only one of which is going to execute now, and the rest of which will execute later

     later doesn't happen strictly and immediately after now

     Any time you wrap a portion of code into a function and specify that it should be executed in response to some event (timer, mouse click, Ajax response, etc.)
     you are creating a later chunk of your code, and thus introducing asynchrony to your program

     : NOTE
     it's possible to make synchronous Ajax requests, but it locks the browser UI and prevents any user interaction.
     so you should never, ever do it
**** Async Console                                                              :ATTACH:
     :PROPERTIES:
     :Attachments: async_console.js
     :ID:       57985140-C76B-4339-9038-A6EAECDCD36B
     :END:
     sometimes the js console environment work in a strange asynchronous scenario
**** Event Loop                                                                 :ATTACH:
     :PROPERTIES:
     :Attachments: event_loop.js
     :ID:       91005263-7E9F-420C-B389-7A419C9916E2
     :END:
     - serialize
       breaks its work into tasks and executes them in serial
       disallowing parallel access and changes to shared memory
     - JS engine itself has no asynchrony recently
       up until recently (ES6) <1>, JavaScript itself has actually never had any direct notion of asynchrony built into it
       The JS engine doesn't run in isolation. It runs inside a hosting environment, which is for most developers the typical web browser
       Over the last several years, JS has expanded beyond the browser into other environments, such as servers, via things like Node.js.
       In fact, JavaScript gets embedded into all kinds of devices these days, from robots to lightbulbs
     : NOTE
     We mentioned "up until recently" <1> in relation to ES6 changing the nature of where the event loop queue is managed.
     but ES6 now specifies how the event loop works, which means technically it's within the purview of the JS engine, rather than just the hosting environment

     the JS engine has a mechanism that *handles executing multiple chunks* of your program over time, at each moment invoking the JS engine, called the "event loop."
     the "event" has had no innate sense of time, but has instead been an *on-demand execution environment* for any arbitrary snippet of JS.
**** Parallel Threading                                                         :ATTACH:
     :PROPERTIES:
     :Attachments: parallel_threading.js
     :ID:       358C6A1E-0841-40C5-985C-DEA76C0F81EA
     :END:
     - parallel and async
       async is about the gap between now and later
       parallel is about things being able to occur simultaneously
     - tools for parallel
       - processes and threads
         they execute independently and may execute simultaneously: on separate processors,
                                                                    or even separate computers, but multiple threads can share the memory of a single process
     - parallel threading and event loop
       parallel threading      allowing parallel access and change to shared memory
       event loop              by contrast, is execute tasks in serial
       Parallelism and "serialism" can coexist in the form of cooperating event loops in separate threads
** ES6 & Beyond
*** ES? Now & Future
* READING php官网文档 php document
** what is php
   超文本预处理 Hypertext Preprocessor
   <?php
       ...
   ?>
** what php can do                                                             :[[http://php.net/manual/en/intro:whatcando.php][PHP: What can PHP do? : Manual]]:
   procedural programming
   object oriented programming (OOP)
   or a mixture of them both
   HTML image PDF Flash(libwf Ming)
   XHTML XML

   mysql PDD ODBC cURL socket

   LDAP IMAP SNMP NNTP POP3 HTTP COM
   Java

   Perl regular expression
   XML documents
   libxml2 SimpleXML XMLReader XMLWriter

   XDebug
** install
*** homebrew
**** version control
     $ brew install php56
     $ brew options php56
     $ export PATH="$(brew --prefix homebrew/php/php56)/bin:$PATH"
** useful example
   show all reserver variables
   - <?php phpinfo(); ?>

   show the value in one of reserver variables
   - <?php
     echo $_SERVER['HTTP_USER_AGENT'];
     ?>
     // $_SERVER                       contain all web server information
     // $_SERVER['HTTP_USER_AGENT']    the sort of visitor's browser

   control structures
   - <?php
     if (strpos($_SERVER['HTTP_USER_AGENT'], 'MSIE') !== FALSE) {
         echo 'You are using Internet Explorer.<br />';
     }
     ?>

   strpos()    search a string for another string
   - <?php
     if (strpos($_SERVER['HTTP_USER_AGENT'], 'MSIE') !== FALSE) {
     ?>
     <h3>strpos() 肯定没有返回假 (FALSE)</h3>
     <p>正在使用 Internet Explorer</p>
     <?php
     } else {
     ?>
     <h3>strpos() 肯定返回假 (FALSE)</h3>
     <center><b>没有使用 Internet Explorer</b></center>
     <?php
     }
     ?>
* READING python官网 python document
** install
*** pyenv
**** version control
     $ pyenv global <version>  # 全局设置python版本为指定版本
     $ pyenv local <version>   # 设置当前路径下python版本为指定版本
     $ pyenv shell <version>   # 设置当前shell窗口使用的python版本为指定版本

** python3
*** conventions
    >>>             input
    ...             output
    _               the last printed expression is assigned to the variable
    \               escape quotes
    print()         format output things
    r               raw string
    """..."""
    '''...'''       string span multiple lines
    String          index slicing immutable
    lists           index slicing concatenation mutable
    end             avoid the newline after output
*** invoke the interpreter
    python -c command [arg]
    python3.6
    # -*- coding: encoding -*-
*** type and first programming                                                 :[[https://docs.python.org/3.6/tutorial/introduction.html][3. An Informal Introduction to Python — Python 3.6.0 documentation]]:
**** number
     : act as a simple calculator
     - the operators +, -, * and / work just like most other languages
       >>> 2 + 2
       4
       >>> 50 - 5*6
       20
       >>> (50 - 5*6) / 4
       5.0
       >>> 8 / 5  # division always returns a floating point number
       1.6
     - division (/) always returns a float and get an integer result you can use *//*, the remainder you can use %
       >>> 17 / 3  # classic division returns a float
       5.666666666666667
       >>>
       >>> 17 // 3  # floor division discards the fractional part
       5
       >>> 17 % 3  # the % operator returns the remainder of the division
       2
       >>> 5 * 3 + 2  # result * divisor + remainder
       17
     - it is possible to use the ** operator to calculate power
       >>> 5 ** 2  # 5 squared
       25
       >>> 2 ** 7  # 2 to the power of 7
       128
     : in interactive mode, the last printed expression is assigned to the variable _
     - when you using python as a desk calculator, it is somewhat easier to continue calculations
       >>> tax = 12.5 / 100
       >>> price = 100.50
       >>> price * tax
       12.5625
       >>> price + _
       113.0625
       >>> round(_, 2)
       113.06
**** strings
     : they can be enclosed ('...') or double quotes ("...")  \ can be used to escape quotes
     - The string is enclosed in double quotes if the string contains a single quote and no double quotes, otherwise it is enclosed in single quotes.
       >>> '"Isn\'t," she said.'
       '"Isn\'t," she said.'
       >>> print('"Isn\'t," she said.')
       "Isn't," she said.
       >>> s = 'First line.\nSecond line.'  # \n means newline
       >>> s  # without print(), \n is included in the output
       'First line.\nSecond line.'
       >>> print(s)  # with print(), \n produces a new line
       First line.
       Second line.
     : use raw strings by adding an r before the first quote
     - If you don’t want characters prefaced by \ to be interpreted as special characters
       >>> print('C:\some\name')  # here \n means newline!
       C:\some
       ame
       >>> print(r'C:\some\name')  # note the r before the quote
       C:\some\name
     : String literals can span multiple lines
     - One way is using triple-quotes: """...""" or '''...'''
       print("""\
       Usage: thingy [OPTIONS]
       -h                        Display this usage message
       -H hostname               Hostname to connect to
       """)
     : string can be concatenated and repeated
     - concatenated with + and repeated with *
       >>> # 3 times 'un', followed by 'ium'
       >>> 3 * 'un' + 'ium'
       'unununium'
       >>> prefix = 'Py'
       >>> prefix + 'thon'
       'Python'
     : string can be indexed
     - a character is simply a string of size one
       >>> word = 'Python'
       >>> word[0]  # character in position 0
       'P'
       >>> word[5]  # character in position 5
       'n'
       >>> word[-1]  # last character
       'n'
       >>> word[-2]  # second-last character
       'o'
       >>> word[-6]
       'P'
     : slice is also supported
     - slicing allows you to obtain substring
       >>> word[0:2]  # characters from position 0 (included) to 2 (excluded)
       'Py'
       >>> word[2:5]  # characters from position 2 (included) to 5 (excluded)
       'tho'
     - the start is always included, and the end always excluded
       >>> word[:2] + word[2:]
       'Python'
       >>> word[:4] + word[4:]
       'Python'
       >>> word[-2:]  # characters from the second-last (included) to the end
       'on'`
     - one way to remenber how slices work
       +-----+---+---+---+---+---+
       | P | y | t | h | o | n |
       +---+-----+---+---+---+---+
       0   1   2   3   4   5   6
      -6  -5  -4  -3  -2  -1
     : string cannot be changed
     - if you need a different string, you should create a new one
       >>> 'J' + word[1:]
       'Jython'
       >>> word[:2] + 'py'
       'Pypy'
**** lists
     : group other data type's value
     - Lists might contain items of different types, but usually the items all have the same type
       >>> squares = [1, 4, 9, 16, 25]
       >>> squares
       [1, 4, 9, 16, 25]
     : indexed and sliced
     - like string lists can be indexed an d sliced
       >>> squares[0]  # indexing returns the item
       1
       >>> squares[-1]
       25
       >>> squares[-3:]  # slicing returns a new list
       [9, 16, 25]
       >>> squares[:]
       [1, 4, 9, 16, 25]
     : muttable
     - unlike string, which are immutable, lists are a mutable type
       >>> squares + [36, 49, 64, 81, 100]
       [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
       >>> cubes = [1, 8, 27, 65, 125]  # something's wrong here
       >>> 4 ** 3  # the cube of 4 is 64, not 65!
       64
       >>> cubes[3] = 64  # replace the wrong value
       >>> cubes
       [1, 8, 27, 64, 125]

       >>> cubes.append(216)  # add the cube of 6
       >>> cubes.append(7 ** 3)  # and the cube of 7
       >>> cubes
       [1, 8, 27, 64, 125, 216, 343]

       >>> letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
       >>> letters
       ['a', 'b', 'c', 'd', 'e', 'f', 'g']
       >>> # replace some values
       >>> letters[2:5] = ['C', 'D', 'E']
       >>> letters
       ['a', 'b', 'C', 'D', 'E', 'f', 'g']
       >>> # now remove them
       >>> letters[2:5] = []
       >>> letters
       ['a', 'b', 'f', 'g']
       >>> # clear the list by replacing all the elements with an empty list
       >>> letters[:] = []
       >>> letters
       []
     - the build-in function len()
       >>> letters = ['a', 'b', 'c', 'd']
       >>> len(letters)
       4
     - nest list
       >>> a = ['a', 'b', 'c']
       >>> n = [1, 2, 3]
       >>> x = [a, n]
       >>> x
       [['a', 'b', 'c'], [1, 2, 3]]
       >>> x[0]
       ['a', 'b', 'c']
       >>> x[0][1]
       'b'
**** first programming
     >>> # Fibonacci series:
     ... # the sum of two elements defines the next
     : multiple assignment
     ... a, b = 0, 1
     : the body of loop within a basic block must be indented by the same amount
     >>> while b < 10:
     : the keyword 'end' can be used to avoid the newline after the output
     ...     # print(b, end=',')   will ouput  1,1,2,3,5,8
     ...     print(b)
     ...     a, b = b, a+b
     ...
     1
     1
     2
     3
     5
     8
*** control flow                                                               :[[https://docs.python.org/3.6/tutorial/controlflow.html][4. More Control Flow Tools — Python 3.6.0 documentation]]:
**** if
     : well-known statement type is the if
     - example
       >>> x = int(input("Please enter an integer: "))
       Please enter an integer: 42
       >>> if x < 0:
       ...     x = 0
       ...     print('Negative changed to zero')
       ... elif x == 0:         # 'elif' is short for 'else if'
       ...     print('Zero')
       ... elif x == 1:
       ...     print('Single')
       ... else:
       ...     print('More')
       ...
       More
**** for
     : python's for statement iterates over the items of any sequence (a list or a string)
     - for loop strings
       >>> # Measure some strings:
       ... words = ['cat', 'window', 'defenestrate']
       >>> for w in words:
       ...     print(w, len(w))
       ...
       cat 3
       window 6
       defenestrate 12
     : modify the sequence inside the loop
     - it is recommended you use slice notation to first make a copy
       >>> for w in words[:]:  # Loop over a slice copy of the entire list.
       ...     if len(w) > 6:
       ...         words.insert(0, w)
       ...
       >>> words
       ['defenestrate', 'cat', 'window', 'defenestrate']
**** range
     : iterate over a sequence of numbers
     - generate artithmetic progressions
       >>> for i in range(5):
       ...     print(i)
       ...
       0
       1
       2
       3
       4
     : different step
     - it is possible to let the range start at another number, or to specify a different increment
       range(5, 10)
       5 through 9

       range(0, 10, 3)
       0, 3, 6, 9

       range(-10, -100, -30)
       -10, -40, -70
     : iterate over the indices of a sequence
     - use combine range() and len()
       >>> a = ['Mary', 'had', 'a', 'little', 'lamb']
       >>> for i in range(len(a)):
       ...     print(i, a[i])
       ...
       0 Mary
       1 had
       2 a
       3 little
       4 lamb
**** list
     : it creates lists from iterables
     >>> list(range(5))
     [0, 1, 2, 3, 4]
**** break and else clauses
     : loop statement may have an else clause
     : it is executed when the loop terminates or when the condition becomes false
     : but not when the loop is terminated by a break statement
     - searches for prime numbers
       >>> for n in range(2, 10):
       ...     for x in range(2, n):
       ...         if n % x == 0:
       ...             print(n, 'equals', x, '*', n//x)
       ...             break
       ...     else:
       ...         # loop fell through without finding a factor
       ...         print(n, 'is a prime number')
       ...
       2 is a prime number
       3 is a prime number
       4 equals 2 * 2
       5 is a prime number
       6 equals 2 * 3
       7 is a prime number
       8 equals 2 * 4
       9 equals 3 * 3
**** continue
     : continues with the next iteration of the loop
     - example
       >>> for num in range(2, 10):
       ...     if num % 2 == 0:
       ...         print("Found an even number", num)
       ...         continue
       ...     print("Found a number", num)
       Found an even number 2
       Found a number 3
       Found an even number 4
       Found a number 5
       Found an even number 6
       Found a number 7
       Found an even number 8
       Found a number 9
**** pass
     : the pass statement does nothing
     : it can be used when a statement is required syntactically but the program requires no action
     - example
       >>> while True:
       ...     pass  # Busy-wait for keyboard interrupt (Ctrl+C)
       ...

       ... # This is commonly used for creating minimal classes:
       >>> class MyEmptyClass:
       ...     pass
       ...

       ... # another place pass can be used is as a place-holder for a function or conditional body
       ... >>> def initlog(*args):
       ...     pass   # Remember to implement this!
       ...
**** def
     : the keyword def introduces a funtion definition
     - write Fibonacci series up to n
       >>> def fib(n):
       ...     """Print a Fibonacci series up to n."""
       ...     a, b = 0, 1
       ...     while a < n:
       ...         print(a, end=' ')
       ...         a, b = b, a+b
       ...     print()
       ...
       >>> # Now call the function we just defined:
       ... fib(2000)
       0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597
     : rename function
     - assigned function to another name
       >>> fib
       <function fib at 10042ed0>
       >>> f = fib
       >>> f(100)
       0 1 1 2 3 5 8 13 21 34 55 89
     : the return value of funtion
     - a function without a return statement do return a value
       >>> fib(0)
       >>> print(fib(0))
       None
     - a funtion with a return value
       >>> def fib2(n):  # return Fibonacci series up to n
       ...     """Return a list containing the Fibonacci series up to n."""
       ...     result = []
       ...     a, b = 0, 1
       ...     while a < n:
       ...         result.append(a)    # see below
       ...         a, b = b, a+b
       ...     return result
       ...
       >>> f100 = fib2(100)    # call it
       >>> f100                # write the result
       [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
**** default argument values
     : The most useful form is to specify a default value for one or more arguments
     - This creates a function that can be called with fewer arguments than it is defined to allow
       def ask_ok(prompt, retries=4, reminder='Please try again!'):
         while True:
           ok = input(prompt)
           if ok in ('y', 'ye', 'yes'):
           return True
           if ok in ('n', 'no', 'nop', 'nope'):
           return False
           retries = retries - 1
           if retries < 0:
           raise ValueError('invalid user response')
           print(reminder)

       # This function can be called in several ways:
       # giving only the mandatory argument: ask_ok('Do you really want to quit?')
       # giving one of the optional arguments: ask_ok('OK to overwrite the file?', 2)
       # or even giving all arguments: ask_ok('OK to overwrite the file?', 2, 'Come on, only yes or no!')
     - *important warming* the default value is evaluated only once
       i = 5
       def f(arg=i):
       print(arg)
       i = 6
       f()
       # will print 5.
     - the following function accumulates the arguments passed to it on subsequent calls
       def f(a, L=[]):
           L.append(a)
           return L

       print(f(1))
       print(f(2))
       print(f(3))

       This will pri
       [1]
       [1, 2]
       [1, 2, 3]
**** keyword arguments
     : function can also be called using the form of key=value
     - example
       def parrot(voltage, state='a stiff', action='voom', type='Norwegian Blue'):
           print("-- This parrot wouldn't", action, end=' ')
           print("if you put", voltage, "volts through it.")
           print("-- Lovely plumage, the", type)
           print("-- It's", state, "!")

       # This function can be called in any of the following ways:
       # parrot(1000)                                          # 1 positional argument
       # parrot(voltage=1000)                                  # 1 keyword argument
       # parrot(voltage=1000000, action='VOOOOOM')             # 2 keyword arguments
       # parrot(action='VOOOOOM', voltage=1000000)             # 2 keyword arguments
       # parrot('a million', 'bereft of life', 'jump')         # 3 positional arguments
       # parrot('a thousand', state='pushing up the daisies')  # 1 positional, 1 keyword

       # but all the following calls would be invalid:
       # parrot()                     # required argument missing
       # parrot(voltage=5.0, 'dead')  # non-keyword argument after a keyword argument
       # parrot(110, voltage=220)     # duplicate value for the same argument
       # parrot(actor='John Cleese')  # unknown keyword argument
     : *name which receives a 'key' formal parameter without value
     : **name which receives a 'key=value' formal parameter
     - example
       def cheeseshop(kind, *arguments, **keywords):
           print("-- Do you have any", kind, "?")
           print("-- I'm sorry, we're all out of", kind)
           for arg in arguments:
               print(arg)
           print("-" * 40)
           keys = sorted(keywords.keys())
           for kw in keys:
               print(kw, ":", keywords[kw])

       # It could be called like this:
       cheeseshop("Limburger", "It's very runny, sir.",
                  "It's really very, VERY runny, sir.",
                  shopkeeper="Michael Palin",
                  client="John Cleese",
                  sketch="Cheese Shop Sketch")

       # and of course it would print:
       -- Do you have any Limburger ?
       -- I'm sorry, we're all out of Limburger
       It's very runny, sir.
       It's really very, VERY runny, sir.
       ----------------------------------------
       client : John Cleese
       shopkeeper : Michael Palin
       sketch : Cheese Shop Sketch
**** arbitrary argument lists
     : *args paramete scoop up all remaining input arguments that passed to the function
     - example
       >>> def concat(*args, sep="/"):
       ...     return sep.join(args)
       ...
       >>> concat("earth", "mars", "venus")
       'earth/mars/venus'
       >>> concat("earth", "mars", "venus", sep=".")
       'earth.mars.venus'
**** unpacking argument lists
     : when the arguments are already in a list or tuple
     : write the function call with the *-operator to unpack the arguments
     - example
       >>> list(range(3, 6))            # normal call with separate arguments
       [3, 4, 5]
       >>> args = [3, 6]
       >>> list(range(*args))            # call with arguments unpacked from a list
       [3, 4, 5]
**** lambda expression
     : Lambda functions can be used wherever function objects are required, Like nested function definitions
     - example
       >>> def make_incrementor(n):
       ...     return lambda x: x + n
       ...
       >>> f = make_incrementor(42)
       >>> f(0)
       42
       >>> f(1)
       43

       >>> pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]
       >>> pairs.sort(key=lambda pair: pair[1])
       >>> pairs
       [(4, 'four'), (1, 'one'), (3, 'three'), (2, 'two')]
**** documentation strings
     : Here are some conventions about the content and formatting of documentation strings
     : 1. The first line should always be a concise summary of the object’s purpose
     : 2. The following lines should be one or more paragraphs describing the object’s calling conventions, its side effects, etc
     : NOTE
     : The Python parser does not strip indentation from multi-line string literals
     - example
       >>> def my_function():
       ...     """Do nothing, but document it.
       ...
       ...     No, really, it doesn't do anything.
       ...     """
       ...     pass
       ...
       >>> print(my_function.__doc__)

       Do nothing, but document it.

          No, really, it doesn't do anything.
**** function annotations
     : Parameter annotations are defined by a colon after the parameter name, followed by an expression evaluating to the value of the annotatio
     : Return annotations are defined by a literal ->, followed by an expression, between the parameter list and the colon denoting the end of the def statement
     - The following example has a positional argument, a keyword argument, and the return value annotated:
       >>> def f(ham: str, eggs: str = 'eggs') -> str:
       ...     print("Annotations:", f.__annotations__)
       ...     print("Arguments:", ham, eggs)
       ...     return ham + ' and ' + eggs
       ...
       >>> f('spam')
       Annotations: {'ham': <class 'str'>, 'return': <class 'str'>, 'eggs': <class 'str'>}
       Arguments: spam eggs
       'spam and eggs'

**** intermezzo: coding style
     : For Python, *PEP 8* has emerged as the style guide that most projects adhere to
     - here are the most important points extracted for you
       - Use 4-space indentation, and no tabs
         Tabs introduce confusion, and are best left out
       - Wrap lines so that they don’t exceed 79 characters
         This helps users makes it possible to have several code files side-by-side on larger displays
       - Use blank lines to separate functions and classes, and larger blocks of code inside functions
       - When possible, put comments on a line of their own
       - Use docstrings
       - Use spaces around operators and after commas
         but not directly inside bracketing constructs: a = f(1, 2) + g(3, 4)
       - Name your classes and functions consistently
         the convention is to use CamelCase for classes and lower_case_with_underscores for functions and methods
         Always use self as the name for the first method argument
       - Don’t use fancy encodings if your code is meant to be used in international environments
         Python’s default, UTF-8, or even plain ASCII work best in any case
       - don’t use non-ASCII characters in identifiers
* READED english grammer in use
  CLOSED: [2017-02-18 六 16:02]
** contents 3
** tenses
*** 1) present continuous(I am doing) 10
*** 2) simple present(I do) 12
*** 3) present continuous(I an doing) or simple present(I do) 14
*** 4) present tenses(I am doing / I do) with a future meaning 16
*** 5) going to (I am going to do) 18
*** 6) will(1) 20
*** 7) will(2) 22
*** 8) will or going to 24
*** 9) when and if sentences(when I do... / if I do ...) 26
*** 10) will be doing and will have done 28
*** 11) simple past(I did) 30
*** 12) past continuous(I was doing) 32
*** 13) present perfect(I have done)(1) 34
*** 14) present perfect(I have done)(2) 36
*** 15) present perfect(I have done)(3) 38
*** 16) present perfectcontinuous(I have been doing) 40
*** 17) present perfect continuous(I have been doing) or present perfect simple(I have done)? 42
*** 18) present perfect(I have done / I have been doing) with how long, for, since 44
*** 19) present perfect with how long; simple past with when; since and for 46
*** 20) present perfect(I have done) or simple past(I did)? 48
*** 21) past perfect(I had done) 50
*** 22) past perfect continuous(I had benn doing) have and have got 52
*** 23) have and have got 54
*** 24) used to(I used to do) 56
** modal verbs
*** 25) can, could, and be able to 58
*** 26) could(do) and could have(done) 60
*** 27) must(have) and can't(have) 62
*** 28) may(have) and might(have) 64
*** 29) may and might(future) 66
*** 30) can, could, may, and would: requests, permission, offers, and invitations 68
*** 31) have to and must 70
*** 32) should 72
*** 33) subjunctive (I suggest you do) 74
** conditionals
*** 34) if sentences (present / future) 76
*** 35) if and wish sentences (present) 78
*** 36) if and wish sentences (past) 80
*** 37) would 82
*** 38) in case 84
*** 39) unless, as long as, and provided / providing(that) 86
** passive
*** 40) passive(1)(be done / have been done) 88
*** 41) passive(1)(present and past tenses) 90
*** 42) passive(3) 92
*** 43) it is said that ... / he is said to ..., etc., and supposed to 94
*** 44) have something done 96
** reported speech
*** 45) reported speech(1) 98
*** 46) reported speech(2) 100
** questions
*** 47) questions(1) 102
*** 48) qurestion(2) (do you know where...? / he asked me where...) 104
*** 49) auxiliary verbs in short answers/questions, etc.: so/neither am I, etc. 106
*** 50) tag questions(are you? doesn't he? ,etc.) 108
** -ing and the infinitive
*** 51) verb + ing 110
*** 52) verb + infinitive 112
*** 53) verb + object + infinitive 114
*** 54) infinitive or -ing?(1) -like, would like, etc. 116
*** 55) infinitive or -ing?(2) -begin, start, continue, remember, try 118
*** 56) preposition + -ing 120
*** 57) verb + preposition + -ing 122
*** 58) expressions + -ing 124
*** 59) be / get used to something(I'm used to...) 126
*** 60) infinitive of purpose-"I went out to mail a letter." so that... 128
*** 61) prefer and would rather 130
*** 62) had better do something  it's time someone did something 132
*** 63) see someone do and see someone doing 134
*** 64) -ing clauses-"feeling tired, I went to bed early." 136
** articles
*** 65) uncountable nouns(gold, music, advice, etc.) 138
*** 66) countable nouns with a/an and some 140
*** 67) a/an and the 142
*** 68) the(1) 144
*** 69) the(2) 146
*** 70) plural and uncountable nouns with and without the(flowers/the flowers) 148
*** 71) school/the school, prison/the prison, etc. 150
*** 72) geographical names with and without the 152
*** 73) names of strees, buildings, etc. with and without the 154
*** 74) singular or plural 156
*** 75) ...'s(apostrophe s) and ...of... 158
*** 76) reflexive pronouns(myself / yourself, etc.), by myself 160
*** 77) "a friend of mine," "my own house" 162
*** 78) all/all of, no/none of, most/most of, etc. 164
*** 79) both/both of, neither/neither of, either/ either of 166
*** 80) some and any  some/any + -one/-body/-thing/-where 168
*** 81) no/none/any  no/any + one/-bodu/-thing/-where 170
*** 82) much, many, little, few, a lot, plenty 172
*** 83) all, every, and whole 174
** relative clauses
*** 84) relative clauses(1)-clauses with who/that/which 176
*** 85) relative clauses(2)-clauses with or without who/that 178
*** 86) relative clauses(3)-whose, whom, why and where 180
*** 87) relative clauses(4)-"extra information" clauses(1) 182
*** 88) relative clauses(5)-"extra information" clauses(2) 184
*** 89) -ing and -ed clauses("the woman talking to Tom," "the man injured in the accident") 186
** adjectives and adverbs
*** 90) adjectives ending in -ing and -ed (boring/bored, etc.) 188
*** 91) adjectives: word order("a nice new house") after verbs("do you feel tired?") 190
*** 92) adjectives and adverbs(1) (quick/quickly) 192
*** 93) adjectives and adverbs(2) (good/well, fast/hard/late, hardly) 194
*** 94) so and such 196
*** 95) enough and too 198
*** 96) the infinitive after adjectives 200
*** 97) comparison(1)-cheaper, more expensive, etc. 202
*** 98) comparison(2) 204
*** 99) comparison(3)-as...as/than 206
*** 100) superlatives-the longest, the most enjoyble, etc. 208
** word order
*** 101) word order(1)-verb + objet;  place and time 210
*** 102) word order(2)-adverbs with the verb 212
*** 103) still and yet anymore/any longer/no longer 214
*** 104) although/though/even though/in spite of/despite 216
*** 105) even 218
*** 106) as(time)-"I watched her as she worked." as(reason)-"as I was feeling tired, I went to bed." 220
*** 107) like and as 222
*** 108) as if 224
** prepositions
*** 109) at/on/in(time) 226
*** 110) for, during, and while 228
*** 111) by and until  by the time ... 230
*** 112) in/at/on(position)(1) 232
*** 113) in/at/on(position)(2) 236
*** 114) to, been to, into    by car/in my car 238
*** 115) noun + preposition("reason for," "cause of," etc.) 240
*** 116) preposition + noun("by mistake," "on television," etc.) 242
*** 117) adjective + preposition(1) 244
*** 118) adjective + preposition(2) 246
*** 119) verb + preposition(1) 248
*** 120) verb + preposition(2) 250
*** 121) verb + preposition(3) 252
*** 122) verb + object + preposition(1) 254
*** 123) verb + object + preposition(2) 256
*** 124) phrasal verbs(get up, break down, fill in, etc.) 258
** appendix
*** 1) list of present and past tenses 261
*** 2) regular and irregular verbs 262
*** 3) spelling 264
*** 4) short forms(I'm/didn't, etc.) 266
** Index) the number in index refer to units, not page 267
* READING word power made essy
** *[basic]* how to use this book for maximum benefit 16
*** this is not a reading book
    Instead, work with it. Write in it, talk aloud to it, talk back to it
*** pronunciation system
**** syllables
***** several syllables in which vowel sound is said very quickly
      - The symbol "ə" called a schwa, represents the quick, short vowel sound
        -a[ə]
        -er[ər]
        a-[ə]
        -ent[ənt]
**** accent
**** S (or s) is always hissed in phonetic respellings
     -ce[s] -s[s]
**** The symbol i or l is pronounced eye
     -y[i] -i[i]
**** All consonants have their normal sounds
     - except for G(or g)
       -g-[G]
**** The vowel sounds
     -a- -e- -i- -o- -u-
*** why etymology
*** but what are nouns, verbs, and adjectives
*** how to work for best results
** *[test]* getting off to a good start
*** test your present vocabulary 33
*** a test of verbal speed 37
*** a test of verbal responsiveness 44
** *[experience]* how to start building your vocabulary 48
   : powerful urge to learn
   : words are the verbal symbols of ideas
   : the more ideas you are familiar with, the more words you know
   : do one or two sessions at a time
   : Find a schedule that is comfortable for you, and then stick to it
   : Avoid interrupting your work until you have completed a full session
** *[sessions 1-3]* how to talk about personality types 59 64 71
** *[sessions 4-6]* how to talk about doctors 86 92 98
** *[sessions 7-10]* how to talk about various practitioners 114
* READED 如何高效使用搜索引擎
** google 资料查找
*** site  某个特定网站下的所有信息
    例: site:http://www.nanzao.com/sc 棱X计划
*** filetype  用于搜索特定格式的文件
    例: filetype:ppt 商务模板
*** 关键字匹配
    "" 双引号   完全匹配
    -  减号     搜索结果不包含减号后面词的页面
    *  星号     通配符
    
** TinEye 以图搜索
** P2Psearch 电影下载                                                           :http://www.p2psearch.net:
** PEXLES 高清图片                                                              :https://www.pexels.com:
** GIPHY gif动态图                                                              :http://giphy.com:
** 天眼查 查公司相关信息                                                          :http://www.tianyancha.com:
** Innojoy 专利查询                                                             :http://www.innojoy.com/search/index.html:
* READING perl语言入门 learning perl
** 介绍 introduction
*** 编译 compile
    $ perl my_program
*** 执行路径 bin path
    #!/usr/bin/env perl
    #!/usr/bin/perl || #!/use/local/bin/perl
*** 走马观花 a whirlwind tour of perl
    #!/usr/bin/perl                  =# perl bin path, you should change it for your system=
    =# an array variable called @lines get message about the function atan2=
    @lines = `perldoc -u -f atan2`;  =# runs a external command, named within backquotes (``)=
                                     =# the perldoc command is to read and display the docmentation for perl=
    foreach (@lines) {
      s/\w<([^>]+)>/\U$1/g;
      print;
    }
** 标量数据 scalar data
*** 标量 scalar
    - 对于大部分标量来说 要么是数字 要么是有字符组成的序列
      a scalar is the simplest kind of data that perl manipulates
      most scalars atr either a number or astring of characters
    - 不区分变量类型
      not like C has char, int, and so on. perl doesn't make distinctions among single things
*** 数字 numbers
    : NOTE
    - 内部不存在整数值 总是按双精度浮点数进行运算
      Perl relies on the underlying C libraries for its numbers and uses a double-precision floating-point value to store the numbers.
      it does mean Perl has some limitations in precision and magnitude of the numbers that are related to how you compiled and installed the perl interpreter instead of a limitation of the language itself.
    - 没有专门的整型运算
      you can specify both integers and floating-point numbers.
      but internally, perl computers with double-precision floating-point values
**** 整数直接量 integer literals
     - 直接量 literals
       a literal is how you represent a value in your source code.(like int datatype)
     - 插入下划线 将若干位数分开
       61298040283
       61_298_040_283
**** 非十进制整数直接量 nondecimal interger literals
     - 八进制 octal
       start with a leading 0 and use the digits from 0 to 7
       0377 # same as 255 decimal
     - 十六进制 hexadecimal
       start with a leading 0x and use the digits 0 to 9 and the letters A through F (or a through f) to represent the values from 0 to 15:
       0xff # FF hex, also 255 decimal
     - 二进制 binary
       start with a leading 0b and use only the digits 0 and 1.
       0b11111111 # also 255 decimal
     - 下划线分隔符
       When a nondecimal literal is more than about four characters long, it may be hard to read, so underscores are handy
       0x1377_0B77
       0x50_65_72_7C
     : NOTE
     - 前置0只对直接量有效
       The “leading zero” indicator works only for literals
       not for automatic string-to-number conversions
**** 浮点数直接量 floating-point literals
     - hexadecimal floating-point literals
       Instead of an e to mark the exponent, you use a p for the power of 2 exponent
       0x1f.0p3
**** 数字操作符 numeric operators
     - 乘幂操作符号 exponentiation
       So, 2**3, is two to the third power, or eight
     : Note
     - 模操作符 modulus operator (%)
       Both values are first reduced to their integer values, so 10.5 % 3.2 is computed as 10 % 3.
       For -10 % 3, is the remainder 2 because it’s two places above -12 or -1 because it’s one place from -9? It’s best to avoid finding out accidentally.
*** 字符串 strings
    - 创建 扫描 操控 二进制数据
      For example, you could update a graphical image or compiled program by read‐ ing it into a Perl string, making the change, and writing the result back out.
    - 需要手动设置unicode编码文本文件读入
      If you want to use Unicode literally in your program, you need to add the utf8 pragma.
      use utf8;
    : NOTE
    - 无内置限制 no build-in limits
      The longest string fills all of your available memory
**** 单引号内的字符串直接量 signle-quoted string literals
     - 转义
       If you want a literal single quote or backslash inside your string, you need to escape it with a backslash:
       'Don\'t let an apostrophe end this string prematurely!'
       'the last character is a backslash: \\'
       '\'\\'    # single quote followed by backslash
     - 换行符
       You can spread your string out over two (or more) lines.
       'hello
       there'    # hello, newline, there (11 characters total)
     : NOTE
     - 无法转义控制字符
       Note that Perl does not interpret the \n within a single-quoted string as a newline
       'hello\nthere'    # hellonthere
**** 双引号内的字符串直接量 double-quoted string literals
     - 控制字符转义
       "hello world\n" # hello world, and a newline
       "coke\tsprite"  # coke, a tab, and sprite
       : Table doubel-quoted string backslash escapes (En 47)
     - 进制表示法
       "\x{2668}"      # Unicode HOT SPRINGS character code point
       "\N{SNOWMAN}"   # Unicode Snowman by name
**** 字符串操作符 string operators
     - 字符串连接
       You can concatenate, or join, string values with the . operator
       "hello" . "world"       # same as "helloworld"
       "hello" . ' ' . "world" # same as 'hello world'
       'hello world' . "\n"    # same as "hello world\n"
     - 重复操作符
       This operator takes its left operand (a string) and makes as many concatenated copies of that string as indicated by its right operand (a number)
       "fred" x 3       # is "fredfredfred"
       "barney" x (4+1) # is "barney" x 5, or "barneybarneybarneybarneybarney"
       5 x 4.8          # is really "5" x 4, which is "5555"
       : NOTE: The copy count (the right operand) is first truncated to an integer value (4.8 becomes 4) before being used.
*** 数字与字符串之间的自动转换 automatic conversion between numbers and strings
    - 操作符类型转换
      Perl automatically converts between numbers and strings as needed.
      It all depends upon the operator that you apply to the scalar value.
      If an operator expects a number (like + does), Perl will see the value as a number.
      If an operator expects a string (like . does), Perl will see the value as a string.
    - 字符串十进制浮点数进行运算
      Perl automatically converts the string to its equivalent numeric value, as if you had entered it as a decimal floating-point value
      So "12" * "3" gives the value 36.
      : Trailing nonnumber stuff and leading whitespace are discarded
      so "12fred34" * " 3" will also give 36 without any complaints
      : something that isn’t a number at all converts to zero.
      so "fjdi12" * "fjdks" will give 0
    - 数字运算字符串连接
      "Z" . 5 * 7 # same as "Z" . 35, or "Z35"
    : NOTE
    - 前置0按十进制数字处理
      0377    # that's octal for 255 decimal
      '0377'  # that's 377 decimal

*** perl的内置警告信息 perl's build-in warnings
    - 发现程序不对劲时 让perl发出警告
      - turn on warnings with a pragma
        : only With Perl 5.6 and later
        : for the file
        #!/usr/bin/perl
        use warnings;
      - use the -w option on the command line
        : for the file
        $ perl -w my_program
      - specify the command-line switches on the shebang line
        : for the entire program
        #!/usr/bin/perl -w
      - to load the pragma only when needed instead of editing the source code each time to enable and disable diagnostics
        $ perl -Mdiagnostics ./my_program
*** perl's build-in warnings
**** interpreting nondecimal numerals
     hex('DEADBEEF') # 3_735_928_559 decimal
     hex('OxDEADBEEF') # 3_735_928_559 decimal
     oct('0377') # 255 decimal
     oct('377') # 255 decimal
     oct('0xDEADBEEF') # 3_735_928_559 decimal, saw leading 0x
     oct('0b1101') # 13 decimal, saw leading 0b
     oct("0b$bits") # convert $bits from binary
     hex( 10 );   # decimal 10, converted to "10", then decimal 16
     hex( 0x10 ); # hex 10,     converted to "16", then decimal 22
*** 标量变量 scalar variables
    - 标量定义
      : not like a variable is a name for a container that holds one or more values
      a scalar variable holds exactly *one value*
      : Uppercase and lowercase letters are distinct
      Scalar variable names begin with a dollar sign, called the sigil
      - these are different
        $name
        $Name
        $NAME
**** 给变量娶个好名字 choosing good variable names
     - 增加可读性
       : properly placed underscores can make a name easier to read and understand
       $super_bowl is a better name than $superbowl
     - 特殊含义的变量
       Using all uppercase (like $ARGV) generally indicates that there’s something special about that variable
     - perlvar documentation
       lists all of the Perl’s special variable names, and perlstyle has general programming style advice
**** 标量的赋值 scalar assignment
     - 如何赋值
       a variable name on the left side, and gives it the value of the expression on the right
       $fred   = 17;
       $barney = 'hello';
       $barney = $fred + 3;
       $barney = $barney * 2;
**** 双目赋值操作符 compound assignment operators
     - 双目赋值操作符
       - the compound assignment operator
         $fred  = $fred + 5; # without the binary assignment operator
         $fred += 5;         # with the binary assignment operator
         $str  = $str . " "; # append a space to $str
         $str .= " ";        # same thing with assignment operator
*** 用print输出结果 output with print
    - print操作符
      it takes a scalar argument and puts it out without any embellishment onto standard output
      : NOTE
      - You can give print a series of values separated by commas
        print "The answer is ", 6 * 7, ".\n";
**** 字符串中的标量变量内插 interpolation of scalar variables into strings
     - 变量内插 variable interpolation
       - a scalar variable name in the string is replaced with its current value
         $meal   = "brontosaurus steak";
         $barney = "fred ate a $meal";    # $barney is now "fred ate a brontosaurus steak"
         $barney = 'fred ate a ' . $meal; # another way to write that
       : NOTE
       - If the scalar variable has never been given a value, the *empty string* is used instead
         $barney = "fred ate a $meat"; # $barney is now "fred ate a "
       - Don’t bother with interpolating if you have just the *one lone variable*
         print "$fred"; # unneeded quote marks
         print $fred;   # better style
       - To put *a literal dollar sign* into a double-quoted string
         $fred = 'hello';
         print "The name is \$fred.\n";    # prints a dollar sign
       - *delimiter or separated* the variable
         $what = "brontosaurus steak";
         $n = 3;
         print "fred ate $n $whats.\n";        # use the value of $whats
         print "fred ate $n ${what}s.\n";      # now use the value of $what
         print "fred ate $n $what" . "s.\n";   # another way to do it

**** 借助代码点创建字符 creating characters by code point
     - 通过代码点(code point)输入键盘上没有的那些字符
       - it’s easier to create them by their code point with the chr() function
         $alef  = chr( 0x05D0 );
         $alpha = chr( hex('03B1') );
         $omega = chr( 0x03C9 );
       : NOTE
       - You can *interpolate* these into double-quoted strings just like any other variable
         "$alpha$omega"
         "\x{03B1}\x{03C9}"
     - 通过特殊字符查找相应代码点
       - with the ord() function, which turns a character into its code point
         $code_point = ord( 'α' );
**** 操作符优先级与结合性 operator precedence and associativity
     - 优先级
       : the same as C
       Associativity and precedence of operators [T En 57]
     - 结合性
       - Just like precedence, associativity resolves the order of operations when *two operators of the same precedence*
         4 ** 3 ** 2      # 4 ** (3 ** 2), or 4 ** 9 (right associative)
         72 / 12 / 3      # (72 / 12) / 3, or 6/3, or 2 (left associative)
         36 / 6 * 3       # (36/6)*3, or 18
     : TIP
     : 直接括号明确顺序
**** 比较操作符 comparison operators
     数值与字符串的比较操作符 [T En 58]
     - example
       35 != 30 + 5        # false
       35 == 35.0          # true
       '35' eq '35.0'      # false (comparing as strings)
       'fred' lt 'barney'  # false
*** if控制结构 the if control structure
    - example
      if ($name gt 'fred') {
        print "'$name' comes after 'fred' in sorted order.\n";
      } else {
        print "'$name' does not come after 'fred'.\n";
        print "Maybe it's the same string, in fact.\n";
      }
    : NOTE
    : You must have those block curly braces around the conditional code, unlike C
**** 布尔值 boolean values
     - perl没有专用的布尔数据类型 它靠一些简单的规则进行判断
       If the value is a *number*, 0 means false; all other numbers mean true
       Otherwise, if the value is a *string*, the empty string ('') and the string '0' means false; all other strings mean true
       If the variable doesn’t have a value yet, it’s false
     - 布尔if判断
       if (! $is_bigger) {
         # Do something when $is_bigger is not true
       }
     - !反转操作
       - use ! return some scalar to represent true and false(1 and 0)
         $still_true  = !! 'Fred';
         $still_false = !! '0';
*** 获取用户输入 getting use input
    - 操作符 <STDIN> 获取键盘输入
      Each time you use <STDIN> in a place where Perl expects a scalar value
      Perl reads the next complete text line from *standard input* (up to the first newline), and uses that string as the value of <STDIN>
      - example
        $line = <STDIN>;
        if ($line eq "\n") {                        =# But in practice, you don’t often want to keep the newline, so you need the chomp() operator=
            print "That was just a blank line!\n";
        } else {
            print "That line of input was: $line";
        }
*** chomp操作符 the chomp operator
    - 去掉字符串变量末尾换行符
      : It works on a variable. The variable has to hold a string, and if the string ends in a newline character, chomp() removes that newline
      - example
        $text = "a line of text\n";    # Or the same thing from <STDIN>
        chomp($text);                  # Gets rid of the newline character
      : NOTE
      : If a string ends with two or more newlines, chomp() removes only one
    - 连用
      - 赋值运算表达式 代替变量参数
        : In fact, there’s an easier way to use chomp() because of a simple rule: any time that you need a variable in Perl, you can use an assignment instead
        - So the most common use of chomp() looks like this
          =# First, Perl does the assignment. Then it uses the variable in whatever way you requested=
          chomp($text = <STDIN>); =# Read the text, without the newline character=

          $text = <STDIN>;        =# Do the same thing...=
          chomp($text);           =# ...but in two steps=
    - 返回值 省略括号
      =# chomp() is actually a function. As a function, it has a return value, which is *the number of characters removed*.=
      =# If there’s no newline, it does nothing, and *returns zero*. For the most part, you don’t care what chomp() returns=
      $food = <STDIN>;
      $betty = chomp $food; =# gets the value 1 - but you knew that!=
      =# As you see, you may write chomp() with or *without the parenthesess*, except in cases where it changes the meaning to remove them=
*** while控制结构 the while control structure
    - while循环
      : The while loop repeats a block of code as long as a condition is true
      $count = 0;
      while ($count < 10) {
          $count += 2;
          print "count is now $count\n"; =# Gives values 2 4 6 8 10=
      }
      : NOTE
      : Eventually you’ll create an infinite loop by accident
      : You can stop it in the same way you’d stop any other program
      : Often, typing Control-C will stop a runaway program
*** undef值 the undef value
    - 空无一物
      : Variables have the special undef value before they are first assigned, which is just Perl’s way of saying, “Nothing here to look at—move along, move along.”
      - If you try to use this “nothing” as a “numeric something,” it acts like zero
         =# Add up some odd numbers=
         $n = 1;
         while ($n < 10) {
           $sum += $n;
           $n += 2; =# On to the next odd number=
         }
         print "The total was $sum.\n";
      - If you try to use it as a “string something,” it acts like the empty string
        $string .= "more text\n";         =# If $string is undef, this will act as if it already held the empty string, putting "more text\n" into that variable=
      - make your own undef values, you can use the obscurely named undef operator
        $next_line = undef; =# As if it had never been touched=
      : NOTE
      : undef is neither a number nor a string; it’s an entirely separate kind of scalar value
*** defined函数 the defined function
    - 判断 undef
      - use the defined function, which returns false for undef, and true for everything else
        $next_line = <STDIN>;
        if ( defined($next_line) ) {
           print "The input was $next_line";
        } else {
           print "No input available!\n";
        }
** 列表与数组 lists and arrays
   - 多个标量组成
     : The list is the data and the array is the variable that stores that data
     : Each element of an array or list is a separate scalar value, The elements of an array or a list are indexed by integers starting at zero and counting by ones
     : Arrays and lists can have any number of elements. The smallest one has no elements, while the largest can fill all of available memory
*** 访问数组中的元素 accessing elements of an array
    - 下标 subscript
      $fred[0] = "yabba";
      $fred[1] = "dabba";
      $fred[2] = "doo";
    - 表达式赋值 change that value by expressions
      $fred[1] .= "whatsis";
    - 舍去小数
      $number = 2.71828;
      print $fred[$number - 1]; # Same as printing $fred[1]
    - 超出下标范围
      $blank = $fred[ 142_857 ]; # unused array element gives undef
      $blanc = $mel;             # unused scalar $mel also gives undef
*** 特殊的数组索引 special array indices
    - 自动扩展数组长度
      $rocks[0]  = 'bedrock';
      $rocks[1]  = 'slate';
      $rocks[2]  = 'lava';
      $rocks[99] = 'schist';       =# now there are 96 undef elements=
    - 最后一个元素的索引值
      : NOTE  That’s not the same as the number of elements, because there’s an element number zero
      $end = $#rocks;                  # 99, which is the last element's index
      $number_of_rocks = $end + 1;     # OK, but you'll see a better way later
      $rocks[ $#rocks ] = 'hard rock'; # the last rock
    - 负数索引
      : In the real world, nobody seems to use any of these except -1
      $rocks[ -1 ]   = 'hard rock';   # easier way to do that last example
      $dead_rock     = $rocks[-100];  # gets 'bedrock'
      $rocks[ -200 ] = 'crystal';     # fatal error!
*** 列表直接量 list literals
    - 列表元素
      (1, 2, 3)      # list of three values 1, 2, and 3
      (1, 2, 3,)     # the same three values (the trailing comma is ignored)
      ("fred", 4.5)  # two values, "fred" and 4.5
      ( )            # empty list - zero elements
    - 范围操作符
      (1..100)          # list of 100 integers
      (1..5)            # same as (1, 2, 3, 4, 5)
      (1.7..5.7)        # same thing; both values are truncated
      (0, 2..6, 10, 12) # same as (0, 2, 3, 4, 5, 6, 10, 12)
      : NOTE
      : The range operator only counts up, so this won’t work and you’ll get the empty list
      (5..1)            # empty list; .. only counts "uphill"
    - 表达式元素
      ($m, 17)       # two values: the current value of $m, and 17
      ($m+$o, $p+$q) # two values
      ($m..$n)       # range determined by current values of $m and $n
      (0..$#rocks)   # the indices of the rocks array from the previous section
**** qw简写 the qw shortcut
     - 单引号字符串
       : The qw shortcut makes it easy to generate them without typing a lot of extra quote marks
       : NOTE
       : Perl treats it like a single-quoted string (so, you can’t use \n or $fred inside a qw list as you would in a double-quoted string)
       ("fred", "barney", "betty", "wilma", "dino")  =# A list may have any scalar values=
       qw( fred barney betty wilma dino )            =# same as earlier, but less typing=
       : The whitespace (characters like spaces, tabs, and newlines) disappear and whatever is left becomes the list of items
       : Some people like to format their lists with one element per line, which makes it easy to operate as a column
       qw(
           fred
           barney
           betty
           wilma
           dino
       )
       : Perl lets you choose any punctuation character as the delimiter
       qw! fred barney betty wilma dino !
       qw/ fred barney betty wilma dino /
       qw# fred barney betty wilma dino #   =# like in a comment!=
       qw( fred barney betty wilma dino )
       qw{ fred barney betty wilma dino }
       qw{
           /usr/dict/words
           /home/rootbeer/.ispell_english
       }

       : include the closing delimiter within the string as one of the characters by using the backslash
       qw! yahoo\! google ask msn !  =# include yahoo! as an element=
       qw( This as a \\ real backslash )
*** 列表的赋值 list assignment
    - 多重变量赋值
      : All three variables in the list on the left get new values, just as if you did three separate assignments
      ($fred, $barney, $dino) = ("flintstone", "rubble", undef);
      : swap two variables
      ($fred, $barney) = ($barney, $fred); =# swap those values=
      ($betty[0], $betty[1]) = ($betty[1], $betty[0]);
      : In a list assignment, extra values are silently ignored
      ($fred, $barney) = qw< flintstone rubble slate granite >; =# two ignored items=
      : if you have too many variables, the extras get the value undef (or the empty list)
      ($wilma, $dino)  = qw[flintstone];                        =# $dino gets undef=
      : use with qw
      ($rocks[0], $rocks[1], $rocks[2], $rocks[3]) = qw/talc mica feldspar quartz/;
      : Use the at sign (@) before the name of the array (and no index brackets after it) to refer to the entire array at once
      : TIP  This works on either side of the assignment operator
      @rocks  = qw/ bedrock slate lava /;
      @tiny   = ( );                       =# the empty list=
      @giant  = 1..1e5;                    =# a list with 100,000 elements=
      @stuff  = (@giant, undef, @giant);   =# a list with 200,001 elements=
      $dino   = "granite";
      @quarry = (@rocks, "crushed rock", @tiny, $dino)
      : copy an array to another array, it’s still a list assignment
      @copy = @quarry; =# copy a list from one array to another=
**** pop和push操作符 the pop and push operators
     - 数组末尾添加删除操作
       : You could add new items to the end of an array by simply storing them as elements with new, larger indices
       : The pop operator takes the last element off of an array and returns it
       @array  = 5..9;
       $fred   = pop(@array);  =# $fred gets 9, @array now has (5, 6, 7, 8)=
       $barney = pop @array;   =# $barney gets 8, @array now has (5, 6, 7)=
       : That last example uses pop in a void context, which is merely a fancy way of saying the return value isn’t going anywhere
       pop @array;             =# @array now has (5, 6). (The 7 is discarded.)=
       : NOTE
       If the array is empty, pop leaves it alone (since there is no element to remove) and returns undef

       : The converse operation is push, which adds an element (or a list of elements) to the end of an array
       push(@array, 0);            =# @array now has (5, 6, 0)=
       push @array, 8;             =# @array now has (5, 6, 0, 8)=
       push @array, 1..10;         =# @array now has those 10 new elements=
       @others = qw/ 9 0 2 1 0 /;
       push @array, @others;       =# @array now has those five new elements (19 total)=

       : NOTE
       the first argument to push or the only argument for pop must be an array variable—pushing and popping would not make sense on a literal list
**** shift和unshift操作符 the shift and unshift operators
     - 数组开头添加删除操作
       @array = qw# dino fred barney #;
       $m = shift(@array);      =# $m gets "dino", @array now has ("fred", "barney")=
       $n = shift @array;       =# $n gets "fred", @array now has ("barney")=
       shift @array;            =# @array is now empty=
       $o = shift @array;       =# $o gets undef, @array is still empty=
       unshift(@array, 5);      =# @array now has the one-element list (5)=
       unshift @array, 4;       =# @array now has (4, 5)=
       @others = 1..3;
       unshift @array, @others; =# @array now has (1, 2, 3, 4, 5)=
       : NOTE
       shift returns undef if you give it an empty array variable
**** splice操作符 the splice operator
     - 数组中间添加删除操作
       : splice operator takes up to four arguments, two of which are optional
       : The first argument is always the array
       : the second argument is the position where you want to start
       : If you only use those two arguments, Perl removes all of the elements from your starting position to the end and returns them to you
       @array = qw( pebbles dino fred barney betty );
       @removed = splice @array, 2; =# remove fred and everything after=
                                    =# @removed is qw(fred barney betty)=
                                    =# @array is qw(pebbles dino)=
       : use a third argument to specify a length
       @array = qw( pebbles dino fred barney betty );
       @removed = splice @array, 1, 2; =# remove dino, fred=
                                       =# @removed is qw(dino fred)=
                                       =# @array is qw(pebbles barney betty)=
       : The fourth argument is a replacement list
       @array = qw( pebbles dino fred barney betty );
       @removed = splice @array, 1, 2, qw(wilma); =# remove dino, fred=
                                                  =# @removed is qw(dino fred)=
                                                  =# @array is qw(pebbles wilma=
                                                  #              barney betty)
       : If you specify a length of 0, you remove no elements but still insert the “replacement” list
       @array = qw( pebbles dino fred barney betty );
       @removed = splice @array, 1, 0, qw(wilma); =# remove nothing  NOTE: Perl inserted the replacement list starting at index 1 and moved everything else over=
                                                  =# @removed is qw()=
                                                  =# @array is qw(pebbles wilma dino=
                                                  =#              fred barney betty)=

*** 字符串中的数组内插 interpolating arrays into strings
    - 双引号字符串 数组内插
      @rocks = qw{ flintstone slate rubble };
      print "quartz @rocks limestone\n";  =# prints five rocks separated by spaces=
      : There are no extra spaces added before or after an interpolated array; if you want those, you’ll have to put them in yourself
      print "There's nothing in the parens (@empty) here.\n";
    - 规避数组内插
      $email = "fred@bedrock.edu";  # WRONG! Tries to interpolate @bedrock
      Possible unintended interpolation of @bedrock
      : To get around this problem, you either escape the @ in a double-quoted string or use a single-quoted string
      $email = "fred\@bedrock.edu"; # Correct
      $email = 'fred@bedrock.edu';  # Another way to do that
    - 内插数组中的某个元素
      @fred = qw(hello dolly);
      $y = 2;
      $x = "This is $fred[1]'s place";    # "This is dolly's place"
      $x = "This is $fred[$y-1]'s place"; # same thing
    - 索引表达式
      : Note that the index expression evaluates as an ordinary expression, as if it were outside a string. It is not variable-interpolated first
      @fred = qw(eating rocks is wrong);
      $fred = "right";               =# we are trying to say "this is right[3]".=
      print "this is $fred[3]\n";    =# prints "wrong" using $fred[3]=
      print "this is ${fred}[3]\n";  =# prints "right" (protected by braces)=
      print "this is $fred"."[3]\n"; =# right again (different string)=
      print "this is $fred\[3]\n";   =# right again (backslash hides it)=
*** foreach控制结构 the foreach control structure
    - 遍历列表中的值
      foreach $rock (qw/ bedrock slate lava /) {
          print "One rock is $rock.\n";  =# Prints names of three rocks=
      }
    - 循环中修改控制变量
       @rocks = qw/ bedrock slate lava /;
       foreach $rock (@rocks) {
           $rock = "\t$rock";       # put a tab in front of each element of @rocks
           $rock .= "\n";           # put a newline on the end of each
       }
       print "The rocks are:\n", @rocks; # Each one is indented, on its own line
    - 控制变量在循环结束之后还原
      : after the loop is done, the variable has the value it had before the loop, or undef if it hadn’t had a value
      $rock = 'shale';
      @rocks = qw/ bedrock slate lava /;
      foreach $rock (@rocks) {
        ...
      }
      : TODO
      After we introduce subroutines to you in Chapter 4, we’ll show you a better way to handle that
**** perl最喜欢的默认变量:$_  perl's favorite default:$_
     - 缺省控制变量
       : If you omit the control variable from the beginning of the foreach loop, Perl uses its <<favorite default variable>>, $_
       foreach (1..10) {  # Uses $_ by default
         print "I can count to $_!\n";
       }
       : one of those cases is print, which will output $_ if given no other argument
       $_ = "Yabba dabba doo\n";
       print;  # prints $_ by default
**** reverse操作符 the reverse operator
     - 逆序返回列表值
       : The reverse operator takes a list of values (which may come from an array) and returns the list in the opposite order
       - So if you were disappointed that the range operator only counts upward, this is the way to fix it
         @fred   = 6..10;
         @barney = reverse(@fred);  =# gets 10, 9, 8, 7, 6=
         @wilma  = reverse 6..10;   =# gets the same thing, without the other array=
         @fred   = reverse @fred;   =# puts the result back into the original array  NOTE: Perl always calculates the value being assigned (on the right) before it begins the actual assignment=
       : Remember that reverse returns the reversed list; it doesn’t affect its arguments. If the return value isn’t assigned anywhere, it’s useless
       reverse @fred;           =# WRONG - doesn't change @fred=
       @fred = reverse @fred;   =# that's better=
**** sort操作符 the sort operator
     - 按字符编码顺序进行排序
       : The sort operator takes a list of values (which may come from an array) and sorts them in the internal character ordering
       - The sort operator takes an input list, sorts it, and outputs a new list
         @rocks   = qw/ bedrock slate rubble granite /;
         @sorted  = sort(@rocks);        # gets bedrock, granite, rubble, slate
         @back    = reverse sort @rocks; # these go from slate to bedrock
         @rocks   = sort @rocks;         # puts sorted result back into @rocks
         @numbers = sort 97..102;        # gets 100, 101, 102, 97, 98, 99
         : TODO
         you’ll see in Chapter 14 how to sort in whatever order you’d like
       : the arguments themselves aren’t affected. If you want to sort an array, you must store the result back into that array
       sort @rocks;          # WRONG, doesn't modify @rocks
       @rocks = sort @rocks; # Now the rock collection is in order
**** each操作符 the each operator
     - 使用each 返回下一个元素对应的两个值
       : Every time that you call each on an array, it returns two values for the next element in the array—the index of the value and the value itself
       require v5.12;
       @rocks = qw/ bedrock slate rubble granite /;
       while( ( $index, $value ) = each @rocks ) {
           print "$index: $value\n";
       }
       : TODO
       but we don’t show you those until Chapter 6
     - 借助索引值取得元素的值
       : If you wanted to do this without each, you have to iterate through all of the indices of the array and use the index to get the value
       @rocks   = qw/ bedrock slate rubble granite /;
       foreach $index ( 0 .. $#rocks ) {
           print "$index: $rocks[$index]\n";
       }
*** 标量上下文与列表上下文 scalar and list context *[important section]*
    - 一个表达式出现在不同的地方会有不同的意义
      : a given expression may mean different things depending upon where it appears and how you use it
      - it’s the operator that decides what you are doing, not the values
        2 * 3      =# numeric multiplication 6=
        2 x 3      =# string replication 222=
      : As Perl is parsing your expressions, it always expects either a scalar value or a list value (or void, which we don’t cover in this book)
      - What Perl expects is called the context of the expression
        42 + something =# The something must be a scalar=
        sort something =# The something must be a list=
      - In a list context, it gives the list of elements. But in a scalar context, it returns the number of elements in the array
        @people = qw( fred barney betty );
        @sorted = sort @people;  # list context: barney, betty, fred
        $number = 42 + @people;  # scalar context: 42 + 3 gives 45
      - Even ordinary assignment (to a scalar or a list) causes different contexts
        @list = @people; =# a list of three people=
        $n = @people;    =# the number 3=
      : TIP
      Each expression can make up its own rules
      follow the overall rule that isn’t very helpful to you
**** 在标量上下文中使用产生列表的表达式 using list-producing expressions in scalar context
     - sort标量上下文
       : sort
       You wouldn’t need to sort a list to count its elements, so until someone implements something else, sort in a scalar context always returns undef
     - reverse标量上下文
       : reverse
       - In a list context, it gives a reversed list. In a scalar con‐ text, it returns a reversed string
         @backwards = reverse qw/ yabba dabba doo /;
             # gives doo, dabba, yabba
         $backwards = reverse qw/ yabba dabba doo /;
             # gives oodabbadabbay
     - 判断上下文
       : At first, it’s not always obvious whether an expression is being used in a scalar or a list context. But trust us, it will become second nature for you eventually
       - Here are some common contexts to start you off
         $fred = something;            =# scalar context=
         @pebbles = something;         =# list context=
         ($wilma, $betty) = something; =# list context=
         ($dino) = something;          =# still list context!=
       - some that provide scalar context to something
         $fred = something;
         $fred[3] = something;
         123 + something
         something + 654
         if (something) { ... }
         while (something) { ... }
         $fred[something] = something;
       - some that provide a list context
         @fred = something;
         ($fred, $barney) = something;
         ($fred) = something;
         push @fred, something;
         foreach $fred (something) { ... }
         sort something
         reverse something
         print something
**** 在列表上下中使用产生标量的表达式 using scalar-producting expressions in list context
     - 产生一个仅含此标量值的列表
       : if an expression doesn’t normally have a list value, the scalar value is automatically promoted to make a one-element list
       @fred = 6 * 7;    =# gets the one-element list (42)=
       @barney = "hello" . ' ' . "world";
       : NOTE
       : Well, there’s one possible catch. Since undef is a scalar value, assigning undef to an array doesn’t clear the array. The better way to do that is to assign an empty list
       @wilma = undef; # OOPS! Gets the one-element list (undef)
           # which is not the same as this:
       @betty = ( );    =# A correct way to empty an array=
**** 强制指定标量上下文 forcing scalar context
     - 使用scalar强制引入标量上下文
       : On occasion, you may need to force scalar context where Perl is expecting a list.
       : In that case, you can use the fake function scalar. It’s not a true function because it just tells Perl to provide a scalar context
       @rocks = qw( talc quartz jade obsidian );
       print "How many rocks do you have?\n";
       print "I have ", @rocks, " rocks!\n";        # WRONG, prints names of rocks
       print "I have ", scalar @rocks, " rocks!\n"; # Correct, gives a number
       : NOTE
       Oddly enough, there’s no corresponding function to force list context. It turns out you almost never need it. Trust us on this
*** 列表上下文中的<STDIN> <STDIN> in list context
    - 读入标准输入
      @lines = <STDIN>; =# read standard input in list context=
      : you’ll normally type a Control-D to indicate to the system that there’s no more input

      - it will remove the newlines from each item in the list. For example
        @lines = <STDIN>;        =# Read all the lines=
        chomp(@lines);           =# discard all the newline characters=
        : the more common way to write that
        chomp(@lines = <STDIN>); =# Read the lines, not the newlines=
      : NOTE
      If the input data is large, you should generally find a way to deal with it without reading it all into memory at once
** 子程序 subroutines
*** 定义子程序 defining a subroutine
    - 子程序主体
      =// NOTE=
      =// You may put your subroutine definitions anywhere in your program text, you don’t normally need any kind of forward declaration=
      =// If you have two subroutine definitions with the same name, the later one overwrites the earlier one=
      sub marine {
            $n += 1;  # Global variable $n         <<Global variable>>
            print "Hello, sailor number $n!\n";
      }
    - 全局变量
      [[Global variable]]
      In fact, all of the variables you’ve seen so far are global; that is, they are accessible from every part of your program
      : TODO
      You’ll see how to make private variables in the section “Private Variables in Subroutines” on page 66
*** 调用子程序 invoking a subroutines
    - 使用子程序名
      : calling the subroutine by using the subroutine name (with the ampersand)
      &marine;  # says Hello, sailor number 1!
      &marine;  # says Hello, sailor number 2!
*** 返回值 return value
    - 处理子程序的返回值
      : Many times, you call a subroutine and actually do something with the result
      : NOTE: All Perl subroutines have a return value
      sub sum_of_fred_and_barney {
            print "Hey, you called the sum_of_fred_and_barney subroutine!\n";
            $fred + $barney;  # That's the return value    [[return value]]
      }

      $fred   = 3;
      $barney = 4;
      $wilma  = &sum_of_fred_and_barney;      # $wilma gets 7
      print "\$wilma is $wilma.\n";
      =# ouput=
        =Hey, you called the sum_of_fred_and_barney subroutine!=
        =$wilma is 7.=

      $betty  = 3 * &sum_of_fred_and_barney;  # $betty gets 21
      print "\$betty is $betty.\n";
      =# output=
        =Hey, you called the sum_of_fred_and_barney subroutine!=
        =$betty is 21.=
    - 最后执行的语句被当成返回值
      <<return value>>
      : Whatever calculation is last performed in a subroutine is automatically also the return value

      : the last expression now the print statement, whose return value is normally 1, meaning “printing was successful"
      sub sum_of_fred_and_barney {
            print "Hey, you called the sum_of_fred_and_barney subroutine!\n";
            $fred + $barney;  # That's not really the return value!
            print "Hey, I'm returning a value now!\n";      # Oops!
      }

      : “The last evaluated expression” really means the last expression that Perl evaluates, rather than the last statement in the subroutine
      sub larger_of_fred_or_barney {
        if ($fred > $barney) {
          $fred;
        } else {
          $barney;
        }
      }
*** 参数 arguments
    - 带参数调用子程序
      : To pass an argument list to the subroutine, simply place the list expression, in parentheses, after the subroutine invocation
      $n = &max(10, 15);  # This sub call has two parameters

      : Perl automatically stores the parameter list in the special array variable named @_, this is valid during program execution
      sub max {
            =# This means that the first subroutine parameter is in $_[0], the second one is stored in $_[1], and so on=
            if ($_[0] > $_[1]) {
              $_[0];
            } else {
              $_[1];
      } }
      : a better way:  [[private variables]]

      : Perl doesn’t care about insufficient parameters either
      $n = &max(10, 15, 27);  =# extra parameters 27 will be omit=
      $n = &max(10);          =# the default second argument will return undef=
*** 子程序中的私有变量 private variables in subroutines
    - 封闭语句块私有变量
      : you can create private variables called lexical variables at any time with the my operator
      sub max {
            my($m, $n);       # new, private variables for this block
            ($m, $n) = @_;    # give names to the parameters
          =# my($m, $n) = @_;  # make the subroutine in the previous two lines even simpler=
                              =# When you see that line, you’ll know that the subroutine expects two scalar parameters, which you’ll call $m and $n inside the subroutine=
            if ($m > $n) { $m } else { $n }
      }
*** 变长参数列表 cariable-length patameter lists
    - 检查参数列表
      sub max {
        if (@_ != 2) {  =# uses the “name” of the array in a scalar context to find out the number of array elements, as you saw in Chapter 3=
           print "WARNING! &max should get exactly two arguments!\n";
        }
        # continue as before...
      }
      : But in real-world Perl programming, virtually no one really uses this sort of check; it’s better to make your subroutines adapt to the parameters
**** 改进的&max子程序 a better &max routine
     : Rewrite &max to allow for any number of arguments
     $maximum = &max(3, 5, 10, 4, 6);

     sub max {
       my($max_so_far) = shift @_;  =# the first one is the largest yet seen    NOTE: if the &max is a <<empty list>>, shift @_ will return undef=
       foreach (@_) {               =# look at the remaining arguments          NOTE: if @_ is undef, the loop body execute zero times=
         if ($_ > $max_so_far) {    =# could this one be bigger yet?=
           $max_so_far = $_;
         }
       }
       $max_so_far;
     }
**** 空参数列表 empty parameter lists
     : if the array @numbers might sometimes be an [[empty list]]
     : the return value may be undef
     $maximum = &max(@numbers);
*** 关于词法(my)变量 notes on lexical(my) variables
    - 将变量圈定在指定代码内
      - Those lexical variables can actually be used in any block, not merely in a subroutine’s block
        =# The variable $square is private to the enclosing block; in this case, that’s the block of the foreach loop=
        foreach (1..10) {
              my($square) = $_ * $_;  # private variable in this loop
              print "$_ squared is $square.\n";
        }
        : TIP
        : the scope of a lexical variable’s name is limi‐ ted to the smallest enclosing block or file
      - Note also that the my operator *doesn’t change the context* of an assignment
        my($num) = @_;  =# list context, same as ($num) = @_;=
        my $num  = @_;  =# scalar context, same as $num = @_;=
      - Remember that *without the parentheses*, my only declares a single lexical variable
        my $fred, $barney;      # WRONG! Fails to declare $barney
        my($fred, $barney);     # declares both
      - use my to create new, private *arrays*
        my @phone_number;
      - in perl, you may use my to introduce a new perivate variable in your own structure
        foreach my $rock (qw/ bedrock slate lava /) {
              print "One rock is $rock.\n";  # Prints names of three rocks
        }
*** use strict编译指令 the use strict progma
    - 遵循优良编程风格
      : Perl tends to be a pretty permissive language.
      : the use strict pragma tells Perl’s internal compiler that it should enforce some good programming rules for the rest of this block or source file

      : without use strict progma
      =# imagine that you’re composing your program and you type a line like this one=
      $bamm_bamm = 3;  =# Perl creates that variable automatically=
      =# Now, you keep typing for a while. After that line has scrolled off the top of the screen, you type this line to increment the variable=
      $bammbamm += 1;  =# Oops! perl create a new variable=
      : with use strict progma
      use strict;  =# Enforce some good programming rules=
      my $bamm_bamm = 3;  =# New lexical variable=
      $bammbamm += 1;  =# No such variable: Compile time fatal error=
*** return操作符 the return operator
    - 程序执行停止 返回值
      my @names = qw/ fred barney betty dino wilma pebbles bamm-bamm /;
      my $result = &which_element_is("dino", @names);
      sub which_element_is {
          my($what, @array) = @_;
          foreach (0..$#array) {  # indices of @array's elements
              if ($what eq $array[$_]) {  =# element not found (return is optional here)=
                  return $_;
              }
          }
          -1;  =# return early once found=
      }
*** 省略与号 omitting the ampersand
    - 省略子程序识别符&
      : if it is a function call, it may should not add &
      my @cards = shuffle(@deck_of_cards); =# No & necessary on &shuffle=
      : or if the subroutine is appeared earlier
      sub division {
            $_[0] / $_[1];                   # Divide first param by second
          }
      my $quotient = division 355, 113;  # Uses &division
      : NOTE
      : if the subroutines has the same name as a perl's build-in, you must use & to call your version
      sub chomp {
            print "Munch, munch!\n";
          }
      &chomp;  =# That ampersand is not optional!=
*** 非标量返回值 nonscalar return values
    - 子程序返回列表值
      sub list_from_fred_to_barney {
            if ($fred < $barney) {
              # Count upwards from $fred to $barney
              $fred..$barney;
            } else {
              # Count downwards from $fred to $barney
              reverse $barney..$fred;
            }
      }
      $fred = 11;
      $barney = 6;
      @c = &list_from_fred_to_barney; # @c gets (11, 10, 9, 8, 7, 6)
*** 持久性私有变量 persistent, private variables
    - state变量
      - 非state变量无法存续
        =# add strict to you program and realize that your use of the global variable $n is now a compilation error=
        =# You can’t make $n a lexical variable with my because it wouldn’t retain its value between calls=
        use strict
        sub marine {
              $n += 1;  # Global variable $n (not declare error)
              my y += 1; # Subroutine private variable my y (can not retain)
              print "Hello, sailor number $n!\n";
        }
      - 多次调用子程序期间保留state变量的值
        =# Declaring our variable with state tells Perl to retain the variable’s value between calls to the subroutine and to make the variable private to the subroutine=
        use v5.10;
            sub marine {
              state $n = 0;  # private, persistent variable $n
              $n += 1;
              print "Hello, sailor number $n!\n";
        }

        =# You can make any variable type a state variable, it’s not just for scalars=
        Here’s a sub‐ routine that remembers its arguments and provides a running sum by using a state array
        use v5.10;
        running_sum( 5, 6 );
        running_sum( 1..3 );
        running_sum( 4 );
        sub running_sum {
          state $sum = 0;
          state @numbers;
          foreach my $number ( @_ ) {
            push @numbers, $number;
            $sum += $number;
          }
          say "The sum of (@numbers) is $sum";
        }
        The sum of (5 6) is 11
        The sum of (5 6 1 2 3) is 17
        The sum of (5 6 1 2 3 4) is 21
        : NOTE
        : You can’t initialize arrays and hashs as state variables in list contexts
        state @array = qw(a b c); # Error!
*** subroutine signatures
    - enable signatures feature
      use v5.20;
      use feature qw(signatures);
      no warnings qw(experimental::signatures);
    - make subroutine a functin with argument like
      sub max ( $m, $n ) { =# The variables are still private to the subroutine but you type much less to declare and assign to them=
          if ($m > $n) { $m } else { $n }
          =# the same as below without signatures=
          =# my($m, $n);=
          =# ($m, $n) = @_;=
      }
    - handle too many or too few argument
      : more argument
      sub max ( $max_so_far, @ ) {  =# the plain @ is same as @rest=
        foreach (@_) {              =# the argument list shows up in @_, which replace the @rest=
          if ($_ > $max_so_far) {
            $max_so_far = $_;
          }
        }
        $max_so_far;
      }

      : less argument with default set
      sub list_from_fred_to_barney ( $fred = 0, $barney = 7 ) { =# Signatures can also specify defaults=
        if ($fred < $barney) { $fred..$barney }
        else                 { reverse $barney..$fred }
      }
      my @defaults    = list_from_fred_to_barney();
      my @default_end = list_from_fred_to_barney( 17 );
      say "defaults: @defaults";
      say "default_end: @default_end";

      : less argument with default set
      : use the $= placeholder to denote an optional argument
      sub one_or_two_args ( $first, $= ) { ... }
** 输入与输出 input and output
*** 读取标准输入 input from standard input
    - 读取用户输入的各种方式
      : scalar context
      $line = <STDIN>;         =# read the next line=
      chomp($line);            =# and chomp it=
      chomp($line = <STDIN>);  =# same thing, more idiomatically=

      : loop
      =# Since the line-input operator will return undef when you reach end-of-file, this is handy for dropping out of loops=
      : output complete
      while (defined($line = <STDIN>)) {  =# reading input into $line variable=
            print "I saw $line";
      }
      while (defined($_ = <STDIN>)) {     =# reading input into default variable $_  NOTE: the line-input operator($_) is not [[favorite default variable]]=
            print "I saw $_";
      }
      while (<STDIN>) {                   =# omit the default varuable $_, the same as above=
            print "I saw $_";
      }
      : output one line per list element
      foreach (<STDIN>) {
            print "I saw $_";
      }
*** 来自钻石操作符的输入 input from the diamond operator
    - 读入文件内容
      : This is useful for making programs that work like standard Unix utilities, with respect to the invocation arguments
      =# That command means to run the command my_program (which will be found in the current directory), and process file fred followed by barney, followed by betty=
      $ ./my_program fred barney betty

      : The diamond operator is actually a special kind of line-input operator. But instead of getting the input from the keyboard, it comes from the user’s choice of input
      while (defined($line = <>)) {
            chomp($line);
            print "It was $line that I saw!\n";
      }
      =# without an argument, chomp works on $_=
      while (<>) {
            chomp;
            print "It was $_ that I saw!\n";
      }
*** the double diamond
    - prevent diamond operator command line having a special characher
      : Suppose that the filename from the command line has a special character in such, such as |.
      : This might cause perl to perform a “pipe open”, which runs an external program and reads that program’s output as if it were a file.
      : The “double diamond” operator, <<>>, prevents this
      use v5.22;
          while (<<>>) {
            chomp;
            print "It was $_ that I saw!\n";
      }
*** 调用参数 the invocation arguments
    - 预填充命令行参数数组
      : @ARGV array is a special array that is preset by the Perl interpreter as the list of the invocation arguments.
      : but when your program starts, @ARGV is already stuffed full of the list of invocation arguments

      : The diamond operator looks in @ARGV to determine what filenames it should use
      @ARGV = qw# larry moe curly #;  # force these three files to be read  =If it finds an empty list, it uses the standard input stream=
      while (<>) {
            chomp;
            print "It was $_ that I saw in some stooge-like file!\n";
      }
*** 输出到标准输出 output to standard output
    
** 哈希 hashes
*** 什么是哈希 what is hash
    - 键值对
      A hash is a data structure
      the indices, called keys are always unique
      each keys has a tag attached, called values may be all numbers, all strings, undef values, or a mixture, and you may use same value more than once
      the keys and values are both arbitrary scalars, but the keys are always converted to string
      : TIP
      the large size of hash will not slow down the speed
** 正则表达式 regular expressions
*** 使用简单模式 sequences                                                       :ATTACH:
    :PROPERTIES:
    :Attachments: sequence_pattern.pl
    :ID:       D4F7B55C-347F-4A08-B20C-FC31ED0385B3
    :END:
    - 字符串精确匹配
      Perl’s regular expressions either match a string or they don’t. There is no such thing as a partial match.
      It matches the leftmost, longest substring that satisfies the pattern

      The simplest sort of pattern is sequence.
      You put literal characters next to each other to assert that you want to match a substring with those characters in that order
*** practice some patterns                                                      :ATTACH:
    :PROPERTIES:
    :Attachments: practice_patterns.pl
    :ID:       9A046A5F-6797-4004-8794-BAD19716C059
    :END:
    - 正则匹配交互模式
      pattern with <STDIN>
*** Unicode属性 Unicode Properties                                              :ATTACH:
    :PROPERTIES:
    :Attachments: unicode_properties.pl
    :ID:       B82CF6C4-FC67-408D-AD1D-85EDC5478A33
    :END:
    - 根据字符的属性来达成匹配
      Unicode characters know something about themselves, they aren’t just sequences of bits
      Every character not only knows what it is, but it also knows what properties it has
      Instead of matching on a particular character, you can match a type of character
** 用正则表达式进行匹配 matching with regular expressions
   how the world of regular expressions fits into the world of perl
*** 用m//进行匹配 matches with m//                                              :ATTACH:
    :PROPERTIES:
    :Attachments: pattern_match_operator.pl
    :ID:       5FF13B00-6FF2-4816-A89A-7293F92D1872
    :END:
    - 模式匹配擦作符 pattern match operator
*** 模式匹配修饰符 match modifiers
    
** 用正则表达式处理文本 processing text with regular expressions
   use regular expressions to change text
*** 用s///进行替换 substitutions with s///                                      :ATTACH:
    :PROPERTIES:
    :Attachments: pattern_match_operator.pl
    :ID:       208FE17D-9DE8-43FF-9CE7-225CF45B673F
    :END:
    - 查找并替换
      If you think of the m// pattern match as being like your word processor’s “search” feature
      the “search and replace” feature would be Perl’s s/// substitution operator
** 其他控制结构 more control structures
   alternative ways to write perl code
*** unless控制结构 the unless control structure                                 :ATTACH:
    :PROPERTIES:
    :Attachments: unless.pl
    :ID:       B5BFBD27-1F35-41B7-AAE0-5583A7710FFC
    :END:
    unless = if no
** perl模块 perl modules
   if there is a problem to solve, somebody has probably already solved it and made their solution available on the comprehensive perl archive network (CPAN)
*** 寻找模块 finding modules
    to find modules that don't come with perl, start at either [[http://search.cpan.org][CPAN Search]] or [[https://metacpan.org][Meta-CPAN]]
    - before you go lokking for a modules, you should check if it is already installed
      one way is to try to read the documentation with *perldoc*
      - the Digest::SHA modules comes with Perl, so you should be able to *read its document*
        $ perldoc Digest::SHA
      - try it with a modules that *does not exist* and you'll get an error message
        $ perldoc Llamas
        No documentation found for "Llamas"
      - The cpan command that comes with Perl can give you details on a module
        $ cpan -D Digest::SHA
** 文件测试 file tests
   perl has a complete set of tests you can use to find out information about files
*** 文件测试操作符 file test operators                                          :ATTACH:
    :PROPERTIES:
    :Attachments: test_operators.pl
    :ID:       D28C7069-BACE-4D6A-B1FA-A9E4B66C9499
    :END:
    - perl has a set of test operatorss that let you get particular information about files
      they all take the form of -X, where the X represents the particular test
      - to get the argument list of -X, use
        $ perldoc -f -X  =# you'll find documentation in perlfunc=
    - file tests and their meanings [T] (En 232-233)
      -r -w -x -o       tell whether the given attribute is true for the effective user or group ID,
                        which essentially refers to the person who is “in charge of ” running the program
      -R -W -X -O       tests use the real user or group ID,
                        which becomes important if your program may be running set-ID
      -s                test does return true if the file is nonempty
      -f -d -l -S -p -b -c         test seven types of items on a unix filesystem
      -M -A -C          return the number of days since the file was last modified, accessed or had its innode changed
      -T -B             take a try at telling whether a file is text or binary
      -t                test returns true if the given filehandle is a TTY--if it's interactive
* READING swift官方文档 swift document
** 3.0.1
*** 关于Swift about Swift
    - 特性介绍
      Swift is a new programming language for iOS, macOS, watchOS, and tvOS apps that builds on the best of C and Objective-C, without the constraints of C compatibility
      Swift’s clean slate, backed by the mature and much-loved Cocoa and Cocoa Touch frameworks
      It is the first industrial-quality systems programming language that is as expressive and enjoyable as a scripting language
      It supports playgrounds(代码预览)
         an innovative feature that allows programmers to experiment with Swift code and see the results immediately
         without the overhead of building and running an app
*** Swift初见 a Swift tour
**** 简单值 simple values
     - 常量 变量 constants and variables
       : Use var to make a variable
       var myVariable = 42
       myVariable = 50
       : Use let to make a constant
       : use constants to name a value that you determine once but use in many places.
       let myConstant = 42

       : write the type explicitly
       let implicitInteger = 70
       let implicitDouble = 70.0
       : Providing a value when you create a constant or variable lets the compiler infer its type
       let explicitDouble: Double = 70

       : an simpler way to include values in strings
       : Write the value in parentheses, and write a backslash (\) before the parentheses
       let apples = 3
       let oranges = 5
       let appleSummary = "I have \(apples) apples."
       let fruitSummary = "I have \(apples + oranges) pieces of fruit."
     - 数组 字典 arrays and dictionaries
       : Create arrays and dictionaries using brackets ([]), and access their elements by writing the index or key in brackets. A comma is allowed after the last element
       1. var shoppingList = ["catfish", "water", "tulips", "blue paint"]
       2. shoppingList[1] = "bottle of water"
       3.
       4. var occupations = [
       5. "Malcolm": "Captain",
       6. "Kaylee": "Mechanic",
       7. ]
       8. occupations["Jayne"] = "Public Relations"
       : To create an empty array or dictionary
       : use the initializer syntax
       1. let emptyArray = [String]()
       2. let emptyDictionary = [String: Float]()
       : write an empty array as [] and an empty dictionary as [:]
       1. shoppingList = []
       2. occupations = [:]
**** 控制流 control flow
     - if
       : Use if and switch to make conditionals
       let individualScores = [75, 43, 103, 87, 12]
       var teamScore = 0
       for score in individualScores {
           if score > 50 {
               teamScore += 3
           } else {
               teamScore += 1
           }
       }
       : NOTE: In an if statement, the conditional must be a Boolean expressio
       :       this means that code such as if score { ... } is an error, not an implicit comparison to zero
     - optional value and default value
       : use if and let together to work with values that might be missing
       var optionalString: String? = "Hello"    =// Write a question mark (?) after the type of a value to mark the value as optional=
                                                =// An optional value either contains a value or contains nil to indicate that a value is missing=
       print(optionalString == nil)
       var optionalName: String? = "John Appleseed"
       var greeting = "Hello!"
       if let name = optionalName {
           greeting = "Hello, \(name)"
       }
       : Another way to handle optional values
       let nickName: String? = nil
       let fullName: String = "John Appleseed"
       let informalGreeting = "Hi \(nickName ?? fullName)"  =// provide a default value using the ?? operator. If the optional value is missing, the default value is used instead=
     - switch
       : support any kind of data and a wide variety of comparison operations
       let vegetable = "red pepper"
       switch vegetable {
       case "celery":
           print("Add some raisins and make ants on a log.")
       case "cucumber", "watercress":
           print("That would make a good tea sandwich.")
       case let x where x.hasSuffix("pepper"):
           print("Is it a spicy \(x)?")
       default:    =// NOTE=
           print("Everything tastes good in soup.")
       }
     - for-in
       : iterate over items in a dictionary
       let interestingNumbers = [
           "Prime": [2, 3, 5, 7, 11, 13],
           "Fibonacci": [1, 1, 2, 3, 5, 8],
           "Square": [1, 4, 9, 16, 25],
       ]
       var largest = 0
       for (kind, numbers) in interestingNumbers {  =// providing a pair of names to use for each key-value pair=
           for number in numbers {
               if number > largest {
                   largest = number
               }
           }
       }
       print(largest)

       : range
       var total = 0
       for i in 0..<4 {  =// Use ..< to make a range that omits its upper value, and use ... to make a range that includes both values=
               total += i
       }
       print(total)
     - while
       var n = 2
       while n < 100 {  =// repeat a block of code until a condition changes=
           n = n * 2
       }
       print(n)

       var m = 2
       repeat {
           m = m * 2
       } while m < 100  =// The condition of a loop can be at the end instead, ensuring that the loop is run at least once=
       print(m)
**** 函数和闭包 functin and closures
     - function
       : Use func to declare a function
       : Call a function by following its name with a list of arguments in parentheses
       : Use -> to separate the parameter names and types from the function’s return type.
       func greet(person: String, day: String) -> String {
           return "Hello \(person), today is \(day)."
       }
       greet(person:"Bob", day: "Tuesday")  =// By default, functions use their parameter names as labels for their arguments=

       : custom arguments
       func greet(_ person: String, on day: String) -> String {  =// Write a custom argument label before the parameter name, or write _ to use no argument label=
           return "Hello \(person), today is \(day)."
       }
       greet("John", on: "Wednesday")

       : tuple
       : Use a tuple to make a compound value
       func calculateStatistics(scores: [Int]) -> (min: Int, max: Int, sum: Int) {
           var min = scores[0]
           var max = scores[0]
           var sum = 0

           for score in scores {
               if score > max {
                   max = score
               } else if score < min {
                   min = score
               }
               sum += score
           }
           return (min, max, sum)
       }
       let statistics = calculateStatistics(scores:[5, 3, 100, 3, 9])
       print(statistics.sum)
       print(statistics.2)
* READING Rust程序设计语言 the rust programming language
** 第一版 first version
** 第二版 second version
*** 介绍 introduction
    - 系统编程语言
      Rust is a systems programming language focused on three goals: safety, speed, and concurrency
    - 嵌入其他语言
      : NOTE
      It maintains these goals *without having a garbage collector*
      making it a useful language for a number of use cases other languages aren’t good at
        embedding in other languages, programs with specific space and time requirements
        and writing low-level code, like device drivers and operating systems
**** 安装 installation
     - 安装 install
       $ curl https://sh.rustup.rs -sSf | sh
     - 卸载 uninstalling
       $ rustup self uninstall
     - 版本号 version
       $ rustc --version
    
**** hello, world!
     - 创建项目文件夹 creating a projct directory
       $ mkdir ~/projects
       $ cd ~/projects
       $ mkdir hello_world
       $ cd hello_world
     - 编码并运行rust程序 writing and running a rust program
       Filename: main.rs

       fn main() {
           println!("Hello, world!");
       }

       $ rustc main.rs
       $ ./main
       Hello, world!
     - 分析rust程序 anatomy of a rust program
       fn main() { =// 1. The main function=
           println!("Hello, world!"); =// 2. indent  3. rust macro  4. semicolon=
       }
       : 1. The main function is special: it's the first thing that is run for every executable Rust program (entry point)
       : 2. indent with four spaces, not a tab
       : 3. when you see a ! that means that you’re calling a macro instead of a normal function (println! not println)
       : 4. The line ends with a semicolon (;)
       $ rustc main.rs
       $ ls
       main  main.rs     =# 1. source file and executable file=
       $ ./main          =# 2. rust is a ahead-of-time compiled languag=
       : 1. the source code, with the .rs extension, and the executable (the executable file)
       : 2. means that you can compile a program, give it to someone else, and they can run it even without having Rust installed
     - cargo
       $ cargo --version    =# get version of cargo installed=
       - 使用cargo创建项目 creating a project with cargo
         $ cd ~/projects
         $ cargo new hello_cargo --bin    =# 1. --bin argument=
         $ cd hello_cargo
         $ ls
         Cargo.toml  src    =# 2. toml  3. src=
         : 1. pass this to cargo because our goal is to make an executable application
         : 2. TOML is similar to INI but has some extra goodies and is used as Cargo’s configuration format
         - Cargo.toml
           [package]        =# 1. heading=
             name = "hello_cargo"
             version = "0.1.0"
             authors = ["Your Name <you@example.com>"]
           [dependencies]   =# 2. crates=
           : 1. a section heading that indicates that the following statements are configuring a package
           : 2. which is what we call packages of Rust code, so your project will depend on so that Cargo knows to download and compile
         : 3. your source files to live inside the src directory
         :    the top-level project directory is just for READMEs, license information, configuration files, and anything else not related to your code
         - src/main.rs
           fn main() {
               println!("Hello, world!");
           }
       - 构建并运行cargo项目 building and running a cargo project
         $ cargo build  =# 1. Cargo.lock=
            Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
         $ ./target/debug/hello_cargo    =# or .\target\debug\hello_cargo.exe on Windows=
         Hello, world!
         $ cargo run
            Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
              Running `target/debug/hello_cargo`  =# 2. the directory of the result of a project of building=
         Hello, world!
         : 1. causes Cargo to create a new file at the top level called Cargo.lock
         :    Cargo uses the Cargo.lock to keep track of dependencies in your application
         - Cargo.lock
           [root]
           name = "hello_cargo"
           version = "0.1.0"
         : 2. Instead of the result of the build being put in the same directory as our code, Cargo will put it in the target/debug directory.
       - 发布构建 building for release
         $ cargo build --releas    =# 1. compile your project with optimizations=
         : 1. This will create an executable in target/release instead of target/debug
         :    These optimizations make your Rust code run faster, but turning them on makes your program take longer to compile
         : NOTE
         : this is for building the final program you’ll give to a user that won't be rebuilt
         : If you're benchmarking the running time of your code, be sure to run cargo build --release and benchmark with the executable in target/release
       - 把cargo当作习惯 cargo as convention
*** 猜猜看 Guessing Game
**** 准备一个新项目 Setting Up a New Project
     - 创建项目目录
       $ cargo new guessing_game --bin  =# The --bin flag tells Cargo to make a binary project=
       $ cd guessing_game
     - Cargo.toml
       [package]
       name = "guessing_game"
       version = "0.1.0"
       authors = ["Your Name <you@example.com>"]

       [dependencies]
     - src/main.rs
       Filename: src/main.rs

       fn main() {
           println!("Hello, world!");
       }
     - cargo run
       $ cargo run
          Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
            Running `target/debug/guessing_game`
       Hello, world!
**** 处理一次猜测 Processing a Guess
     - 第一部分要求用户输入，处理输入，并检查输入是否为期望的形式
       - To start, we’ll allow the player to input a guess
         - Code to get a guess from the user and print it out
           Filename: src/main.rs
           use std::io;                               =// Using the std::io library provides you with a number of useful io-related features, including the functionality to accept user input=
           fn main() {                                =// The fn syntax declares a new function, the () indicate there are no parameters, and { starts the body of the function=
               println!("Guess the number!");         =// println! is a macro that prints a string to the screen=
               println!("Please input your guess.");  =// [[storing values with variables]]=
               let mut guess = String::new();
               io::stdin().read_line(&mut guess)
                   .expect("Failed to read line");
               println!("You guessed: {}", guess);
           }

         - <<storing values with variables>>
           : create a place to store the user input
           let mut guess = String::new();
           : let statement, which is used to create variables
           let foo = bar;
           : In Rust, variables are immutable by default. The following example shows how to use mut before the variable name to make a variable mutable
           let foo = 5; =// immutable=
           let mut bar = 5; =// mutable=
           : created a mutable variable that is currently bound to a new, empty instance of a String
           =// String  a string type provided by the standard library that is a growable, UTF-8 encoded bit of text=
           =// The :: syntax in the ::new line indicates that new is an associated function of the String type. Some languages call this a static method=
           =// This new function creates a new, empty String=
           String::new
           : call an associated function, stdin, on io
           io::stdin().read_line(&mut guess)
               .expect("Failed to read line");
           =// NOTE: If we didn’t have the use std::io line at the beginning of the program, we could have written this function call as std::io::stdin=
                    =The stdin function returns an instance of std::io::Stdin, which is a type that represents a handle to the standard input for your terminal=
           io::stdin()
           =// calls the read_line method on the standard input handle to get input from the user. We’re also passing one argument to read_line: &mut guess=
           .read_line(&mut guess)
           =// The & indicates that this argument is a reference=
                =which gives you a way to let multiple parts of your code access one piece of data without needing to copy that data into memory multiple times=
           =// references are immutable by default. Hence, we need to write &mut guess rather than &guess to make it mutable=
           &mut guess
**** 使用Result来处理潜在的错误 handling potemtial failure with the result type
* READING An Introduction to Programming in Emacs Lisp
** How To Write Function Definitions                                            :[[info:eintr#Writing%20Defuns][info:eintr#Writing Defuns]]:
*** defun
*** interactive
*** interactive "p"
*** interactive "p\ncZap to char: "
*** let
* READING tools
** idea
*** keybinding
    shift + shift     navigate | all files
    shift + F6        file | rename

    cmd + N           navigate | class
    cmd + B           navigate | declaration
    cmd + J           insert | live template

    ctrl + click      navigate | source code
    ctrl + E          view | recent file
    ctrl + J          View | Document
    ctrl + N          code | generate

    ctrl + shift + F  format | code
    ctrl + shift + U  uppercase | lowercase

    alt + /           completion
    alt + F7          find usage | particular class
    alt + F1          view | project structure or other
    alt + cmd + t     code | surround with
